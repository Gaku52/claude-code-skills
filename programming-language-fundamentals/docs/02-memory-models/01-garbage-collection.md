# ガベージコレクション（GC）

> GC は「不要になったメモリを自動的に回収する」仕組み。プログラマの負担を減らす一方、制御不能な停止時間というトレードオフがある。

## この章で学ぶこと

- [ ] GC の主要アルゴリズムを理解する
- [ ] 各言語の GC 実装の違いを把握する
- [ ] GC チューニングの基本を理解する

---

## 1. なぜ GC が必要か

```
手動メモリ管理の問題:

  1. メモリリーク（解放忘れ）
     malloc → ... → (free忘れ) → メモリ枯渇

  2. ダングリングポインタ（解放済みメモリへのアクセス）
     free(ptr) → ... → *ptr → 未定義動作

  3. 二重解放（同じメモリを2回解放）
     free(ptr) → ... → free(ptr) → クラッシュ

GC はこれらの問題を自動的に解決する
→ ただし実行時のオーバーヘッドがある
```

---

## 2. マーク&スイープ（Mark and Sweep）

```
最も基本的な GC アルゴリズム:

  Phase 1: Mark（マーク）
    ルート（スタック変数、グローバル変数）から到達可能な
    オブジェクトを全てマークする

  Phase 2: Sweep（スイープ）
    マークされていないオブジェクトを解放する

  ┌─ルート──┐
  │ a ─────→ [Obj A] ───→ [Obj B]     ← マーク済み（生存）
  │ b ─────→ [Obj C]                    ← マーク済み（生存）
  └─────────┘
               [Obj D] ───→ [Obj E]    ← 未マーク（到達不能→回収）

利点:
  ✓ 循環参照を正しく処理できる
  ✓ 実装がシンプル

欠点:
  ✗ GC 中はプログラム全体が停止（Stop-The-World）
  ✗ メモリの断片化
```

---

## 3. 世代別 GC（Generational GC）

```
「若いオブジェクトほど早く死ぬ」（世代別仮説）に基づく最適化

  Young Generation          Old Generation
  ┌──────────────┐         ┌──────────────┐
  │ Eden  │ S0│S1│         │              │
  │ (新規) │   │  │  昇格→  │  (長寿命)     │
  │       │   │  │ ─────→ │              │
  └──────────────┘         └──────────────┘
   Minor GC（高頻度・高速）   Major GC（低頻度・低速）

  1. 新規オブジェクトは Eden に配置
  2. Eden が満杯 → Minor GC（生存オブジェクトを S0 へ）
  3. 何回か Minor GC を生き延びたオブジェクト → Old へ昇格
  4. Old が満杯 → Major GC（フルGC、低速）

使用言語: Java(HotSpot), C#(.NET), JavaScript(V8)
```

### Java の GC 実装

```
┌───────────────────────────────────────────┐
│ G1 GC（Java 9+ デフォルト）                │
│ ヒープを等サイズの Region に分割            │
│ 回収効率の高い Region から優先的に回収      │
│ 目標停止時間を設定可能（-XX:MaxGCPauseMillis）│
├───────────────────────────────────────────┤
│ ZGC（Java 15+、低レイテンシ向け）           │
│ 停止時間 < 1ms（ヒープサイズに依存しない）  │
│ 数TB規模のヒープに対応                      │
│ カラーポインタ + ロードバリア                │
├───────────────────────────────────────────┤
│ Shenandoah GC                              │
│ ZGC と同等の低レイテンシ                    │
│ OpenJDK で利用可能                          │
└───────────────────────────────────────────┘
```

### V8（JavaScript）のGC

```
V8 の世代別 GC:

  Young: Scavenger（コピーGC）
    - Semi-space: From と To の2つの空間
    - From の生存オブジェクトを To にコピー
    - 2回生き延びたら Old へ昇格
    - 非常に高速（1-2ms）

  Old: Mark-Sweep-Compact
    - インクリメンタルマーキング（少しずつマーク）
    - 並行スイープ（メインスレッドを止めない）
    - コンパクション（断片化解消）

  特徴:
    - Orinoco（並行GC）でSTW時間を最小化
    - アイドル時にGCを実行（Idle-Time GC）
```

---

## 4. その他の GC アルゴリズム

### コピーGC

```
生存オブジェクトを新しい領域にコピーする

  From空間          To空間
  ┌────────┐       ┌────────┐
  │ A      │       │ A'     │  ← 生存オブジェクトをコピー
  │ (dead) │ ───→  │ C'     │
  │ C      │       │        │
  │ (dead) │       │        │
  └────────┘       └────────┘
  全体を破棄         新しい空間

利点: コンパクション不要、高速
欠点: メモリ使用量が2倍必要
```

### 並行・インクリメンタルGC

```
STW（Stop-The-World）を最小化する手法:

  インクリメンタル: GCを小さなステップに分割
    アプリ実行 → GC少し → アプリ実行 → GC少し → ...

  並行（Concurrent）: GCをバックグラウンドスレッドで実行
    メインスレッド: アプリ実行
    GCスレッド:    マーク・スイープを並行実行

  課題: 三色マーキング（白・灰・黒）で整合性を保つ
    黒: 走査済み（子も全て走査済み）
    灰: 走査中（子の走査がまだ）
    白: 未走査（GC後に白→回収対象）
```

---

## 5. Go の GC

```go
// Go: 並行マーク&スイープ GC
// 特徴:
// - 世代別ではない（シンプル）
// - 並行GC（STW < 1ms を目標）
// - 書き込みバリアで整合性保持

// GC チューニング
// GOGC=100（デフォルト: ヒープが100%成長したらGC）
// GOGC=50（より頻繁にGC → メモリ使用量削減）
// GOGC=200（GC頻度減 → スループット向上）
// GOMEMLIMIT=1GiB（Go 1.19+: メモリ上限設定）

// GC 統計の確認
import "runtime"

var m runtime.MemStats
runtime.ReadMemStats(&m)
// m.Alloc:      現在のヒープ使用量
// m.TotalAlloc: 累積確保量
// m.NumGC:      GC実行回数
// m.PauseTotalNs: GC停止時間の合計
```

---

## 6. Python の GC

```python
# Python: 参照カウント + 世代別GC

# 参照カウント（メインの仕組み）
import sys
a = [1, 2, 3]
print(sys.getrefcount(a))  # 参照カウント

# 循環参照の検出（世代別GCで補完）
import gc
gc.collect()               # 手動GC実行
gc.get_stats()             # GC統計

# 循環参照の例（参照カウントだけでは回収不可）
a = []
b = []
a.append(b)  # a → b
b.append(a)  # b → a（循環）
del a, b     # 参照カウントは1のまま → 世代別GCで回収
```

---

## 7. GC vs 手動管理 vs 所有権

```
┌──────────────┬──────────┬──────────┬──────────┐
│              │ GC       │ 手動管理  │ 所有権   │
├──────────────┼──────────┼──────────┼──────────┤
│ 安全性        │ 高い     │ 低い     │ 最も高い │
│ 性能予測性    │ 低い     │ 高い     │ 高い     │
│ 開発効率      │ 高い     │ 低い     │ 中程度   │
│ レイテンシ    │ GCパーズ │ 最良     │ 良好     │
│ メモリ効率    │ やや低い │ 最良     │ 良好     │
│ 循環参照      │ 処理可能 │ 問題なし │ 問題なし │
│ 代表言語      │ Java,Go  │ C,C++   │ Rust     │
│              │ Python,JS│          │          │
└──────────────┴──────────┴──────────┴──────────┘
```

---

## まとめ

| アルゴリズム | 特徴 | 使用言語 |
|------------|------|---------|
| マーク&スイープ | 基本。循環参照OK | 多くの言語の基盤 |
| 世代別 | 若いオブジェクトを高速回収 | Java, JS, C# |
| コピーGC | コンパクション不要 | Young世代で使用 |
| 並行GC | STW最小化 | Go, Java(ZGC) |
| 参照カウント | 即座に回収 | Python, Swift |

---

## 次に読むべきガイド
→ [[02-ownership-and-borrowing.md]] — 所有権と借用

---

## 参考文献
1. Jones, R., Hosking, A. & Moss, E. "The Garbage Collection Handbook." 2nd Ed, CRC Press, 2023.
2. "GC FAQ." oracle.com/java/technologies.
