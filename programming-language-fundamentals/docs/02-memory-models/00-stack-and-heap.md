# スタックとヒープ

> プログラムのメモリは「スタック」（高速・自動管理）と「ヒープ」（柔軟・手動/GC管理）に分かれる。この区別を理解することが、パフォーマンスとメモリ安全性の基盤となる。

## この章で学ぶこと

- [ ] スタックとヒープの違いと特性を理解する
- [ ] 各言語でのメモリ配置の違いを把握する
- [ ] メモリレイアウトを意識した効率的なコードが書ける

---

## 1. メモリレイアウト

```
プロセスのメモリ空間:

  高アドレス ┌─────────────────────┐
             │    カーネル空間      │
             ├─────────────────────┤
             │    スタック ↓        │  ← 自動管理、高速、サイズ制限
             │    (Stack)          │     関数のローカル変数、引数
             │                     │
             │    ↓ 成長方向       │
             │         ↑           │
             │    ↑ 成長方向       │
             │                     │
             │    ヒープ ↑         │  ← 動的管理、柔軟、大きなデータ
             │    (Heap)           │     new/malloc で確保
             ├─────────────────────┤
             │    BSS              │  ← 未初期化グローバル変数
             ├─────────────────────┤
             │    Data             │  ← 初期化済みグローバル変数
             ├─────────────────────┤
             │    Text (Code)      │  ← プログラムの命令コード
  低アドレス └─────────────────────┘
```

---

## 2. スタック（Stack）

```
特徴:
  - LIFO（Last In, First Out）
  - 自動的に確保・解放（関数の開始/終了時）
  - 非常に高速（ポインタの加減算のみ）
  - サイズ制限あり（通常 1〜8 MB）
  - 連続したメモリ領域

格納されるもの:
  - 関数の引数
  - ローカル変数（固定サイズ）
  - 戻りアドレス
  - フレームポインタ
```

```c
// C: スタック上の変数
void example() {
    int x = 42;           // スタック上に 4 バイト確保
    double y = 3.14;      // スタック上に 8 バイト確保
    char buf[256];        // スタック上に 256 バイト確保
}  // 関数終了時に全て自動解放

// 関数呼び出しのスタックフレーム:
// ┌──────────────────┐ ← SP（スタックポインタ）
// │ buf[256]         │
// │ y (3.14)         │
// │ x (42)           │
// │ 戻りアドレス      │
// │ 前のフレームポインタ│
// ├──────────────────┤ ← 呼び出し元のフレーム
```

```rust
// Rust: スタック上のデータ
fn example() {
    let x: i32 = 42;          // スタック（4バイト）
    let point = (3.0, 4.0);   // スタック（16バイト）
    let arr = [1, 2, 3, 4, 5]; // スタック（20バイト）
}  // 全て自動解放
```

---

## 3. ヒープ（Heap）

```
特徴:
  - 動的にサイズを決定できる
  - プログラマ（またはGC）が管理
  - スタックより低速（アロケータの管理コスト）
  - サイズ制限は物理メモリまで
  - 断片化の問題がある

格納されるもの:
  - 動的サイズのデータ（文字列、配列、コレクション）
  - オブジェクト（多くの言語で）
  - 関数の寿命を超えて生存するデータ
```

```c
// C: ヒープの手動管理
void example() {
    // malloc でヒープに確保
    int *arr = (int *)malloc(100 * sizeof(int));
    if (arr == NULL) {
        // メモリ確保失敗
        return;
    }

    arr[0] = 42;

    // 必ず free で解放（忘れるとメモリリーク）
    free(arr);
    arr = NULL;  // ダングリングポインタ防止
}
```

```rust
// Rust: Box でヒープに確保
fn example() {
    let x = Box::new(42);     // ヒープに i32 を確保
    let s = String::from("hello"); // ヒープに文字列を確保
    let v = vec![1, 2, 3];    // ヒープに配列を確保

    // スコープを抜けると自動的に解放（所有権システム）
}
```

```python
# Python: ほぼ全てがヒープ
x = 42           # ヒープ上の int オブジェクト
s = "hello"      # ヒープ上の str オブジェクト
lst = [1, 2, 3]  # ヒープ上の list オブジェクト

# GC が自動的に解放
# プログラマはメモリ管理を意識しなくてよい
```

---

## 4. 言語ごとのメモリ配置

```
┌────────────────┬────────────────────┬──────────────────┐
│ 言語            │ スタック            │ ヒープ             │
├────────────────┼────────────────────┼──────────────────┤
│ C / C++        │ プリミティブ型      │ malloc/new        │
│                │ 固定サイズ配列      │ 動的配列          │
│                │ 構造体              │ ポインタ経由      │
├────────────────┼────────────────────┼──────────────────┤
│ Rust           │ プリミティブ型      │ Box<T>           │
│                │ 固定サイズ型        │ String, Vec<T>   │
│                │ 参照（&T）         │ Rc<T>, Arc<T>    │
├────────────────┼────────────────────┼──────────────────┤
│ Go             │ エスケープ解析で決定│ エスケープ解析で決定│
│                │ （コンパイラが最適化）│                  │
├────────────────┼────────────────────┼──────────────────┤
│ Java           │ プリミティブ型      │ 全オブジェクト    │
│                │ 参照変数自体        │ 配列、String      │
├────────────────┼────────────────────┼──────────────────┤
│ Python/Ruby    │ （ほぼ使わない）    │ 全オブジェクト    │
│ JavaScript     │                    │                  │
└────────────────┴────────────────────┴──────────────────┘
```

### Go のエスケープ解析

```go
// Go: コンパイラが自動的にスタック/ヒープを決定
func example() *int {
    x := 42       // x は関数外に返されるためヒープに配置
    return &x     // エスケープ解析: x がエスケープする
}

func local() {
    x := 42       // x は関数内でのみ使用 → スタックに配置
    fmt.Println(x)
}

// go build -gcflags="-m" で確認可能
// ./main.go:3:2: moved to heap: x
```

---

## 5. スタックオーバーフロー

```
スタックのサイズは制限されている（通常1〜8MB）

原因:
  1. 深すぎる再帰
  2. スタック上の巨大な配列
  3. 相互再帰

対策:
  - 再帰の代わりにループを使う
  - 末尾再帰最適化（TCO）がある言語を使う
  - 大きなデータはヒープに置く
```

```rust
// スタックオーバーフローの例
fn infinite_recursion(n: i32) -> i32 {
    infinite_recursion(n + 1)  // 終了条件なし → スタックオーバーフロー
}

// 巨大なスタック確保
fn big_stack() {
    let arr = [0u8; 10_000_000];  // 10MB → スタックオーバーフロー
    // 解決: let arr = vec![0u8; 10_000_000]; // ヒープに配置
}
```

---

## まとめ

| 特性 | スタック | ヒープ |
|------|---------|--------|
| 速度 | 非常に高速 | 低速（アロケーション） |
| 管理 | 自動（LIFO） | 手動/GC |
| サイズ | 制限あり（1-8MB） | 大きい（物理メモリまで） |
| 寿命 | 関数スコープ | 任意（参照がある限り） |
| 用途 | ローカル変数・引数 | 動的データ・オブジェクト |

---

## 次に読むべきガイド
→ [[01-garbage-collection.md]] — ガベージコレクション

---

## 参考文献
1. Bryant, R. & O'Hallaron, D. "Computer Systems: A Programmer's Perspective." 3rd Ed, Ch.9, 2015.
2. Klabnik, S. & Nichols, C. "The Rust Programming Language." Ch.4, 2023.
