# プログラミング言語とは何か

> プログラミング言語は「人間の意図をコンピュータに伝える」ための形式言語であり、同時に「人間が思考を構造化する」ための道具でもある。

## この章で学ぶこと

- [ ] プログラミング言語の本質的な役割を理解する
- [ ] 言語の抽象化レベルと設計思想の違いを把握する
- [ ] 言語を構成する要素（構文・意味論・プラグマティクス）を理解する

---

## 1. なぜプログラミング言語が必要か

### コンピュータが理解するのは機械語

```
コンピュータの実行レベル:

  人間の意図:    「Webサーバーを起動して、ポート8080で待ち受けて」
       ↓
  高水準言語:    server.listen(8080)
       ↓
  中間表現:      バイトコード / IR
       ↓
  アセンブリ:    mov eax, 0x1F90 / syscall
       ↓
  機械語:        10111000 10010000 00011111 00000000 00000000
       ↓
  ハードウェア:  電気信号 (High/Low)
```

プログラミング言語は、この**抽象化の階段**を提供する。高水準になるほど人間にとって理解しやすく、低水準になるほどハードウェアに近い制御ができる。

### 抽象化のトレードオフ

```
高水準    Python, Ruby, JavaScript
  ↑      生産性は高いが、実行効率の制御は限定的
  │
  │      Java, C#, Go
  │      バランス型。十分な抽象化と合理的な性能
  │
  │      C, C++, Rust
  │      低レベル制御が可能だが、習得コストが高い
  ↓
低水準    アセンブリ言語
          ハードウェア直接制御。最高の効率だが人間には読みにくい
```

---

## 2. 言語を構成する3つの側面

### 2.1 構文（Syntax）

言語の「文法」。何が正しいプログラムの形か。

```python
# Python: インデントでブロック構造
def greet(name):
    if name:
        print(f"Hello, {name}!")
    else:
        print("Hello, World!")
```

```rust
// Rust: 波括弧でブロック構造
fn greet(name: &str) {
    if !name.is_empty() {
        println!("Hello, {}!", name);
    } else {
        println!("Hello, World!");
    }
}
```

```lisp
;; Lisp: S式（全てが括弧）
(defun greet (name)
  (if name
      (format t "Hello, ~a!" name)
      (format t "Hello, World!")))
```

同じロジックでも、構文が異なると**思考のパターン**が変わる。

### 2.2 意味論（Semantics）

プログラムの「意味」。実行すると何が起こるか。

```javascript
// JavaScriptの意味論の罠
"5" + 3       // → "53"（文字列結合）
"5" - 3       // → 2（数値演算）

[] + []        // → ""
[] + {}        // → "[object Object]"
{} + []        // → 0
```

```python
# Pythonの意味論
"5" + 3       # → TypeError（型の安全性）
```

意味論の設計が言語の「安全性」と「驚きの少なさ」を決める。

### 2.3 プラグマティクス（Pragmatics）

言語の「実践的な側面」。エコシステム、ツール、コミュニティ。

```
言語選択に影響する実践的要素:

  ライブラリ:     npm（JS: 200万+パッケージ）
                  PyPI（Python: 50万+パッケージ）
                  crates.io（Rust: 15万+パッケージ）

  ツールチェーン: コンパイラ、リンター、フォーマッタ、デバッガ
  IDE サポート:   補完、型チェック、リファクタリング
  コミュニティ:   ドキュメント、Stack Overflow、GitHub
  採用市場:       求人数、給与水準
  実行環境:       ブラウザ、サーバー、組み込み、モバイル
```

---

## 3. 言語の分類

### 実行方式による分類

```
┌─────────────────────────────────────────────────────┐
│ コンパイル型                                          │
│ ソースコード → コンパイラ → 機械語 → 実行              │
│ 例: C, C++, Rust, Go, Swift                          │
│ 利点: 高速実行、事前エラー検出                         │
│ 欠点: コンパイル時間、プラットフォーム依存              │
├─────────────────────────────────────────────────────┤
│ インタプリタ型                                        │
│ ソースコード → インタプリタ → 逐次実行                 │
│ 例: Python, Ruby, PHP, Perl                          │
│ 利点: 即座に実行、対話的開発                          │
│ 欠点: 実行速度、実行時エラー                          │
├─────────────────────────────────────────────────────┤
│ JIT コンパイル型                                      │
│ ソースコード → バイトコード → JIT → 機械語             │
│ 例: Java, C#, JavaScript(V8), Python(PyPy)           │
│ 利点: ポータビリティ + 実行時最適化                    │
│ 欠点: ウォームアップ時間、メモリ消費                   │
├─────────────────────────────────────────────────────┤
│ トランスパイル型                                      │
│ ソースコード → 別の高水準言語 → 実行                   │
│ 例: TypeScript→JS, Kotlin→JVM/JS, Elm→JS            │
│ 利点: 言語間の良いとこ取り                            │
└─────────────────────────────────────────────────────┘
```

### パラダイムによる分類

```
┌─────────────┬─────────────────────────────────────────┐
│ パラダイム    │ 特徴と代表言語                          │
├─────────────┼─────────────────────────────────────────┤
│ 手続き型     │ 命令の順次実行。C, Pascal, BASIC        │
│ オブジェクト │ データと振る舞いの結合。Java, C#, Ruby  │
│  指向        │                                         │
│ 関数型       │ 純粋関数と不変性。Haskell, Elm, Erlang │
│ 論理型       │ 論理式による記述。Prolog, Datalog       │
│ マルチ       │ 複数パラダイム対応。Python, Scala,      │
│  パラダイム  │ Rust, Kotlin, Swift, TypeScript         │
└─────────────┴─────────────────────────────────────────┘
```

---

## 4. 言語設計のトレードオフ

### 安全性 vs 自由度

```
最大安全性                                    最大自由度
  ←──────────────────────────────────────→
  Haskell  Rust  Java  Go  Python  C  Assembly

  Haskell: 副作用をモナドで管理。型で不正を排除
  Rust:    所有権システムでメモリ安全を保証
  Java:    GCでメモリ管理。NullPointerExceptionは残る
  Go:      シンプルだが nil パニックの可能性
  Python:  動的型で自由だがランタイムエラーのリスク
  C:       メモリを直接操作。バッファオーバーフロー可能
```

### 表現力 vs 可読性

```python
# Python: 可読性を重視（"There should be one obvious way to do it"）
result = [x * 2 for x in numbers if x > 0]
```

```perl
# Perl: 表現力を重視（"There's more than one way to do it"）
@result = map { $_ * 2 } grep { $_ > 0 } @numbers;
```

```haskell
-- Haskell: 数学的な表現力
result = map (*2) . filter (>0) $ numbers
```

### 暗黙 vs 明示

```python
# Python: 鋳型の動作は暗黙的
x = 5           # 型推論（暗黙）
x = "hello"     # 型が変わる（動的型付け）
```

```rust
// Rust: 全てが明示的
let x: i32 = 5;                     // 型を明示
let y = 5;                          // 推論可能な場合は省略可
// let x = "hello";                 // コンパイルエラー（型が異なる）
let x: &str = "hello";             // 再宣言（シャドウイング）
```

---

## 5. 言語選択の思考フレームワーク

```
プロジェクトに最適な言語を選ぶ判断基準:

  1. ドメイン適合性
     Web フロント    → JavaScript/TypeScript
     Web バック      → Go, Python, Node.js, Java
     システム        → Rust, C++, C
     データ分析      → Python, R, Julia
     モバイル        → Swift(iOS), Kotlin(Android)

  2. チームの習熟度
     チームが得意な言語 > 理論上最適な言語
     学習コスト・採用コストを含めて判断

  3. エコシステムの充実度
     必要なライブラリ・フレームワークがあるか
     ツールチェーン（ビルド・テスト・デプロイ）の成熟度

  4. パフォーマンス要件
     リアルタイム / 低レイテンシ → C++, Rust, Go
     バッチ処理 / スクリプト → Python, Ruby
     高スループット → Go, Java, Rust

  5. 長期保守性
     型安全性、ドキュメント、コミュニティの活発さ
     10年後もサポートされているか
```

---

## 実践演習

### 演習1: [基礎] — 同じアルゴリズムを3言語で書く
FizzBuzzを Python, JavaScript, Rust で実装し、構文の違いを比較する。

### 演習2: [応用] — 言語の実行速度比較
フィボナッチ数列の計算を複数言語で実装し、実行時間を計測する。

### 演習3: [発展] — 言語選定レポート
架空のプロジェクト（例: リアルタイムチャットアプリ）に最適な言語を選定し、根拠を述べる。

---

## FAQ

### Q1: 最初に学ぶべき言語は？
A: Python（読みやすさとエコシステムの広さ）か JavaScript（Webの普遍性）が推奨。重要なのは1つの言語を深く学ぶこと。2つ目以降の言語は格段に習得しやすくなる。

### Q2: 言語は何個覚えるべき？
A: 3〜5言語を異なるパラダイムから選ぶのが理想。例: Python（動的スクリプト） + TypeScript（静的Web） + Rust（システム） + SQL（データ）。

### Q3: 新しい言語はどうやって学ぶ？
A: 「構文→型システム→メモリモデル→並行処理→エコシステム」の順で学ぶと効率的。既知の言語との差分に注目する。

---

## まとめ

| 観点 | ポイント |
|------|---------|
| 言語の役割 | 抽象化の階段を提供する |
| 3つの側面 | 構文・意味論・プラグマティクス |
| 実行方式 | コンパイル / インタプリタ / JIT |
| パラダイム | 手続き / OOP / 関数型 / マルチ |
| 設計トレードオフ | 安全性 vs 自由度、明示 vs 暗黙 |
| 言語選択 | ドメイン・チーム・エコシステム・性能・保守性 |

---

## 次に読むべきガイド
→ [[01-compilation-vs-interpretation.md]] — コンパイルとインタプリタ

---

## 参考文献
1. Abelson, H. & Sussman, G. "Structure and Interpretation of Computer Programs." MIT Press, 1996.
2. Pierce, B. "Types and Programming Languages." MIT Press, 2002.
3. Van Roy, P. & Haridi, S. "Concepts, Techniques, and Models of Computer Programming." MIT Press, 2004.
