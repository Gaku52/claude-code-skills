# 並行モデル概要

> プログラムが「複数のことを同時に行う」ための3つの主要モデル: マルチスレッド、イベントループ、アクターモデル。それぞれの仕組み、利点、欠点を比較する。

## この章で学ぶこと

- [ ] 並行（Concurrency）と並列（Parallelism）の違いを理解する
- [ ] 3つの主要な並行モデルの特徴を把握する
- [ ] 各モデルが得意なユースケースを学ぶ

---

## 1. 並行 vs 並列

```
並行（Concurrency）:
  → 複数のタスクを「切り替えながら」進める
  → 1つのCPUコアでも可能
  → 「構造」の問題

  コア1: [タスクA] [タスクB] [タスクA] [タスクC] [タスクB]

並列（Parallelism）:
  → 複数のタスクを「同時に」実行する
  → 複数のCPUコアが必要
  → 「実行」の問題

  コア1: [タスクA] [タスクA] [タスクA]
  コア2: [タスクB] [タスクB] [タスクB]
  コア3: [タスクC] [タスクC] [タスクC]

Rob Pike（Go設計者）:
  「Concurrency is about dealing with lots of things at once.
   Parallelism is about doing lots of things at once.」
  （並行性は多くのことを一度に扱うこと。
   並列性は多くのことを一度にやること。）
```

---

## 2. マルチスレッドモデル

```
仕組み:
  → OSスレッドを複数生成
  → 共有メモリでデータを交換
  → ロック（Mutex）で排他制御

  Thread 1 ─────────────────────────→
  Thread 2 ─────────────────────────→
  Thread 3 ─────────────────────────→
       ↕ 共有メモリ ↕
  ┌──────────────────┐
  │  Shared State    │ ← Mutex でロック
  └──────────────────┘

利点:
  ✓ 真の並列実行（マルチコア活用）
  ✓ CPU集約型に適する

欠点:
  ✗ 共有状態のロック管理が複雑
  ✗ デッドロック、レースコンディション
  ✗ スレッド生成のオーバーヘッド（~1MB/スレッド）
  ✗ デバッグ困難

代表: Java, C++, Python(GILあり), Rust
```

---

## 3. イベントループモデル

```
仕組み:
  → シングルスレッドでイベントキューを処理
  → I/Oはノンブロッキング（OSに委任）
  → I/O完了時にコールバックをキューに追加

  ┌──────────────────────────────────────┐
  │           イベントループ              │
  │  ┌──────────────────────────────┐   │
  │  │ 1. コールスタック実行         │   │
  │  │ 2. マイクロタスク処理         │   │
  │  │ 3. マクロタスク1つ実行        │   │
  │  │ 4. → 1に戻る                 │   │
  │  └──────────────────────────────┘   │
  │         ↑ 完了通知                   │
  │  ┌──────────────────────────────┐   │
  │  │ OS / libuv（I/O管理）         │   │
  │  │ ネットワーク、ファイル、タイマー│   │
  │  └──────────────────────────────┘   │
  └──────────────────────────────────────┘

利点:
  ✓ 共有状態のロック不要（シングルスレッド）
  ✓ 大量の同時接続に強い（C10K問題の解決）
  ✓ メモリ効率が良い

欠点:
  ✗ CPU集約型に不向き（イベントループをブロック）
  ✗ マルチコアを直接活用できない
  ✗ コールバック地獄（async/awaitで改善）

代表: JavaScript(Node.js/ブラウザ), Python(asyncio)
```

---

## 4. アクターモデル

```
仕組み:
  → 全てが「アクター」（独立したプロセス）
  → アクター間はメッセージパッシングで通信
  → 共有状態なし（各アクターが自分の状態を持つ）

  ┌─────────┐  メッセージ  ┌─────────┐
  │ Actor A │────────────→│ Actor B │
  │ state_a │             │ state_b │
  └─────────┘             └─────────┘
       │                       │
       │  メッセージ            │ メッセージ
       ↓                       ↓
  ┌─────────┐             ┌─────────┐
  │ Actor C │             │ Actor D │
  │ state_c │             │ state_d │
  └─────────┘             └─────────┘

利点:
  ✓ 共有状態なし（ロック不要）
  ✓ 分散システムに自然に拡張
  ✓ 耐障害性（アクターの再起動）
  ✓ スケーラビリティ

欠点:
  ✗ メッセージパッシングのオーバーヘッド
  ✗ デバッグが難しい（非同期メッセージ）
  ✗ 学習コストが高い

代表: Erlang/Elixir(BEAM), Akka(Scala/Java)
```

---

## 5. CSP（Communicating Sequential Processes）

```
仕組み:
  → 軽量スレッド（goroutine）× 多数
  → チャネルでデータを送受信
  → 「メモリを共有して通信するな、通信してメモリを共有しろ」

  goroutine 1 ───→ [channel] ───→ goroutine 2
  goroutine 3 ───→ [channel] ───→ goroutine 4

利点:
  ✓ 軽量（goroutine: ~2KB、スレッド: ~1MB）
  ✓ チャネルによる安全な通信
  ✓ ランタイムが自動スケジューリング

代表: Go, Clojure(core.async)
```

---

## 6. 比較と選択

```
┌──────────────┬────────────┬────────────┬────────────┬────────────┐
│              │ マルチ     │ イベント   │ アクター   │ CSP        │
│              │ スレッド   │ ループ     │ モデル     │            │
├──────────────┼────────────┼────────────┼────────────┼────────────┤
│ CPU集約      │ ◎         │ △         │ ○         │ ◎         │
├──────────────┼────────────┼────────────┼────────────┼────────────┤
│ I/O集約      │ ○         │ ◎         │ ◎         │ ◎         │
├──────────────┼────────────┼────────────┼────────────┼────────────┤
│ 同時接続数   │ ~千        │ ~十万      │ ~百万      │ ~百万      │
├──────────────┼────────────┼────────────┼────────────┼────────────┤
│ 安全性       │ 低(ロック) │ 中         │ 高         │ 高         │
├──────────────┼────────────┼────────────┼────────────┼────────────┤
│ デバッグ     │ 困難       │ 中程度     │ 困難       │ 中程度     │
└──────────────┴────────────┴────────────┴────────────┴────────────┘

選択指針:
  Web API（I/O集約）→ イベントループ or CSP
  リアルタイム通信 → アクターモデル
  画像/動画処理 → マルチスレッド
  マイクロサービス → アクターモデル or CSP
```

---

## まとめ

| モデル | 核心 | 代表言語 |
|--------|------|---------|
| マルチスレッド | 共有メモリ + ロック | Java, C++, Rust |
| イベントループ | シングルスレッド + 非同期I/O | JS, Python |
| アクターモデル | メッセージパッシング | Erlang, Elixir |
| CSP | 軽量スレッド + チャネル | Go |

---

## 次に読むべきガイド
→ [[../01-async-patterns/00-callbacks.md]] — コールバック

---

## 参考文献
1. Hoare, C.A.R. "Communicating Sequential Processes." 1978.
2. Hewitt, C. "A Universal Modular Actor Formalism." 1973.
