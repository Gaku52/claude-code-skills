# プロンプト駆動開発 ── 仕様からプロンプトへ、プロンプトからコードへ

> ソフトウェア開発の起点を「コードを書くこと」から「プロンプトを設計すること」へ移行させ、仕様→プロンプト→コード→検証の新しい開発サイクルを体系的に習得する。

---

## この章で学ぶこと

1. **プロンプト駆動開発（PDD）のプロセス** ── 仕様定義からコード生成までの一貫したワークフローを理解する
2. **効果的なプロンプト設計パターン** ── 再現性と品質を高めるプロンプトテンプレートを習得する
3. **プロンプトの反復改善手法** ── AIの出力品質を段階的に向上させるテクニックを身につける

---

## 1. プロンプト駆動開発（PDD）とは

### 1.1 開発パラダイムの変遷

```
手続型開発          オブジェクト指向      テスト駆動開発(TDD)   プロンプト駆動開発(PDD)
(1960s-)           (1990s-)            (2000s-)            (2024s-)

コード → 動作      設計 → コード        テスト → コード      プロンプト → コード

┌──────┐          ┌──────┐           ┌──────┐            ┌──────────┐
│手続き │          │クラス │           │Red   │            │ 仕様定義  │
│を書く │          │設計  │           │Green │            │    ↓     │
│  ↓   │          │  ↓   │           │Refac │            │プロンプト │
│デバッグ│          │実装  │           │ tor  │            │    ↓     │
└──────┘          └──────┘           └──────┘            │AI生成    │
                                                         │    ↓     │
                                                         │検証・改善 │
                                                         └──────────┘
```

### 1.2 PDDのワークフロー

```
┌──────────────────────────────────────────────────────┐
│              プロンプト駆動開発サイクル                  │
│                                                      │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐         │
│   │ 1.仕様  │───►│2.プロン │───►│ 3.生成  │         │
│   │  定義   │    │ プト設計│    │ (AI)    │         │
│   └─────────┘    └─────────┘    └────┬────┘         │
│        ▲                              │              │
│        │                              ▼              │
│   ┌─────────┐    ┌─────────┐    ┌─────────┐         │
│   │ 6.統合  │◄───│5.改善   │◄───│ 4.検証  │         │
│   │         │    │(反復)   │    │ (人間)  │         │
│   └─────────┘    └─────────┘    └─────────┘         │
│                                                      │
│   各ステップの所要時間:                                │
│   仕様(10min) → プロンプト(5min) → 生成(1min)        │
│   → 検証(5min) → 改善(3min) → 統合(5min)            │
│   合計: 約30分 (従来: 2-4時間)                        │
└──────────────────────────────────────────────────────┘
```

---

## 2. プロンプト設計パターン

### コード例1: 基本テンプレート（CRISP形式）

```markdown
# CRISP プロンプトテンプレート

## Context（文脈）
- プロジェクト: ECサイトの注文管理システム
- 技術スタック: Python 3.12, FastAPI, SQLAlchemy, PostgreSQL
- 既存コードの規約: PEP 8準拠、型ヒント必須、docstring必須

## Role（AIの役割）
あなたはシニアバックエンドエンジニアです。
クリーンアーキテクチャとDDDに精通しています。

## Intent（意図・目的）
注文のキャンセル機能を実装したい。
キャンセル可能な条件（発送前のみ）を厳密にチェックし、
在庫の復元とユーザーへの通知も行う必要がある。

## Specifics（具体的要件）
- エンドポイント: POST /api/v1/orders/{order_id}/cancel
- キャンセル条件: ステータスが "pending" または "confirmed" のみ
- 副作用: 在庫数の復元、キャンセルメールの送信
- エラー: 既にキャンセル済み(409)、発送済み(422)

## Pattern（出力形式）
- ドメイン層、ユースケース層、プレゼンテーション層に分離
- 各層のファイルを別々に出力
- テストコードも含める
```

### コード例2: 段階的詳細化パターン

```python
# === ステップ1: 大枠の設計を依頼 ===
prompt_step1 = """
注文キャンセル機能の設計を以下の観点で提案してください:
1. ドメインモデルの変更点
2. ユースケースのフロー
3. 必要なインターフェース
コードは不要。箇条書きで構造だけ示してください。
"""

# === ステップ2: 設計をレビューしてコード生成 ===
prompt_step2 = """
上記の設計に同意します。以下の修正を加えてコードを生成してください:
- OrderCancelledイベントを追加
- 冪等性を保証する（同じリクエストを2回送っても安全）
- CancelReasonをenumで定義
"""

# === ステップ3: テストとエッジケース ===
prompt_step3 = """
生成されたコードに対して以下のテストを作成してください:
1. 正常系: pending状態の注文をキャンセル
2. 正常系: confirmed状態の注文をキャンセル
3. 異常系: shipped状態の注文をキャンセル試行
4. 異常系: 既にキャンセル済みの注文を再キャンセル
5. 境界: 在庫が0の商品を含む注文のキャンセル
6. 並行: 同時に2つのキャンセルリクエスト
"""
```

### コード例3: コンテキスト注入パターン

```markdown
# 既存コードをコンテキストとして提供し、一貫性を保つ

## 既存のドメインモデル（参考）
```python
# domain/order.py の既存コード
class Order:
    def __init__(self, order_id: OrderId, items: list[OrderItem]):
        self._id = order_id
        self._items = items
        self._status = OrderStatus.PENDING
        self._events: list[DomainEvent] = []

    def confirm(self) -> None:
        if self._status != OrderStatus.PENDING:
            raise OrderAlreadyConfirmedException(self._id)
        self._status = OrderStatus.CONFIRMED
        self._events.append(OrderConfirmed(self._id))
```

## 依頼
上記の既存パターン（イベント発行、例外クラス、命名規則）に
完全に一致する形で `cancel` メソッドを追加してください。
既存コードとの差分のみを出力してください。
```

### コード例4: 制約指定パターン

```python
# AIの出力を制約で制御する

PROMPT_WITH_CONSTRAINTS = """
以下の制約に従ってReactコンポーネントを作成してください。

## 機能要件
ユーザー一覧テーブル（検索・ソート・ページネーション付き）

## 制約条件（必ず守ること）
- DO: TypeScript strict mode で型安全にする
- DO: TanStack Table v8 を使う
- DO: サーバーサイドページネーション対応
- DO: ローディング・エラー・空状態の3つのUIステートを実装
- DO: アクセシビリティ（aria属性）を含める

- DON'T: any型を使わない
- DON'T: useEffectの中でデータフェッチしない（TanStack Queryを使う）
- DON'T: CSSをインラインで書かない（Tailwind CSSを使う）
- DON'T: 1コンポーネント200行を超えない
"""
```

### コード例5: プロンプトのバージョン管理

```yaml
# .prompts/order-cancel.yaml
# プロンプトをコードと同様にバージョン管理する

metadata:
  id: order-cancel-v3
  author: "team-backend"
  created: "2025-03-15"
  model: "claude-sonnet-4-20250514"
  quality_score: 0.92  # 過去の出力品質スコア

context:
  project: "ec-platform"
  module: "order-management"
  conventions: |
    - Clean Architecture (domain / usecase / infra / presentation)
    - Domain events for side effects
    - Result type for error handling (no exceptions in domain layer)

prompt: |
  注文キャンセルのユースケースを実装してください。

  入力: order_id (UUID), reason (CancelReason enum), cancelled_by (UserId)
  出力: Result[CancelledOrder, CancelError]

  ビジネスルール:
  1. キャンセル可能なステータス: PENDING, CONFIRMED
  2. 発送後はキャンセル不可 → ReturnRequestへ誘導
  3. キャンセル時に在庫を復元
  4. OrderCancelledイベントを発行

  制約:
  - 冪等性を保証すること
  - 楽観ロックでの並行制御

validation:
  - "CancelError型が定義されていること"
  - "Result型で返していること"
  - "DomainEventが発行されていること"
  - "テストが5件以上含まれていること"
```

---

## 3. プロンプト品質の評価基準

### 3.1 CLEAR基準

| 基準 | 説明 | チェック項目 |
|------|------|-------------|
| **C**oncrete（具体的） | 曖昧さがない | 入出力の型、エラーケースが明記されているか |
| **L**ayered（段階的） | 複雑さを分解 | 1プロンプトの責務が適切に限定されているか |
| **E**xample-rich（例が豊富） | 期待する形式を示す | 入出力例やコードスニペットが含まれているか |
| **A**ctionable（実行可能） | 即座にコードに変換可能 | AIが追加質問なしに実装できるか |
| **R**eproducible（再現可能） | 誰が実行しても同じ結果 | モデル、バージョン、コンテキストが固定されているか |

### 3.2 プロンプト品質 vs コード品質の相関

| プロンプト品質 | コード品質の傾向 | 修正回数 | 総所要時間 |
|--------------|----------------|---------|-----------|
| 曖昧（1行） | 動くが設計が悪い | 5-10回 | 従来と同等 |
| 基本的（要件列挙） | 機能は正しい | 2-3回 | 従来の50% |
| 構造化（CRISP） | 設計も品質も高い | 0-1回 | 従来の25% |
| 完全（例+制約付き） | プロダクション品質 | 0回 | 従来の15% |

---

## 4. 反復改善のテクニック

### 4.1 フィードバックループ

```
┌────────────────────────────────────────────────┐
│          プロンプト反復改善プロセス               │
│                                                │
│  Round 1: 初回生成                              │
│  ┌──────────┐    ┌──────────┐                  │
│  │プロンプト │───►│  出力    │──► 評価: 60点    │
│  │ (v1)     │    │ (Draft1) │                  │
│  └──────────┘    └──────────┘                  │
│       │                                        │
│       │ 修正: "エラーハンドリングが不足"          │
│       ▼                                        │
│  Round 2: 改善                                  │
│  ┌──────────┐    ┌──────────┐                  │
│  │プロンプト │───►│  出力    │──► 評価: 80点    │
│  │ (v2)     │    │ (Draft2) │                  │
│  └──────────┘    └──────────┘                  │
│       │                                        │
│       │ 修正: "テストのエッジケース追加"          │
│       ▼                                        │
│  Round 3: 完成                                  │
│  ┌──────────┐    ┌──────────┐                  │
│  │プロンプト │───►│  出力    │──► 評価: 95点    │
│  │ (v3)     │    │ (Final)  │                  │
│  └──────────┘    └──────────┘                  │
└────────────────────────────────────────────────┘
```

---

## アンチパターン

### アンチパターン 1: ワンショット万能プロンプト

```markdown
# BAD: 1つのプロンプトで全てを解決しようとする
"ECサイトの全機能を実装して。ユーザー管理、商品管理、注文管理、
決済連携、在庫管理、レコメンド、通知機能を含めて。
フロントはReact、バックはFastAPI、DBはPostgreSQLで。"

# → 出力が膨大かつ品質が低い。コンテキスト制限にも引っかかる。

# GOOD: 機能単位で分割し、依存関係順に生成する
"Step 1: ドメインモデル（User, Product, Order）の定義"
"Step 2: Userの CRUD API実装"
"Step 3: Productの CRUD API実装（Step 2の規約に従う）"
# ...段階的に構築
```

### アンチパターン 2: コンテキスト不足プロンプト

```markdown
# BAD: プロジェクト固有の情報を提供しない
"ログイン機能を作って"

# → 汎用的すぎるコードが生成され、既存コードと整合しない

# GOOD: 既存コードと規約をコンテキストとして提供
"以下の既存認証モジュール（auth/service.py）のパターンに従い、
OAuth2.0によるGoogleログイン機能を追加してください。
既存のSessionManagerを再利用し、UserRepositoryに
google_idフィールドを追加する想定です。"
```

---

## FAQ

### Q1: PDDはTDD（テスト駆動開発）と併用できるか？

完全に併用可能であり、むしろ相性が良い。手順は「(1) テストの仕様をプロンプトで記述 → (2) AIがテストコードを生成 → (3) テストの正しさを人間がレビュー → (4) 実装コードをプロンプトで生成 → (5) テストが通ることを確認」となる。TDDの「Red→Green→Refactor」サイクルの各段階でAIを活用できる。

### Q2: プロンプトの再利用性を高めるにはどうすればよいか？

3つの方法がある。(1) テンプレート化: CRISPなどの形式でチーム共有テンプレートを作成、(2) パラメータ化: 変数部分を `{entity_name}` のようにプレースホルダーにする、(3) バージョン管理: `.prompts/` ディレクトリでGit管理し、品質スコアをメタデータとして記録する。

### Q3: プロンプトの品質をチーム内でどう標準化すればよいか？

「プロンプトレビュー」をコードレビューと同様のプロセスとして導入する。CLEAR基準によるチェックリストを作成し、PRにプロンプトも含める。優れたプロンプトはチームWikiに登録し、パターンライブラリとして蓄積する。月次で「プロンプト品質向上会」を実施し、ベストプラクティスを更新する。

---

## まとめ

| 項目 | 要点 |
|------|------|
| PDDの定義 | 仕様→プロンプト→生成→検証のサイクルで開発する手法 |
| 設計パターン | CRISP形式、段階的詳細化、コンテキスト注入、制約指定 |
| 品質基準 | CLEAR（具体的・段階的・例付き・実行可能・再現可能） |
| 反復改善 | 平均2-3回の改善で95点品質に到達 |
| バージョン管理 | プロンプトもコードと同様にGit管理する |
| 注意点 | ワンショット禁止、コンテキスト必須 |

---

## 次に読むべきガイド

- [../01-ai-coding/00-github-copilot.md](../01-ai-coding/00-github-copilot.md) ── GitHub Copilotでのプロンプト実践
- [../01-ai-coding/01-claude-code.md](../01-ai-coding/01-claude-code.md) ── Claude Codeでの高度なPDD
- [../02-workflow/00-ai-testing.md](../02-workflow/00-ai-testing.md) ── PDD+TDDの統合アプローチ

---

## 参考文献

1. Elvis Saravia, "Prompt Engineering Guide," 2024. https://www.promptingguide.ai/
2. Anthropic, "Prompt Engineering Documentation," 2025. https://docs.anthropic.com/en/docs/build-with-claude/prompt-engineering
3. Lilian Weng, "Prompt Engineering," lilianweng.github.io, 2023. https://lilianweng.github.io/posts/2023-03-15-prompt-engineering/
4. Harrison Chase, "LangChain: Building applications with LLMs," 2024. https://python.langchain.com/docs/
