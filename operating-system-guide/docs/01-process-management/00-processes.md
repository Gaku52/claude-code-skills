# プロセスの概念

> プロセスとは「実行中のプログラム」であり、OSが管理する最も基本的な実行単位である。

## この章で学ぶこと

- [ ] プロセスの定義と構成要素を説明できる
- [ ] プロセスのライフサイクル（状態遷移）を理解する
- [ ] fork/execモデルを説明できる

---

## 1. プロセスとは

```
プログラム vs プロセス:

  プログラム: ディスク上の実行ファイル（静的）
  プロセス:   メモリに読み込まれて実行中のプログラム（動的）

  1つのプログラム → 複数のプロセスになりうる
  （例: Chromeのタブごとにプロセス）

プロセスの構成要素:
  ┌──────────────────────────────────┐
  │ プロセスのメモリレイアウト        │
  │                                  │
  │ ┌──────────────┐  高アドレス     │
  │ │ スタック ↓   │  ← ローカル変数、│
  │ │              │    関数呼び出し  │
  │ ├──────────────┤                 │
  │ │    ↕ 空き    │                 │
  │ ├──────────────┤                 │
  │ │ ヒープ  ↑   │  ← 動的メモリ   │
  │ │              │    (malloc等)   │
  │ ├──────────────┤                 │
  │ │ BSS          │  ← 未初期化     │
  │ │              │    グローバル変数│
  │ ├──────────────┤                 │
  │ │ データ       │  ← 初期化済み   │
  │ │              │    グローバル変数│
  │ ├──────────────┤                 │
  │ │ テキスト     │  ← プログラム   │
  │ │ (コード)     │    の命令列     │
  │ └──────────────┘  低アドレス     │
  └──────────────────────────────────┘

PCB（Process Control Block）:
  OSがプロセスを管理するためのデータ構造

  ┌──────────────────────┐
  │ PID (プロセスID)      │
  │ 状態 (実行中/待機等)  │
  │ プログラムカウンタ    │
  │ CPUレジスタの値       │
  │ メモリマップ情報      │
  │ 開いているファイル    │
  │ スケジューリング優先度│
  │ 所有者(UID)          │
  │ 親プロセスID(PPID)   │
  └──────────────────────┘
```

---

## 2. プロセスの状態遷移

```
5状態モデル:

  ┌─────┐  fork()   ┌──────┐
  │ New │──────────→│Ready │←──────────────┐
  └─────┘           └──┬───┘               │
                  選ばれた│                  │割り込み/
                       ↓│               タイムアウト
                  ┌───────┐                │
                  │Running│────────────────┘
                  └──┬──┬─┘
            I/O要求  │  │  exit()
                    ↓│  │↓
              ┌───────┐ ┌──────────┐
              │Blocked│ │Terminated│
              └───┬───┘ └──────────┘
           I/O完了│
                  ↓
              ┌───────┐
              │ Ready │
              └───────┘

  New:        プロセスが作成された直後
  Ready:      CPU割り当てを待っている
  Running:    CPUで実行中（1コアにつき1プロセス）
  Blocked:    I/O等のイベントを待っている
  Terminated: 実行完了

  コンテキストスイッチ:
  Running → Ready の切替時にCPUの状態を保存/復元

  ┌────────────┐        ┌────────────┐
  │ Process A  │        │ Process B  │
  │ (Running)  │        │ (Ready)    │
  └──────┬─────┘        └──────┬─────┘
         │  PCBに状態保存       │
         │─────────→ OS ←──────│
         │         │           │
         │  PCBから状態復元     │
         │←──────── OS ────────→│
  ┌──────┴─────┐        ┌──────┴─────┐
  │ Process A  │        │ Process B  │
  │ (Ready)    │        │ (Running)  │
  └────────────┘        └────────────┘

  コンテキストスイッチのコスト:
  → 数マイクロ秒（レジスタ保存、TLBフラッシュ等）
  → 頻繁すぎるとオーバーヘッドに
```

---

## 3. プロセスの生成（fork/exec）

```
Unix/Linuxのプロセス生成モデル:

  fork(): 現在のプロセスのコピーを作成
  exec(): プロセスのプログラムを別のものに置換

  親プロセス(PID=100)
       │
       │ fork()
       ├──────────────────┐
       │                  │
  親(PID=100)        子(PID=101)
  fork()=101         fork()=0
       │                  │
       │             exec("/bin/ls")
       │                  │
       │             ls が実行される
       │                  │
  wait()              exit(0)
       │                  │
  子の終了を受取        終了

  Copy-on-Write (CoW):
  fork()は全メモリをコピーしない
  → 同じ物理ページを共有し、書き込み時にのみコピー
  → fork()を高速に実行できる

  プロセスツリー:
  init/systemd (PID=1)
    ├── sshd
    │   └── bash
    │       └── vim
    ├── nginx
    │   ├── worker
    │   └── worker
    └── cron
```

```python
# Pythonでforkの動作を確認
import os

pid = os.fork()

if pid == 0:
    # 子プロセス
    print(f"子プロセス: PID={os.getpid()}, 親PID={os.getppid()}")
else:
    # 親プロセス
    print(f"親プロセス: PID={os.getpid()}, 子PID={pid}")
    os.waitpid(pid, 0)  # 子の終了を待つ
```

---

## 4. プロセスの階層と特殊プロセス

```
Linuxの特殊プロセス:

  PID 0: swapper/idle（カーネルスレッド）
  PID 1: init/systemd（全プロセスの祖先）
  PID 2: kthreadd（カーネルスレッドの親）

  ゾンビプロセス:
  子が終了したが親がwait()していない状態
  → PCBが残り続ける（リソースリーク）
  → 親がwait()するか親が終了すればクリーンアップ

  孤児プロセス:
  親が先に終了した子プロセス
  → PID 1(init/systemd)が養子にする
  → initが代わりにwait()して回収

  デーモン:
  バックグラウンドで動作するプロセス
  → 制御端末を持たない
  → sshd, nginx, cron 等
```

---

## 実践演習

### 演習1: [基礎] — プロセスの観察

```bash
# 現在のプロセスツリーを確認
ps auxf         # Linux（ツリー表示）
ps aux          # macOS
pstree          # ツリー表示（要インストール）

# /proc からプロセス情報を読む（Linux）
cat /proc/self/status   # 自分のプロセス情報
cat /proc/self/maps     # メモリマップ
ls -la /proc/self/fd    # 開いているファイル
```

### 演習2: [応用] — fork爆弾の理解

```bash
# ⚠️ 絶対に実行しないこと！理論的な理解のみ
# :(){ :|:& };:
#
# 展開すると:
# bomb() {
#   bomb | bomb &
# }
# bomb
#
# なぜこれが危険か、OSはどう対策するか説明せよ
# ヒント: ulimit -u, cgroups, systemd の ResourceLimit
```

---

## FAQ

### Q1: プロセスとプログラムの違いは？

プログラムはディスク上の静的なファイル（/usr/bin/python等）。プロセスはそのプログラムがメモリに読み込まれ、CPU時間が割り当てられ、実行中の動的な実体。1つのプログラムから複数のプロセスが生成できる。

### Q2: なぜforkしてからexecするのか？直接起動ではダメか？

fork+execの分離により、**子プロセスの環境を親が事前に設定できる**。リダイレクト（ファイルディスクリプタの付け替え）、環境変数の設定、権限の変更をfork後exec前に行える。Windowsの`CreateProcess`は一体化しており柔軟性が低い。

### Q3: コンテキストスイッチはなぜ遅いのか？

レジスタ保存・復元だけなら速いが、**TLB（ページテーブルのキャッシュ）のフラッシュ**とキャッシュの汚染が大きい。プロセス切替後は新しいプロセスのデータがキャッシュに乗るまでキャッシュミスが多発する（コールドキャッシュ問題）。

---

## まとめ

| 概念 | ポイント |
|------|---------|
| プロセス | 実行中のプログラム。PID、メモリ空間、状態を持つ |
| 状態遷移 | New→Ready→Running→Blocked→Terminated |
| fork/exec | Unix流の生成。CoWで高速 |
| コンテキストスイッチ | CPU状態の保存/復元。TLBフラッシュが高コスト |

---

## 次に読むべきガイド
→ [[01-threads.md]] — スレッドと並行性

---

## 参考文献
1. Silberschatz, A. et al. "Operating System Concepts." 10th Ed, Ch.3, 2018.
2. Kerrisk, M. "The Linux Programming Interface." No Starch Press, 2010.
