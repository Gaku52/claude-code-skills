# CPUスケジューリング

> スケジューリングとは「どのプロセスに次にCPUを割り当てるか」を決定するアルゴリズムである。

## この章で学ぶこと

- [ ] 主要なスケジューリングアルゴリズムを比較できる
- [ ] プリエンプティブとノンプリエンプティブの違いを説明できる
- [ ] Linuxのスケジューラの仕組みを知る

---

## 1. スケジューリングの基本

```
スケジューラの目標:
  - CPU利用率: CPUをできるだけ忙しく保つ
  - スループット: 単位時間あたりの完了プロセス数を最大化
  - ターンアラウンド時間: 投入から完了までの時間を最小化
  - 待ち時間: Ready状態で待つ時間を最小化
  - 応答時間: 最初の応答までの時間を最小化（対話的システム）

  → これらは互いにトレードオフ

プリエンプティブ vs ノンプリエンプティブ:
  ノンプリエンプティブ: プロセスが自発的にCPUを手放すまで待つ
  プリエンプティブ:     OSがタイマー割り込みで強制切替

  現代のOSは全てプリエンプティブ
  （ノンプリエンプティブだと1プロセスがCPUを独占可能）
```

---

## 2. 主要なスケジューリングアルゴリズム

```
1. FCFS（First-Come, First-Served）:
   到着順に実行。キュー。

   到着: P1(24ms) P2(3ms) P3(3ms)
   ┌────────────────────────┬───┬───┐
   │        P1 (24ms)       │P2 │P3 │
   └────────────────────────┴───┴───┘
   0                        24  27  30

   平均待ち時間: (0 + 24 + 27) / 3 = 17ms
   → Convoy Effect: 長いプロセスの後に短いのが待たされる

2. SJF（Shortest Job First）:
   実行時間が短い順

   ┌───┬───┬────────────────────────┐
   │P2 │P3 │        P1 (24ms)       │
   └───┴───┴────────────────────────┘
   0   3   6                        30

   平均待ち時間: (6 + 0 + 3) / 3 = 3ms
   → 最適だが「次の実行時間」の予測が困難
   → 長いプロセスが飢餓状態（Starvation）に

3. ラウンドロビン（RR）:
   タイムクォンタム（例: 4ms）で交互に実行

   クォンタム=4ms:
   ┌────┬───┬───┬────┬────┬────┬────┬────┬────┐
   │ P1 │P2 │P3 │ P1 │ P1 │ P1 │ P1 │ P1 │ P1 │
   └────┴───┴───┴────┴────┴────┴────┴────┴────┘
   0    4   7  10   14   18   22   26   30

   → 応答時間が良い（対話的システム向き）
   → クォンタムが短すぎるとコンテキストスイッチのオーバーヘッド
   → 長すぎるとFCFSに退化

4. 優先度スケジューリング:
   優先度の高いプロセスを先に実行
   → 飢餓問題: 低優先度が永遠に実行されない
   → エージング: 待ち時間に応じて優先度を上昇させて対策

5. マルチレベルフィードバックキュー:
   複数の優先度キューを持ち、動的にプロセスを移動

   高優先度 [Q0] ─── クォンタム 8ms
                ↓ タイムアウト
   中優先度 [Q1] ─── クォンタム 16ms
                ↓ タイムアウト
   低優先度 [Q2] ─── FCFS

   → 短いプロセスは高優先度で素早く完了
   → 長いプロセスは低優先度に降格
   → 多くの汎用OSで採用
```

---

## 3. Linuxのスケジューラ

```
CFS（Completely Fair Scheduler, 2007〜）:

  原理: 全プロセスに「公平に」CPU時間を分配
  → 仮想ランタイム（vruntime）が最小のプロセスを次に実行

  データ構造: 赤黒木（Red-Black Tree）
  → 最小vruntimeのプロセスをO(log n)で取得

  ┌───────────────────────────────────┐
  │          赤黒木                    │
  │         ┌───┐                     │
  │         │ 5 │                     │
  │        / \                        │
  │    ┌───┐ ┌───┐                    │
  │    │ 3 │ │ 8 │                    │
  │   / \     \                       │
  │ ┌───┐┌───┐┌───┐                   │
  │ │ 1 ││ 4 ││ 9 │                   │
  │ └───┘└───┘└───┘                   │
  │  ↑ 次に実行                        │
  │ (最小vruntime)                     │
  └───────────────────────────────────┘

  nice値: -20（最高優先度）〜 +19（最低優先度）
  → vruntimeの進む速度を調整
  → nice値が低い → vruntimeがゆっくり増加 → より多くのCPU時間

EEVDF（Earliest Eligible Virtual Deadline First, Linux 6.6〜）:
  CFSの後継。仮想デッドラインベースで公平性を改善
  → レイテンシの改善

リアルタイムスケジューリング:
  SCHED_FIFO: リアルタイムFIFO（プリエンプトされない）
  SCHED_RR: リアルタイムラウンドロビン
  SCHED_DEADLINE: デッドラインベース
  → 通常プロセスより常に優先

マルチコアスケジューリング:
  各コアにRunキューを持ち、ロードバランシング
  → キャッシュアフィニティ: 同じコアに配置し続ける方が効率的
  → NUMA対応: メモリに近いコアで実行
```

---

## 実践演習

### 演習1: [基礎] — スケジューリングの手計算

```
以下のプロセスをFCFS、SJF、RR(q=2)でスケジュールし、
平均待ち時間と平均ターンアラウンド時間を比較せよ。

| プロセス | 到着時刻 | 実行時間 |
|---------|---------|---------|
| P1      | 0       | 6       |
| P2      | 1       | 3       |
| P3      | 2       | 1       |
| P4      | 3       | 4       |
```

### 演習2: [応用] — Linuxスケジューラの観察

```bash
# プロセスのスケジューリング情報を確認
chrt -p $$                    # 現在のスケジューリングポリシー
cat /proc/$$/sched            # スケジューリング統計（Linux）

# nice値の変更
nice -n 10 sleep 100 &        # nice値10で起動
renice -n 5 -p <PID>          # 実行中のプロセスのnice値変更

# CPU使用率の監視
top                           # リアルタイム監視
mpstat -P ALL 1               # コアごとの使用率
```

---

## FAQ

### Q1: タイムクォンタムの最適値は？

一般的には10〜100ms。短すぎるとコンテキストスイッチのオーバーヘッドが増大、長すぎると応答性が悪化。Linuxのデフォルトは約6ms（CFSの目標レイテンシから算出）。

### Q2: リアルタイムOSと汎用OSの違いは？

リアルタイムOS（RTOS）は「デッドラインまでに必ず処理を完了する」保証を提供。ハードリアルタイム（航空機制御）は違反が致命的。ソフトリアルタイム（動画再生）は違反が品質低下に留まる。LinuxはCONFIG_PREEMPTで「ほぼリアルタイム」を実現可能。

---

## まとめ

| アルゴリズム | 特徴 | 用途 |
|------------|------|------|
| FCFS | シンプル、Convoy Effect | バッチ処理 |
| SJF | 最適だが予測困難 | 理論的に重要 |
| ラウンドロビン | 公平、応答性良好 | 対話的システム |
| CFS/EEVDF | 仮想ランタイムで公平 | Linux |

---

## 次に読むべきガイド
→ [[03-ipc.md]] — プロセス間通信

---

## 参考文献
1. Silberschatz, A. et al. "Operating System Concepts." 10th Ed, Ch.5, 2018.
2. Love, R. "Linux Kernel Development." 3rd Ed, Ch.4, 2010.
