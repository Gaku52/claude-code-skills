# I/Oスケジューリング

> I/Oスケジューラはディスクへのリクエストを並べ替え、ヘッドの移動距離を最小化してスループットを向上させる。

## この章で学ぶこと

- [ ] I/Oスケジューリングの必要性を理解する
- [ ] 主要なスケジューラの違いを知る
- [ ] SSD時代のI/O最適化を理解する

---

## 1. なぜI/Oスケジューリングが必要か

```
HDD のアクセス時間:
  シーク時間: ヘッドの移動（3〜10ms）← ボトルネック
  回転待ち:   プラッタの回転（2〜5ms）
  転送時間:   データ読み書き（<1ms）

  → リクエストの順序を最適化してシーク時間を削減

  FIFO（何もしない場合）:
  ヘッド位置 → 98 → 183 → 37 → 122 → 14 → 124
  総移動距離: 85 + 146 + 85 + 108 + 110 = 534

  SSTF（最短シーク時間優先）:
  ヘッド位置 → 37 → 14 → 98 → 122 → 124 → 183
  総移動距離: 大幅に削減
```

---

## 2. Linuxの I/Oスケジューラ

```
現在のLinux I/Oスケジューラ:

  1. mq-deadline（マルチキューデッドライン）:
     → リクエストにデッドラインを設定
     → 飢餓状態を防止
     → HDD向け

  2. BFQ（Budget Fair Queueing）:
     → プロセスごとに公平にI/O帯域を分配
     → 対話的アプリの応答性を重視
     → デスクトップ向け

  3. none（noop）:
     → スケジューリングなし（FIFO）
     → SSD/NVMe向け（物理的なシークがない）
     → 仮想環境（ホストOSがスケジュール済み）

  SSD時代の変化:
  ┌──────────────────────────────────────┐
  │ HDD:  シーク最適化が重要             │
  │ SSD:  シーク不要、キューの深さが重要  │
  │ NVMe: 超並列I/O（64Kキュー×64K深さ） │
  │ → none が最適、OS側のスケジューラは最小限│
  └──────────────────────────────────────┘
```

```bash
# 現在のスケジューラ確認
cat /sys/block/sda/queue/scheduler

# スケジューラ変更
echo "mq-deadline" | sudo tee /sys/block/sda/queue/scheduler
```

---

## 3. I/O最適化テクニック

```
1. ページキャッシュ:
   読み込んだディスクデータをメモリにキャッシュ
   → 2回目以降はメモリから読み取り（超高速）
   → Linuxはメモリの大半をページキャッシュに使用

2. 先読み（Read-ahead）:
   連続読み取りを検知して先にデータを読む
   → デフォルト128KB（調整可能）

3. io_uring（Linux 5.1+）:
   高性能非同期I/Oインターフェース
   → システムコール回数を削減
   → ゼロコピー対応
   → epollの後継として普及中

4. Direct I/O:
   ページキャッシュをバイパス
   → データベース（自前キャッシュ）で使用
   → open()にO_DIRECTフラグ
```

---

## まとめ

| スケジューラ | 特徴 | 用途 |
|------------|------|------|
| mq-deadline | デッドライン保証 | HDD |
| BFQ | 公平性重視 | デスクトップ |
| none | スケジューリングなし | SSD/NVMe |

---

## 次に読むべきガイド
→ [[../04-io-and-devices/00-device-drivers.md]] — デバイスドライバ

---

## 参考文献
1. Love, R. "Linux Kernel Development." 3rd Ed, Ch.14, 2010.
