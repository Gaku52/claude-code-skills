# 文字コードとUnicode

> 文字化けの原因は常に「エンコーディングの不一致」であり、UTF-8の仕組みを理解すれば根本的に予防できる。

## この章で学ぶこと

- [ ] ASCII → Unicode → UTF-8 の進化を説明できる
- [ ] UTF-8のバイト構造を手計算で確認できる
- [ ] 文字化けの原因と対策を説明できる

## 前提知識

- 2進数と16進数 → 参照: [[00-binary-and-number-systems.md]]

---

## 1. 文字コードの歴史

### 1.1 ASCII（1963年）

```
ASCII: 7ビット = 128文字

  0x00-0x1F: 制御文字（改行LF, タブHT, NULL等）
  0x20:      スペース
  0x30-0x39: 数字 '0'-'9'
  0x41-0x5A: 大文字 'A'-'Z'
  0x61-0x7A: 小文字 'a'-'z'
  0x7F:      DEL

  特徴:
  - 英語圏のみ。日本語、中国語は表現不可能
  - 大文字と小文字の差は 0x20（ビット5の違い）
    'A' = 0x41 = 0100 0001
    'a' = 0x61 = 0110 0001
    →  差 = 0010 0000 = 0x20 = 32
  - 数字 '0'-'9' は 0x30-0x39（下位4ビットが数値そのもの）
```

### 1.2 文字コードの混乱期

| コード | 年代 | 対象 | 問題 |
|--------|------|------|------|
| ASCII | 1963 | 英語 | 128文字のみ |
| Latin-1 (ISO-8859-1) | 1987 | 西欧 | 256文字、日本語不可 |
| Shift_JIS | 1982 | 日本語 | Windows標準。可変長。他言語と混在困難 |
| EUC-JP | 1985 | 日本語 | UNIX標準。Shift_JISと互換性なし |
| GB2312/GBK | 1980 | 中国語 | 日本語と互換性なし |
| Big5 | 1984 | 繁体字 | 簡体字と互換性なし |

→ **各言語・地域ごとに独自の文字コード** → **相互運用性の悪夢**

### 1.3 Unicode の誕生（1991年）

Unicode の理念: **全ての言語の全ての文字に一意のコードポイントを割り当てる**

```
Unicode のコードポイント:

  U+0041  = 'A' (ラテン文字)
  U+3042  = 'あ' (ひらがな)
  U+4E16  = '世' (CJK漢字)
  U+1F600 = '😀' (絵文字)
  U+1F4A9 = '💩' (うんち絵文字)

  範囲: U+0000 〜 U+10FFFF（約111万コードポイント）
  割り当て済み: 約15万文字（2024年時点）
  → 人類が使用する全ての文字を収容可能
```

---

## 2. UTF-8 — 現代の標準

### 2.1 UTF-8のバイト構造

```
UTF-8 エンコーディング規則:

  コードポイント範囲        バイト数  バイト列パターン
  ──────────────────────────────────────────────────
  U+0000  - U+007F         1バイト   0xxxxxxx
  U+0080  - U+07FF         2バイト   110xxxxx 10xxxxxx
  U+0800  - U+FFFF         3バイト   1110xxxx 10xxxxxx 10xxxxxx
  U+10000 - U+10FFFF       4バイト   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx

  先頭バイトの1の数 = バイト数
  継続バイトは必ず 10 で始まる
  → どのバイトからでも文字境界を特定できる（自己同期性）
```

### 2.2 具体例

```
'A' = U+0041:
  2進数: 100 0001
  UTF-8: 0_1000001 = 0x41 (1バイト、ASCIIと完全互換)

'あ' = U+3042:
  2進数: 0011 0000 0100 0010
  UTF-8: 1110_0011 10_000001 10_000010 = 0xE3 0x81 0x82 (3バイト)

  エンコード手順:
  U+3042 = 0011 000001 000010
  テンプレート: 1110xxxx 10xxxxxx 10xxxxxx
  埋め込み:     1110_0011 10_000001 10_000010
  結果:         E3 81 82

'😀' = U+1F600:
  2進数: 0001 1111 0110 0000 0000
  UTF-8: 11110_000 10_011111 10_011000 10_000000 = 0xF0 0x9F 0x98 0x80 (4バイト)
```

### 2.3 UTF-8の利点

| 特性 | 説明 |
|------|------|
| ASCII互換 | ASCIIテキストはそのままUTF-8として有効 |
| 可変長 | 1-4バイト。英語はコンパクト、全言語をサポート |
| 自己同期 | 任意のバイト位置から文字境界を復元可能 |
| ソート可能 | バイト列の辞書順 ≈ コードポイントの昇順 |
| BOM不要 | エンディアン問題がない（UTF-16と異なり） |
| 広く普及 | Web の 98%以上が UTF-8 |

---

## 3. 文字化けの原因と対策

### 3.1 よくある文字化け

```python
# 文字化けの再現

text = "こんにちは"

# UTF-8でエンコードしたバイト列
utf8_bytes = text.encode('utf-8')
# b'\xe3\x81\x93\xe3\x82\x93\xe3\x81\xab\xe3\x81\xa1\xe3\x81\xaf'

# ❌ Latin-1としてデコード → 文字化け
wrong = utf8_bytes.decode('latin-1')
# 'ã\x81\x93ã\x82\x93ã\x81«ã\x81¡ã\x81¯'  ← 典型的な文字化け

# ❌ Shift_JISとしてデコード → 別の文字化け
wrong2 = utf8_bytes.decode('shift_jis', errors='replace')
# '縺薙s縺ォ縺。縺ッ' のような意味不明な文字列

# ✅ 正しいエンコーディングでデコード
correct = utf8_bytes.decode('utf-8')
# 'こんにちは'
```

### 3.2 文字化け対策チェックリスト

```
全レイヤーでUTF-8を統一:

  ┌──────────────────────────────┐
  │ ファイル保存: UTF-8 (BOMなし) │
  ├──────────────────────────────┤
  │ HTTP: Content-Type: text/html;│
  │       charset=utf-8          │
  ├──────────────────────────────┤
  │ HTML: <meta charset="utf-8"> │
  ├──────────────────────────────┤
  │ DB: CHARACTER SET utf8mb4    │
  │    (MySQLのutf8は3バイトまで！│
  │     utf8mb4が真のUTF-8)     │
  ├──────────────────────────────┤
  │ Python: open(f, encoding='utf-8') │
  ├──────────────────────────────┤
  │ JSON: デフォルトUTF-8        │
  └──────────────────────────────┘

  注意: MySQLの"utf8"は3バイトまで（絵文字不可）
  → 必ず"utf8mb4"を使用すること！
```

---

## 4. Unicode の落とし穴

### 4.1 結合文字と正規化

```python
# 「が」の2つの表現方法

# 1. 合成済み文字（NFC）: 1文字
ga_nfc = '\u304C'  # 'が' (1コードポイント)
len(ga_nfc)  # 1

# 2. 結合文字（NFD）: 基底文字 + 濁点
ga_nfd = '\u304B\u3099'  # 'か' + '゙' (2コードポイント)
len(ga_nfd)  # 2

# 見た目は同じ 'が' だが、==で比較するとFalse!
ga_nfc == ga_nfd  # False!

# 対策: unicodedata.normalize で正規化
import unicodedata
unicodedata.normalize('NFC', ga_nfd) == ga_nfc  # True
```

### 4.2 サロゲートペア（UTF-16の問題）

```
UTF-16 でのコードポイント表現:

  U+0000 - U+FFFF:   2バイトでそのまま（BMP: Basic Multilingual Plane）
  U+10000 - U+10FFFF: 4バイト（サロゲートペア必要）

  例: '😀' U+1F600
  1. U+1F600 - 0x10000 = 0x0F600
  2. 上位10ビット: 0x003D → + 0xD800 = 0xD83D（上位サロゲート）
  3. 下位10ビット: 0x0200 → + 0xDC00 = 0xDE00（下位サロゲート）
  4. UTF-16: 0xD83D 0xDE00

  → JavaScript の string.length が絵文字で2を返す理由
  '😀'.length === 2  // true! (UTF-16の内部表現)
  [...'😀'].length === 1  // true (イテレータはコードポイント単位)
```

---

## 5. 実践演習

### 演習1: UTF-8エンコード（基礎）
以下の文字のUTF-8バイト列を手計算で求めよ:
1. 'Z' (U+005A)
2. '¥' (U+00A5)
3. '漢' (U+6F22)

### 演習2: 文字化け解析（応用）
バイト列 `E6 97 A5 E6 9C AC E8 AA 9E` をUTF-8としてデコードし、元の文字列を求めよ。

### 演習3: Unicode正規化の実装（発展）
Pythonで、2つの文字列が「見た目」が同じか（NFC/NFD正規化後に一致するか）を判定する関数を作成せよ。

---

## FAQ

### Q1: BOM（Byte Order Mark）は必要ですか？
**A**: UTF-8では不要（むしろ有害な場合あり）。UTF-16/UTF-32ではエンディアン判定に必要。BOM（U+FEFF）がUTF-8ファイルの先頭にあると、シェルスクリプトやCSV解析でエラーの原因になる。

### Q2: 絵文字はどう実装されていますか？
**A**: Unicodeで標準化。U+1F600〜に割り当て。肌の色は修飾子（U+1F3FB〜U+1F3FF）で変更。家族絵文字はZWJ（Zero Width Joiner）で複数の絵文字を結合。

### Q3: ASCII以外のファイル名は安全ですか？
**A**: OS依存:
- macOS: NFD正規化を強制（ファイル名が意図しない形に）
- Linux: バイト列として格納（UTF-8推奨だが強制なし）
- Windows: UTF-16で格納（内部はUCS-2の拡張）
安全を期すなら英数字とハイフン/アンダースコアのみ使用。

---

## まとめ

| 概念 | ポイント |
|------|---------|
| ASCII | 7ビット128文字。英語のみ。全ての基盤 |
| Unicode | 全言語を統一。コードポイント U+0000〜U+10FFFF |
| UTF-8 | 可変長(1-4バイト)。ASCII互換。Webの98%で使用 |
| 文字化け | エンコーディング不一致が原因。全レイヤーでUTF-8統一 |
| 正規化 | NFC/NFDの違いに注意。比較前に正規化必須 |

---

## 次に読むべきガイド
→ [[02-integer-representation.md]] — 整数表現と2の補数

---

## 参考文献
1. Unicode Consortium. "The Unicode Standard." https://unicode.org/
2. Pike, R. & Thompson, K. "Hello World, or Καλημέρα κόσμε, or こんにちは 世界." UTF-8 Design, 1992.
3. Spolsky, J. "The Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets." 2003.
4. W3C. "Character encodings for beginners." https://www.w3.org/International/
