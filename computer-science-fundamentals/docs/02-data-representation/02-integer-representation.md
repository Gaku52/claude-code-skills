# 整数表現と2の補数

> コンピュータが負の数を表現する方法は「2の補数」という天才的な仕組みであり、加算器1つで加算も減算もこなせる。

## この章で学ぶこと

- [ ] 符号なし整数と符号付き整数の違いを説明できる
- [ ] 2の補数の仕組みを手計算で確認できる
- [ ] オーバーフローの原因と対策を説明できる
- [ ] エンディアン（バイトオーダー）の違いを理解する

## 前提知識

- 2進数と16進数 → 参照: [[00-binary-and-number-systems.md]]

---

## 1. 符号なし整数（Unsigned Integer）

### 1.1 基本

```
符号なし整数: 全ビットを値の表現に使用

  Nビットで表現できる範囲: 0 〜 2^N - 1

  8ビット (uint8):   0 〜 255
  16ビット (uint16):  0 〜 65,535
  32ビット (uint32):  0 〜 4,294,967,295 (約43億)
  64ビット (uint64):  0 〜 18,446,744,073,709,551,615 (約1844京)

  例: 8ビットでの表現
  0000 0000 =   0
  0000 0001 =   1
  0111 1111 = 127
  1000 0000 = 128
  1111 1111 = 255
```

### 1.2 各言語での符号なし整数

```python
# Python: 整数に上限なし（任意精度整数）
x = 2**64  # 18446744073709551616 — 問題なく扱える
x = 2**1000  # これも問題なし

# ただしctypesやstructで固定幅を扱う場合は制限あり
import struct
struct.pack('B', 255)   # uint8: OK
struct.pack('B', 256)   # struct.error: ubyte format requires 0 <= number <= 255
```

```rust
// Rust: 明示的な型指定が必須
let a: u8 = 255;    // OK
let b: u8 = 256;    // コンパイルエラー！
let c: u32 = 4_294_967_295;  // OK (アンダースコアで視認性向上)
let d: u64 = 18_446_744_073_709_551_615;  // OK
```

```javascript
// JavaScript: Number型は64ビット浮動小数点
// → 安全に扱える整数の範囲は限定的
Number.MAX_SAFE_INTEGER  // 9007199254740991 (2^53 - 1)

// BigInt で任意精度
const big = 18446744073709551615n;  // OK
```

---

## 2. 符号付き整数（Signed Integer）— 2の補数

### 2.1 負の数の表現方法の比較

```
負の数を表現する3つの方法（8ビットの場合）:

  方法1: 符号ビット（Sign-Magnitude）
  ─────────────────────────────
    最上位ビット = 符号（0:正, 1:負）
    残り7ビット = 絶対値

    +5 = 0_0000101
    -5 = 1_0000101

    問題点:
    - +0 (0000 0000) と -0 (1000 0000) の2つのゼロが存在
    - 加算に特別な回路が必要
    - 範囲: -127 〜 +127

  方法2: 1の補数（One's Complement）
  ─────────────────────────────
    負の数 = 全ビット反転

    +5 = 0000 0101
    -5 = 1111 1010

    問題点:
    - +0 (0000 0000) と -0 (1111 1111) の2つのゼロ
    - 桁上がりの処理が必要（end-around carry）
    - 範囲: -127 〜 +127

  方法3: 2の補数（Two's Complement）★現代の標準
  ─────────────────────────────
    負の数 = 全ビット反転 + 1

    +5 = 0000 0101
    -5 = 1111 1011  (0000 0101 → 反転 → 1111 1010 → +1 → 1111 1011)

    利点:
    - ゼロが1つだけ（0000 0000）
    - 加算器1つで加算も減算もできる！
    - 範囲: -128 〜 +127（非対称だが合理的）
```

### 2.2 2の補数の仕組み

```
2の補数の本質:
  -x = 2^N - x  （N = ビット数）

  8ビットの場合: -x = 256 - x

  例: -5 = 256 - 5 = 251 = 1111 1011

  なぜこれで加算が統一できるのか:
  5 + (-5) = 5 + 251 = 256 = 1_0000_0000 (9ビット)
  → 8ビットに収まらない最上位ビット(キャリー)を捨てると 0000 0000 = 0 ✓

  3 + (-5) = 3 + 251 = 254 = 1111 1110
  → 2の補数として解釈すると -2 ✓

  → ハードウェアは符号を意識せず、ただ加算するだけでよい！
```

### 2.3 2の補数の変換手順

```
正 → 負 の変換:

  方法1: 全ビット反転 + 1
    +42 = 0010 1010
    反転 → 1101 0101
    +1  → 1101 0110 = -42

  方法2: 2^N - x
    -42 = 256 - 42 = 214 = 1101 0110 ✓

  方法3: 右端の1を見つけ、それより左のビットを全て反転
    +42 = 0010 1010
              ↑ 右端の1
    反転 → 1101 0110 = -42

  逆変換（負 → 正）: 同じ操作をもう一度行う
    -42 = 1101 0110
    反転 → 0010 1001
    +1  → 0010 1010 = +42 ✓
```

### 2.4 符号付き整数の範囲

```
Nビット2の補数の範囲: -2^(N-1) 〜 2^(N-1) - 1

  型       ビット数  最小値                     最大値
  ──────────────────────────────────────────────────────
  int8     8        -128                       127
  int16    16       -32,768                    32,767
  int32    32       -2,147,483,648             2,147,483,647 (約±21億)
  int64    64       -9,223,372,036,854,775,808  9,223,372,036,854,775,807

  なぜ負の方が1つ多い？
  ────────────────────
  8ビットの場合:
  正の最大: 0111 1111 = +127
  負の最小: 1000 0000 = -128

  -128を反転+1すると:
  1000 0000 → 0111 1111 → 1000 0000 = -128 (自分自身に戻る！)
  → -128は反転操作で対になる正の数が存在しない特殊な値
```

---

## 3. オーバーフロー

### 3.1 オーバーフローとは

```
オーバーフロー: 演算結果が表現可能な範囲を超えること

  符号なし8ビット:
  255 + 1 = 256 → 0 (ラップアラウンド)

  1111 1111
+ 0000 0001
──────────
1 0000 0000 → 8ビットに切り詰め → 0000 0000 = 0

  符号付き8ビット (2の補数):
  127 + 1 = 128? → -128 (オーバーフロー!)

  0111 1111  (+127)
+ 0000 0001  (+1)
──────────
  1000 0000  (-128)  ← 正+正=負 は明らかにおかしい

  オーバーフロー検出:
  - 正 + 正 = 負 → オーバーフロー
  - 負 + 負 = 正 → オーバーフロー
  - 正 + 負 は絶対にオーバーフローしない
```

### 3.2 実際のバグ・事故

```python
# 有名なオーバーフロー事故

# 1. Ariane 5 ロケット爆発（1996年）
#    64ビット浮動小数点 → 16ビット符号付き整数への変換
#    水平速度が32,767を超え、オーバーフロー → 制御不能 → 爆発
#    損害: 5億ドル

# 2. パックマン 256面バグ（1980年）
#    面数を8ビット符号なし整数で管理
#    255面クリア → 256面 = 0x100 → 8ビットでは0x00
#    右半分が文字化けした「キルスクリーン」が出現

# 3. Boeing 787 電源喪失（2015年）
#    32ビットカウンタが248日で2^31に到達
#    int32オーバーフロー → 電源制御システムがシャットダウン
#    対策: 248日以内に再起動する暫定措置（！）

# 4. 2038年問題（Y2K38）
#    Unix時間: 1970年1月1日からの秒数（int32）
#    2^31 - 1 = 2,147,483,647秒 = 2038年1月19日 03:14:07 UTC
#    → int64への移行が必要
import time
# 2038年問題のタイムスタンプ
print(2**31 - 1)  # 2147483647
# ほとんどの現代システムは64ビットに移行済み
```

### 3.3 各言語のオーバーフロー対策

```python
# Python: 任意精度整数 → オーバーフローなし！
x = 2**100 + 1  # 問題なし
# Pythonは唯一、整数オーバーフローを心配しなくてよい言語
```

```rust
// Rust: コンパイル時・実行時の検出
let x: u8 = 255;

// デバッグビルド: パニック（プログラム停止）
let y = x + 1;  // thread 'main' panicked at 'attempt to add with overflow'

// リリースビルド: ラップアラウンド（デフォルト）
// 明示的なオーバーフロー制御メソッド:
let a = x.checked_add(1);    // Option<u8> → None
let b = x.saturating_add(1); // 255 (上限で飽和)
let c = x.wrapping_add(1);   // 0 (明示的ラップ)
let d = x.overflowing_add(1); // (0, true) — 値とオーバーフローフラグ
```

```java
// Java: サイレントラップアラウンド（危険！）
int x = Integer.MAX_VALUE;  // 2147483647
int y = x + 1;              // -2147483648 (警告なし！)

// Java 8以降: Math.addExact()
int z = Math.addExact(x, 1);  // ArithmeticException
```

```c
// C: 符号付きオーバーフローは未定義動作（最も危険）
int x = INT_MAX;
int y = x + 1;  // 未定義動作！コンパイラが何をしても「正しい」
// GCCの最適化により、オーバーフローチェックが削除される場合もある

// 安全な加算チェック:
#include <limits.h>
int safe_add(int a, int b) {
    if (b > 0 && a > INT_MAX - b) return -1;  // オーバーフロー
    if (b < 0 && a < INT_MIN - b) return -1;  // アンダーフロー
    return a + b;
}
```

---

## 4. エンディアン（Byte Order）

### 4.1 ビッグエンディアンとリトルエンディアン

```
エンディアン: マルチバイト値をメモリに格納する際のバイト順序

  値: 0x12345678（32ビット整数）

  ビッグエンディアン（Big-Endian）:
  アドレス:  0x00  0x01  0x02  0x03
  値:        0x12  0x34  0x56  0x78
  → 最上位バイト(MSB)が最小アドレスに格納
  → 人間の読み方と同じ順序
  → ネットワーク通信の標準（ネットワークバイトオーダー）

  リトルエンディアン（Little-Endian）:
  アドレス:  0x00  0x01  0x02  0x03
  値:        0x78  0x56  0x34  0x12
  → 最下位バイト(LSB)が最小アドレスに格納
  → Intel/AMD x86/x64, ARM（デフォルト）
  → 加算時に下位バイトから処理でき、回路が単純

  バイエンディアン（Bi-Endian）:
  → 切り替え可能。ARM, MIPS, PowerPC
  → ARM は実質リトルエンディアンで使用されることが多い
```

### 4.2 エンディアンの実務的影響

```python
import struct

value = 0x12345678

# ビッグエンディアンでパック
big = struct.pack('>I', value)
print(big.hex())  # '12345678'

# リトルエンディアンでパック
little = struct.pack('<I', value)
print(little.hex())  # '78563412'

# ネットワーク通信での注意:
# ネットワーク = ビッグエンディアン
# x86 PC = リトルエンディアン
# → 送受信時にバイトオーダー変換が必要

import socket
# ホストバイトオーダー → ネットワークバイトオーダー
port = 8080
network_port = socket.htons(port)  # host to network short

ip = 0xC0A80001  # 192.168.0.1
network_ip = socket.htonl(ip)  # host to network long
```

### 4.3 エンディアンの確認方法

```python
import sys
print(sys.byteorder)  # 'little' (x86/ARM) or 'big'

# バイナリファイルの先頭を見て判断する例:
# BMP画像: 先頭が 'BM' (0x42 0x4D) → リトルエンディアン
# JPEG: 先頭が 0xFF 0xD8 → エンディアン非依存
# ELF: offset 5 に 1(LE) or 2(BE) が格納
# UTF-16 BOM: 0xFE 0xFF(BE) or 0xFF 0xFE(LE)
```

---

## 5. 固定小数点数

### 5.1 固定小数点の仕組み

```
固定小数点数: 小数点の位置を固定して整数演算で小数を扱う

  Q8.8 形式（16ビット: 整数部8ビット + 小数部8ビット）:

  ビット: IIIIIIII.FFFFFFFF

  例: 3.75 を Q8.8 で表現
  整数部: 3 = 0000 0011
  小数部: 0.75 = 0.5 + 0.25 = 2^(-1) + 2^(-2) = 1100 0000
  結果: 0000 0011.1100 0000 = 0x03C0

  固定小数点の演算:
  加算: そのまま加算（整数と同じ！）
  乗算: 結果を右シフト（小数部ビット数分）

  用途:
  - 金融計算（通貨は小数2桁固定）
  - 組み込みシステム（FPU非搭載のマイコン）
  - ゲーム（DSP時代の3Dグラフィックス）
  - 音声処理（DSP）
```

### 5.2 金融計算での整数活用

```python
# ❌ 浮動小数点で金額計算（危険！）
price = 0.1 + 0.2
print(price)  # 0.30000000000000004
print(price == 0.3)  # False!

# ✅ 整数（セント単位）で金額計算
price_cents = 10 + 20  # 30セント
print(price_cents / 100)  # 0.3

# ✅ Decimal型を使用
from decimal import Decimal
price = Decimal('0.1') + Decimal('0.2')
print(price)  # 0.3
print(price == Decimal('0.3'))  # True

# ✅ 実務でのベストプラクティス
# データベース: DECIMAL(10, 2) — 整数部10桁、小数部2桁
# JavaScript: 金額は全てセント(整数)で扱い、表示時のみ変換
# Java: BigDecimal を使用
```

---

## 6. 実践演習

### 演習1: 2の補数（基礎）
以下の計算を8ビット2の補数で手計算せよ:
1. -42 のビット表現
2. 50 + (-30) の加算
3. -100 + (-50) の加算（オーバーフローするか？）

### 演習2: オーバーフロー検出（応用）
好きな言語で、2つの32ビット符号付き整数の加算がオーバーフローするかどうかを判定する関数を実装せよ。ただし、64ビット整数への拡張を使わずに判定すること。

### 演習3: エンディアン変換（発展）
バイナリファイルから4バイトの整数を読み取り、リトルエンディアン/ビッグエンディアン両方で解釈した値を表示するプログラムを実装せよ。

---

## FAQ

### Q1: なぜ2の補数が採用されたのですか？
**A**: 加算器1つで加減算が統一できるため。ハードウェアコストが劇的に削減される。符号ビット方式では加算と減算に別の回路が必要で、かつ +0/-0 の2つのゼロの処理が複雑。2の補数は数学的にも美しく（mod 2^N の環）、実装も効率的。

### Q2: 2038年問題は本当に起きますか？
**A**: 32ビットのtime_tを使い続けるシステムでは起きうる。ほとんどのデスクトップOS/サーバーは64ビットに移行済み。問題は組み込みシステム（IoTデバイス、産業制御装置）で、ファームウェア更新が困難な機器が多数残存している。

### Q3: Pythonの整数に上限がないのはなぜですか？
**A**: Pythonは内部的に可変長の整数表現を使用（ob_digit配列）。必要に応じてメモリを動的確保するため、メモリが許す限り任意の大きさの整数を扱える。代償として、固定幅整数に比べて演算速度は遅い。

---

## まとめ

| 概念 | ポイント |
|------|---------|
| 符号なし整数 | 全ビットを値に使用。0〜2^N-1 |
| 2の補数 | 負の数 = ビット反転+1。加算器で統一処理 |
| オーバーフロー | 表現範囲を超える演算。言語ごとに挙動が異なる |
| エンディアン | バイト格納順序。ネットワーク=BE、x86=LE |
| 固定小数点 | 小数点位置固定。金融・組み込みで使用 |

---

## 次に読むべきガイド
→ [[03-floating-point.md]] — 浮動小数点数とIEEE 754

---

## 参考文献
1. Bryant, R. E. & O'Hallaron, D. R. "Computer Systems: A Programmer's Perspective." Chapter 2.
2. Warren, H. S. "Hacker's Delight." 2nd Edition, Chapters 2-4.
3. Goldberg, D. "What Every Computer Scientist Should Know About Floating-Point Arithmetic." 1991.
4. IEEE. "IEEE 754-2019 Standard for Floating-Point Arithmetic."
