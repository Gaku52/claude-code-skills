# データ構造の選び方

> 適切なデータ構造を選ぶことは、適切なアルゴリズムを選ぶことと同等に重要である。

## この章で学ぶこと

- [ ] 要件に応じて最適なデータ構造を選択できる
- [ ] 各データ構造のトレードオフを理解する
- [ ] 実務での選択基準を身につける

## 前提知識

- 本セクションの全ガイド → 参照: [[00-arrays-and-strings.md]] 〜 [[06-advanced-structures.md]]

---

## 1. 選択フローチャート

```
データ構造選択の判断フロー:

  Q1: 順序は重要？
  ├── No → Q2: キーでアクセス？
  │   ├── Yes → ハッシュテーブル (dict/Map)
  │   └── No → Q3: 重複許容？
  │       ├── Yes → 配列 (list/ArrayList)
  │       └── No → ハッシュセット (set/HashSet)
  │
  └── Yes → Q4: ソート順を維持？
      ├── Yes → Q5: 範囲検索が必要？
      │   ├── Yes → 平衡BST (TreeMap) or B+木
      │   └── No → ソート済み配列 + 二分探索
      │
      └── No → Q6: アクセスパターンは？
          ├── LIFO → スタック
          ├── FIFO → キュー
          ├── 優先度付き → ヒープ（優先度キュー）
          └── 両端 → デキュー (deque)
```

---

## 2. 計算量の比較表

```
主要データ構造の計算量一覧:

  ┌──────────────┬────────┬────────┬────────┬────────┬────────┐
  │ データ構造    │ アクセス│ 検索   │ 挿入   │ 削除   │ 空間   │
  ├──────────────┼────────┼────────┼────────┼────────┼────────┤
  │ 配列         │ O(1)   │ O(n)   │ O(n)   │ O(n)   │ O(n)   │
  │ 動的配列     │ O(1)   │ O(n)   │ O(1)*  │ O(n)   │ O(n)   │
  │ 連結リスト   │ O(n)   │ O(n)   │ O(1)   │ O(1)   │ O(n)   │
  │ スタック     │ O(n)   │ O(n)   │ O(1)   │ O(1)   │ O(n)   │
  │ キュー       │ O(n)   │ O(n)   │ O(1)   │ O(1)   │ O(n)   │
  │ ハッシュテーブル│ -    │ O(1)*  │ O(1)*  │ O(1)*  │ O(n)   │
  │ BST          │ O(n)†  │ O(n)†  │ O(n)†  │ O(n)†  │ O(n)   │
  │ 平衡BST      │ O(logn)│ O(logn)│ O(logn)│ O(logn)│ O(n)   │
  │ ヒープ       │ O(1)‡  │ O(n)   │ O(logn)│ O(logn)│ O(n)   │
  │ Trie         │ -      │ O(m)   │ O(m)   │ O(m)   │ O(Σm)  │
  └──────────────┴────────┴────────┴────────┴────────┴────────┘

  * 期待値 / 償却  † 最悪ケース  ‡ 最小/最大のみ
```

---

## 3. 実務の選択基準

### 3.1 よくあるケースと推奨

```
実務での選択パターン:

  「ユーザー一覧の表示」→ 配列
  「IDからユーザーを検索」→ ハッシュテーブル
  「ユーザーを名前順でソート」→ 配列 + ソート
  「リアルタイムTop-10」→ ヒープ
  「Undo機能」→ スタック
  「タスクキュー」→ キュー / 優先度キュー
  「重複チェック」→ ハッシュセット
  「オートコンプリート」→ Trie
  「範囲検索（日付範囲等）」→ 平衡BST / B+木
  「グラフの関係性」→ 隣接リスト
  「キャッシュ（LRU）」→ ハッシュテーブル + 双方向連結リスト
  「存在確認（大量データ）」→ Bloom Filter

  黄金ルール:
  1. まず配列かハッシュテーブルで十分か検討
  2. 90%のケースはこの2つで解決できる
  3. 特殊な要件がある場合のみ他を検討
```

### 3.2 パフォーマンスのトレードオフ

```
データ構造のトレードオフ:

  配列 vs ハッシュテーブル:
  → 配列: 順序あり、キャッシュ効率良い、メモリ効率良い
  → ハッシュ: 高速検索、順序なし、メモリオーバーヘッド

  配列 vs 連結リスト:
  → 配列: キャッシュ効率が圧倒的に良い → ほぼ常に配列が勝つ
  → 連結リスト: 先頭挿入O(1)、サイズ変更が柔軟

  BST vs ハッシュテーブル:
  → BST: ソート順維持、範囲検索可能、最悪O(log n)保証
  → ハッシュ: 期待O(1)だが最悪O(n)、順序なし
```

---

## 4. 実践演習

### 演習1: 要件分析（基礎）
以下の要件に対して最適なデータ構造を選び、理由を述べよ:
1. 直近100件のログを保持し、古いものから削除
2. 英単語の辞書から前方一致検索
3. リアルタイムで中央値を計算

### 演習2: 設計問題（応用）
Twitter風サービスのデータ構造を設計せよ（ツイート保存、タイムライン取得、フォロー関係管理）。

### 演習3: ベンチマーク（発展）
list, deque, set, dict の各操作のパフォーマンスを実測し、データサイズ別の性能グラフを作成せよ。

---

## まとめ

| 要件 | 推奨データ構造 |
|------|-------------|
| 順次アクセス | 配列 |
| キーで高速検索 | ハッシュテーブル |
| ソート順維持 | 平衡BST |
| LIFO/FIFO | スタック/キュー |
| 優先度付き処理 | ヒープ |
| 大量データの存在確認 | Bloom Filter |

---

## 次に読むべきガイド
→ [[../05-computation-theory/00-automata.md]] — オートマトンと形式言語

---

## 参考文献
1. Skiena, S. S. "The Algorithm Design Manual." Chapter 3: Data Structures.
2. Kleppmann, M. "Designing Data-Intensive Applications." Chapter 3.
