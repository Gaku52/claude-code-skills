# アルゴリズムとは何か

> アルゴリズムとは「問題を解くための明確な手順」であり、プログラミングの本質はアルゴリズムの設計と実装である。

## この章で学ぶこと

- [ ] アルゴリズムの定義と5つの条件を説明できる
- [ ] 良いアルゴリズムと悪いアルゴリズムの違いを理解する
- [ ] 問題→アルゴリズム→コードの思考プロセスを身につける

## 前提知識

- 基本的なプログラミング経験

---

## 1. アルゴリズムの定義

### 1.1 アルゴリズムの5つの条件

```
アルゴリズム (Algorithm):
  有限の手順で問題を解決する、明確に定義された計算手続き

  5つの条件（Knuth, 1968）:

  1. 入力 (Input):
     → 0個以上の外部データを受け取る
     → 例: ソート → 数値の配列

  2. 出力 (Output):
     → 1個以上の結果を生成する
     → 例: ソート → 並べ替えた配列

  3. 明確性 (Definiteness):
     → 各ステップが曖昧さなく定義されている
     → ❌「適当にいい感じに並べる」
     → ✅「隣接する要素を比較し、左が大きければ交換する」

  4. 有限性 (Finiteness):
     → 有限回のステップで必ず終了する
     → 無限ループはアルゴリズムではない

  5. 有効性 (Effectiveness):
     → 各ステップが十分に基本的で、実行可能である
     → 「素数を全て列挙する」は無限なのでNG
     → 「N以下の素数を列挙する」はOK
```

### 1.2 日常のアルゴリズム

```
料理のレシピ = アルゴリズム:

  カレーの作り方:
  入力: 玉ねぎ2個, 肉300g, カレールー1箱, 水800ml
  出力: カレー4人前

  1. 玉ねぎを薄切りにする
  2. 鍋に油を入れ、中火で加熱する
  3. 玉ねぎを飴色になるまで炒める（約10分）
  4. 肉を加え、色が変わるまで炒める
  5. 水800mlを加え、沸騰させる
  6. 弱火で20分煮る
  7. 火を止め、ルーを割り入れて溶かす
  8. 弱火で5分煮る
  → 完成

  これはアルゴリズムの5条件を全て満たす:
  ✅ 入力: 食材
  ✅ 出力: カレー
  ✅ 明確性: 各ステップが具体的
  ✅ 有限性: 8ステップで終了
  ✅ 有効性: 各ステップは実行可能
```

---

## 2. アルゴリズムの設計戦略

### 2.1 主要な設計パターン

```
アルゴリズム設計の7大戦略:

  ┌─────────────────┬──────────────────────────────────────┐
  │ 戦略            │ 概要                                  │
  ├─────────────────┼──────────────────────────────────────┤
  │ 全探索          │ 全ての可能性を試す（ブルートフォース） │
  │ 分割統治        │ 問題を分割→各個解決→結合              │
  │ 動的計画法      │ 部分問題の解を記憶して再利用           │
  │ 貪欲法          │ 各ステップで局所最適な選択をする       │
  │ バックトラック   │ 探索を進め、行き詰まったら戻る        │
  │ 二分探索        │ 範囲を半分に絞りながら探索             │
  │ グラフ探索      │ BFS/DFSで状態空間を探索               │
  └─────────────────┴──────────────────────────────────────┘
```

### 2.2 問題解決のフレームワーク

```
問題→アルゴリズム→コードの思考プロセス:

  ステップ1: 問題を理解する
  ─────────────────────────
  - 入力は何か？出力は何か？
  - 制約条件は？（データサイズ、時間制限）
  - エッジケースは？

  ステップ2: 手作業で例を解く
  ─────────────────────────
  - 具体的な小さい例で手を動かす
  - パターンを見つける
  - 自分がどういう手順で解いているか意識する

  ステップ3: アルゴリズムを設計する
  ─────────────────────────
  - 手順を言葉で書き出す
  - 計算量を見積もる
  - もっと良い方法がないか検討する

  ステップ4: コードに変換する
  ─────────────────────────
  - 擬似コード → 実際のコード
  - エッジケースの処理を追加

  ステップ5: テストと検証
  ─────────────────────────
  - 正常系: 基本的な入力
  - 境界値: 空、1要素、最大値
  - 異常系: 不正な入力
```

### 2.3 具体例: 配列の最大値を見つける

```python
# 問題: 配列の中で最大の値を見つける
# 入力: 整数の配列 (空でない)
# 出力: 最大の値

# 方法1: 全探索（ブルートフォース）
def find_max_brute(arr):
    """全ての要素を1つずつ確認"""
    max_val = arr[0]
    for i in range(1, len(arr)):
        if arr[i] > max_val:
            max_val = arr[i]
    return max_val
# 計算量: O(n) — これ以上改善できない（全要素を見る必要がある）

# 方法2: 分割統治
def find_max_divide(arr, left, right):
    """配列を半分に分割して各最大値を比較"""
    if left == right:
        return arr[left]
    mid = (left + right) // 2
    left_max = find_max_divide(arr, left, mid)
    right_max = find_max_divide(arr, mid + 1, right)
    return max(left_max, right_max)
# 計算量: O(n) — 同じだが、並列化に適している

# 方法3: Python組み込み
max_val = max(arr)  # 内部的に方法1と同じ O(n)

# この問題ではO(n)が最適（下界）
# → 全ての要素を少なくとも1回は見なければ最大値は分からない
```

---

## 3. アルゴリズムの正しさの証明

### 3.1 ループ不変条件

```python
# ループ不変条件（Loop Invariant）:
# ループの各反復の前に成り立つ性質

def insertion_sort(arr):
    """挿入ソート"""
    for i in range(1, len(arr)):
        # ループ不変条件: arr[0:i] はソート済み
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
        # ループ不変条件: arr[0:i+1] はソート済み
    # 終了時: i = len(arr) なので arr[0:len(arr)] がソート済み ✓

# ループ不変条件の3つの性質:
# 1. 初期化: ループ開始前に成り立つ（arr[0:1]は自明にソート済み）
# 2. 維持:   反復のたびに維持される（各ステップでソート範囲が拡大）
# 3. 終了:   ループ終了時に目的の性質が成り立つ（全体がソート済み）
```

### 3.2 再帰の正しさ — 帰納法

```python
# 数学的帰納法によるアルゴリズムの正しさの証明

def factorial(n):
    """n! を再帰的に計算"""
    if n <= 1:    # 基底ケース
        return 1
    return n * factorial(n - 1)  # 再帰ケース

# 証明:
# 基底ケース: n=0, n=1 の時、1を返す → 0!=1, 1!=1 ✓
# 帰納ステップ:
#   factorial(k) = k! が正しいと仮定する（帰納法の仮定）
#   factorial(k+1) = (k+1) * factorial(k) = (k+1) * k! = (k+1)! ✓
# よって全ての n≥0 に対して factorial(n) = n! ✓
```

---

## 4. アルゴリズムの分類

### 4.1 問題の種類別

```
問題の分類とアルゴリズム:

  ┌─────────────┬──────────────────┬─────────────────┐
  │ 問題の種類   │ 代表的アルゴリズム │ 実務での例       │
  ├─────────────┼──────────────────┼─────────────────┤
  │ 探索        │ 二分探索, ハッシュ │ DB検索, 辞書引き │
  │ ソート      │ クイックソート,    │ ランキング,      │
  │             │ マージソート       │ データ整理       │
  │ グラフ      │ BFS, DFS,        │ 経路探索,        │
  │             │ ダイクストラ       │ SNSの友達推薦    │
  │ 文字列      │ KMP, Rabin-Karp  │ 全文検索,        │
  │             │                  │ テキストエディタ  │
  │ 最適化      │ DP, 貪欲法       │ スケジューリング, │
  │             │                  │ リソース配分     │
  │ 数値計算    │ ニュートン法,     │ 科学シミュレーション│
  │             │ FFT              │ 信号処理         │
  │ 暗号        │ RSA, AES,        │ HTTPS,          │
  │             │ SHA-256          │ 電子署名         │
  │ 機械学習    │ 勾配降下法,       │ 推薦,           │
  │             │ 逆伝播           │ 画像認識         │
  └─────────────┴──────────────────┴─────────────────┘
```

---

## 5. 実践演習

### 演習1: 日常のアルゴリズム（基礎）
以下の日常作業をアルゴリズムとして記述せよ（5条件を満たすように）:
1. 本棚で特定の本を探す
2. トランプを並べ替える

### 演習2: 問題解決プロセス（応用）
「配列から重複する要素を全て取り除く」問題を、3つの異なる方法で解き、各計算量を比較せよ。

### 演習3: 正しさの証明（発展）
二分探索アルゴリズムの正しさをループ不変条件を用いて証明せよ。

---

## FAQ

### Q1: アルゴリズムとデータ構造の関係は？
**A**: 密接に関連している。適切なデータ構造を選ぶことでアルゴリズムの効率が劇的に変わる。例: 探索→配列(O(n)) vs ハッシュテーブル(O(1))。「アルゴリズム + データ構造 = プログラム」（Wirth, 1976）。

### Q2: アルゴリズムを学ぶとどんな実務に役立ちますか？
**A**: 直接的にはパフォーマンス最適化、システム設計、コーディング面接。間接的には問題分解力、論理的思考力、「計算量の感覚」が身につき、日常的なコーディングの質が向上する。

### Q3: 全てのアルゴリズムを暗記する必要がありますか？
**A**: いいえ。重要なのは「設計パターン」と「計算量の感覚」を身につけること。具体的な実装は必要な時に調べればよい。ただし基本的なソート・探索・グラフアルゴリズムは理解しておくべき。

---

## まとめ

| 概念 | ポイント |
|------|---------|
| 定義 | 有限の明確な手順で問題を解く計算手続き |
| 5条件 | 入力、出力、明確性、有限性、有効性 |
| 設計戦略 | 全探索、分割統治、DP、貪欲法、二分探索等 |
| 正しさ | ループ不変条件、数学的帰納法で証明 |
| 思考法 | 理解→手計算→設計→実装→テスト |

---

## 次に読むべきガイド
→ [[01-complexity-analysis.md]] — 計算量解析（Big-O記法）

---

## 参考文献
1. Cormen, T. H. et al. "Introduction to Algorithms (CLRS)." 4th Edition, MIT Press, 2022.
2. Knuth, D. E. "The Art of Computer Programming." Addison-Wesley, 1968-2022.
3. Skiena, S. S. "The Algorithm Design Manual." 3rd Edition, Springer, 2020.
