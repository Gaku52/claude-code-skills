# システム設計概要

> 大規模システムを「なぜ・どう設計するか」を体系的に学び、設計面接から実務まで通用する思考フレームワークを習得する。

## この章で学ぶこと

1. システム設計の全体プロセスと各フェーズで問うべき質問
2. 機能要件・非機能要件の切り分けとトレードオフ分析の手法
3. 設計面接で高評価を得るための構造化アプローチ

---

## 1. システム設計とは何か

システム設計（System Design）とは、ビジネス要件を満たすソフトウェアシステムの**アーキテクチャ、コンポーネント、データフロー、インターフェース**を定義する活動である。単にコードを書く能力とは異なり、**スケーラビリティ、信頼性、保守性**を同時に満たす構造を導く力が求められる。

### 設計プロセスの4ステップ

```
Step 1: 要件の明確化（Clarify Requirements）
  - 機能要件（FR）: システムが「何をするか」
  - 非機能要件（NFR）: 性能、可用性、一貫性など
  - 制約条件: 予算、チーム規模、既存技術スタック

Step 2: 見積もり（Estimation）
  - DAU / QPS / ストレージ / 帯域幅

Step 3: 高レベル設計（High-Level Design）
  - コンポーネント図、データフロー図

Step 4: 詳細設計（Deep Dive）
  - ボトルネック分析、トレードオフ議論
```

---

## 2. 機能要件と非機能要件

```
┌──────────────────────────────────────────────────┐
│                  要件の分類                        │
├────────────────────┬─────────────────────────────┤
│   機能要件 (FR)     │   非機能要件 (NFR)           │
├────────────────────┼─────────────────────────────┤
│ ユーザー登録       │ レイテンシ < 200ms           │
│ 投稿の作成/削除    │ 可用性 99.99%               │
│ タイムライン表示   │ 1日1億リクエスト対応         │
│ 通知送信           │ データ損失ゼロ               │
│ 検索機能           │ GDPR準拠                    │
└────────────────────┴─────────────────────────────┘
```

---

## 3. 見積もり（Back-of-the-Envelope Estimation）

設計面接では概算を即座に出す力が問われる。

### コード例1: QPS の見積もり

```python
# Twitter風サービスの見積もり
dau = 300_000_000          # DAU 3億
tweets_per_user_per_day = 2
read_write_ratio = 100     # 読み100 : 書き1

# 書き込み QPS
write_qps = dau * tweets_per_user_per_day / 86400
print(f"書き込み QPS: {write_qps:,.0f}")   # ≈ 6,944

# 読み込み QPS
read_qps = write_qps * read_write_ratio
print(f"読み込み QPS: {read_qps:,.0f}")     # ≈ 694,444

# ピーク時 (平均の2〜5倍)
peak_write = write_qps * 3
peak_read = read_qps * 3
print(f"ピーク書き込み QPS: {peak_write:,.0f}")  # ≈ 20,833
print(f"ピーク読み込み QPS: {peak_read:,.0f}")    # ≈ 2,083,333
```

### コード例2: ストレージ見積もり

```python
# 1ツイートあたりのデータサイズ
tweet_id = 8           # bytes
user_id = 8
text = 280             # 最大280文字 = 280 bytes (ASCII)
media_url = 256
timestamp = 8
total_per_tweet = tweet_id + user_id + text + media_url + timestamp
# = 560 bytes

tweets_per_day = dau * tweets_per_user_per_day  # 6億
storage_per_day = tweets_per_day * total_per_tweet
storage_per_year = storage_per_day * 365

print(f"1日のストレージ: {storage_per_day / 1e12:.2f} TB")   # ≈ 0.34 TB
print(f"1年のストレージ: {storage_per_year / 1e12:.1f} TB")  # ≈ 122.6 TB
```

### コード例3: 帯域幅見積もり

```python
# 読み込み帯域幅
avg_response_size = 10_000  # 10 KB (テキスト+メタデータ)
bandwidth_read = peak_read * avg_response_size
print(f"ピーク読み込み帯域: {bandwidth_read / 1e9:.1f} Gbps")  # ≈ 20.8 Gbps
```

---

## 4. 高レベル設計の描き方

### ASCII図解1: 典型的なWebアプリケーション構成

```
                         ┌─────────────┐
                         │   DNS       │
                         └──────┬──────┘
                                │
                         ┌──────▼──────┐
              ┌──────────│   CDN       │──────────┐
              │          └──────┬──────┘          │
              │                 │ (miss)          │ (static)
              │          ┌──────▼──────┐          │
              │          │   LB (L7)   │          │
              │          └──┬───┬───┬──┘          │
              │             │   │   │             │
              │        ┌────▼┐ ┌▼──┐┌▼────┐       │
              │        │ App ││App ││ App │       │
              │        │ S1  ││ S2 ││ S3  │       │
              │        └──┬──┘└─┬──┘└──┬──┘       │
              │           │     │      │          │
              │        ┌──▼─────▼──────▼──┐       │
              │        │   Cache (Redis)  │       │
              │        └────────┬─────────┘       │
              │                 │ (miss)          │
              │        ┌───────▼──────────┐       │
              │        │  DB Primary      │       │
              │        │  ┌──────────┐    │       │
              │        │  │ Replica  │    │       │
              │        └──┴──────────┴────┘       │
              └───────────────────────────────────┘
```

### ASCII図解2: 設計面接の時間配分（45分の場合）

```
  0        5       10       15              35     40    45
  ├────────┼────────┼────────┼───────────────┼──────┼─────┤
  │ 要件   │ 見積   │ 高レベ │   詳細設計     │ まと │ Q&A │
  │ 確認   │ もり   │ ル設計 │  (Deep Dive)  │  め  │     │
  │  5min  │  5min  │  5min  │    20min      │ 5min │5min │
  └────────┴────────┴────────┴───────────────┴──────┴─────┘
```

### ASCII図解3: トレードオフの三角形

```
              性能 (Performance)
                /\
               /  \
              /    \
             / 最適 \
            /  解は  \
           /  中央   \
          /    域    \
         /____________\
   コスト              信頼性
  (Cost)           (Reliability)

  ※ 3つ全てを最大化することは不可能
    → ビジネス要件に応じてバランスを取る
```

---

## 5. 詳細設計のアプローチ

### コード例4: レイテンシの見積もり参照表

```python
# Jeff Deanのレイテンシ数値（2024年版概算）
latency_numbers = {
    "L1 cache reference":           "1 ns",
    "L2 cache reference":           "4 ns",
    "Main memory reference":        "100 ns",
    "SSD random read":              "16 us",
    "HDD seek":                     "2 ms",
    "Same datacenter round trip":   "0.5 ms",
    "Cross-continent round trip":   "150 ms",
}

for operation, latency in latency_numbers.items():
    print(f"{operation:40s} {latency}")

# 設計のルール:
# - メモリ内操作: ナノ秒オーダー
# - SSD操作: マイクロ秒オーダー
# - ネットワーク: ミリ秒オーダー
# - ディスク(HDD): ミリ秒オーダー
```

### コード例5: 2の冪乗テーブル

```python
# 設計面接でよく使う2の冪乗
powers_of_two = {
    10: "1 KB (千)",
    20: "1 MB (百万)",
    30: "1 GB (十億)",
    40: "1 TB (一兆)",
    50: "1 PB (千兆)",
}

for power, label in powers_of_two.items():
    print(f"2^{power:2d} = {2**power:>20,} bytes = {label}")
```

---

## 6. 比較表

### 比較表1: 設計アプローチの比較

| 観点 | トップダウン設計 | ボトムアップ設計 |
|------|-----------------|-----------------|
| 開始点 | ビジネス要件から | 技術コンポーネントから |
| 長所 | ビジネス価値に直結 | 技術的正確性が高い |
| 短所 | 技術的実現可能性の見落とし | 過剰設計のリスク |
| 適する場面 | 設計面接、新規プロジェクト | 既存システムのリファクタ |
| リスク | 実装不可能な設計 | ビジネス要件との乖離 |

### 比較表2: 機能要件 vs 非機能要件

| 項目 | 機能要件 (FR) | 非機能要件 (NFR) |
|------|--------------|-----------------|
| 定義 | 何をするか | どのように実現するか |
| 例 | ユーザー登録、検索 | レイテンシ、可用性 |
| テスト方法 | 機能テスト | 負荷テスト、カオステスト |
| 変更頻度 | 高い（機能追加） | 低い（基盤的） |
| 影響範囲 | 特定機能 | システム全体 |
| 見落としの危険度 | 低い（明示的） | 高い（暗黙的） |

---

## 7. アンチパターン

### アンチパターン1: 要件確認なしの即設計

```
❌ ダメな例:
面接官: 「Twitterを設計してください」
候補者: 「まずマイクロサービスで...Kafkaを使って...」

→ 何のためのシステムかを理解せず技術選定に走っている

✅ 正しい例:
面接官: 「Twitterを設計してください」
候補者: 「いくつか確認させてください。
  1. コア機能はツイート投稿とタイムライン表示でよいですか？
  2. DAUはどの程度を想定しますか？
  3. 画像/動画のサポートは必要ですか？
  4. リアルタイム性はどの程度求められますか？」
```

### アンチパターン2: 銀の弾丸症候群

```
❌ ダメな例:
「全ての問題はキャッシュで解決できる」
「マイクロサービスにすれば全て解決」
「NoSQLを使えばスケールする」

→ 万能な技術は存在しない。常にトレードオフがある。

✅ 正しい例:
「読み込みが多いのでキャッシュが有効。
  ただしキャッシュ無効化の複雑さと
  データ整合性のトレードオフを考慮する必要がある」
```

---

## 8. FAQ

### Q1: システム設計の勉強はどこから始めるべきですか？

まず本ガイドの「00-fundamentals」セクションで基礎概念（スケーラビリティ、信頼性、CAP定理）を固める。次に「01-components」で個別コンポーネント（LB、キャッシュ、MQ）を学ぶ。最後に「03-case-studies」で実際の設計問題を解く流れが効率的である。書籍としては *Designing Data-Intensive Applications*（Martin Kleppmann著）が最も推奨される。

### Q2: 設計面接でホワイトボードに何を描けばよいですか？

最低限以下の要素を含める: (1) クライアント、(2) ロードバランサー、(3) アプリケーションサーバー群、(4) データストア、(5) キャッシュレイヤー。矢印でデータフローの方向を示し、各コンポーネント間のプロトコル（HTTP、gRPC、WebSocket等）を明記する。数値（QPS、レイテンシ目標）もボックスの近くに記載すると説得力が増す。

### Q3: 実務とシステム設計面接の違いは何ですか？

面接では45分という制約の中で「思考プロセス」を見せることが重要であり、完璧な設計は求められない。実務では時間をかけて段階的に設計し、プロトタイプで検証する。面接では深さより広さが重視される傾向がある一方、実務では特定の問題に対する深い理解が求められる。

---

## まとめ

| 項目 | ポイント |
|------|---------|
| システム設計の目的 | ビジネス要件を満たすスケーラブルで信頼性の高いアーキテクチャを定義する |
| 4ステップ | 要件確認 → 見積もり → 高レベル設計 → 詳細設計 |
| 要件の分類 | 機能要件（何をするか）と非機能要件（どう実現するか） |
| 見積もりの重要性 | QPS、ストレージ、帯域幅を概算し設計判断の根拠とする |
| トレードオフ思考 | 性能・コスト・信頼性は同時最大化不可、ビジネスに応じて選択 |
| 面接のコツ | 要件確認から始め、思考プロセスを声に出しながら進める |

---

## 次に読むべきガイド

- [スケーラビリティ](./01-scalability.md) — 水平/垂直スケーリングの基礎
- [信頼性](./02-reliability.md) — フォールトトレランスと冗長化
- [CAP定理](./03-cap-theorem.md) — 分散システム設計の理論的基盤

---

## 参考文献

1. Kleppmann, M. (2017). *Designing Data-Intensive Applications*. O'Reilly Media.
2. Xu, A. (2020). *System Design Interview – An insider's guide*. Byte Code LLC.
3. Dean, J. & Barroso, L.A. (2013). "The Tail at Scale." *Communications of the ACM*, 56(2), 74-80.
4. Google SRE Book — https://sre.google/sre-book/table-of-contents/
