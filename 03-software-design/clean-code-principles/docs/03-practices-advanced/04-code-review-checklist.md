# コードレビューチェックリスト

> コードレビューは品質保証・知識共有・チーム学習の3つの役割を担う。主観に頼らず体系的なチェックリストに基づいて効率的かつ建設的なレビューを行うための観点・プロセス・コミュニケーション手法を解説する

## この章で学ぶこと

1. **レビューの観点体系** — 正確性、可読性、保守性、セキュリティ、パフォーマンスの5軸チェック
2. **効率的なレビュープロセス** — PR サイズ制限、レスポンスタイム SLA、自動化との組み合わせ
3. **建設的なフィードバック** — コメントの種類分類、提案型レビュー、心理的安全性の確保

---

## 1. レビュー観点の5軸

### 1.1 チェックリスト全体構成

```
コードレビュー 5軸チェック

  +-----------+
  | 正確性     |  ← ロジックは正しいか？エッジケースは？
  +-----------+
       |
  +-----------+
  | 可読性     |  ← 6ヶ月後の自分が理解できるか？
  +-----------+
       |
  +-----------+
  | 保守性     |  ← 変更が容易か？テストはあるか？
  +-----------+
       |
  +-----------+
  | セキュリティ|  ← 入力検証は？認証・認可は？
  +-----------+
       |
  +-----------+
  | パフォーマンス| ← N+1問題は？メモリリークは？
  +-----------+
```

### 1.2 各軸の詳細チェックリスト

```python
# 正確性チェック
correctness_checklist = [
    "ビジネスロジックが要件と一致しているか",
    "エッジケース（null、空配列、0、負数、最大値）が処理されているか",
    "エラーハンドリングが適切か（例外の種類、リカバリー）",
    "並行処理の問題はないか（レースコンディション、デッドロック）",
    "トランザクション境界は正しいか",
    "既存テストが通るか（回帰がないか）",
]

# 可読性チェック
readability_checklist = [
    "変数名・関数名が意図を明確に伝えているか",
    "関数の長さは適切か（20行以内が目安）",
    "ネストが深すぎないか（3段以内が目安）",
    "コメントが「なぜ」を説明しているか（「何」はコードが語るべき）",
    "一貫した命名規則に従っているか",
    "不要なコメントやデッドコードがないか",
]

# 保守性チェック
maintainability_checklist = [
    "単一責任原則に従っているか（1クラス=1責務）",
    "DRY原則：重複コードはないか",
    "テストが追加されているか（新機能・バグ修正）",
    "既存のアーキテクチャパターンに従っているか",
    "依存関係の方向は正しいか（レイヤー違反がないか）",
    "マジックナンバーが定数化されているか",
]

# セキュリティチェック
security_checklist = [
    "入力のバリデーション・サニタイズは適切か",
    "SQLインジェクション対策（パラメータバインド）",
    "XSS対策（出力エスケープ）",
    "認証・認可チェックが漏れていないか",
    "機密情報がログに出力されていないか",
    "秘密鍵・トークンがコードにハードコードされていないか",
]

# パフォーマンスチェック
performance_checklist = [
    "N+1 クエリ問題はないか",
    "不要なデータの取得（SELECT *）はないか",
    "ループ内でのDB/API呼び出しはないか",
    "適切なインデックスが設定されているか",
    "大量データ処理でメモリを圧迫しないか",
    "キャッシュすべきデータをキャッシュしているか",
]
```

---

## 2. レビューフローとルール

### 2.1 プロセス

```
  PR 作成
    |
    v
  [自動チェック] ← CI: lint, test, coverage, security scan
    |
    | 全パス
    v
  [セルフレビュー] ← 作者自身がまず確認
    |
    v
  [レビュー依頼] ← 1-2名のレビュアーをアサイン
    |
    +---> レビュアー確認 (目標: 24時間以内)
    |
    v
  [フィードバック]
    |
    +---> Approve → マージ
    |
    +---> Request Changes → 修正 → 再レビュー
    |
    +---> Comment → 議論 → 合意形成
```

### 2.2 PR サイズガイドライン

```
PR サイズと品質の関係

  変更行数    レビュー品質    推奨度
  ─────────────────────────────────
  < 50行      非常に高い      最適
  50-200行    高い           推奨
  200-400行   中程度         許容
  400-800行   低い           分割推奨
  > 800行     非常に低い      分割必須

  研究結果 (SmartBear):
  - 200行以下のレビューで欠陥発見率が最大
  - 400行を超えると「LGTM」と流す傾向が強まる
  - 60分以上のレビューで集中力が低下
```

### 2.3 レビュー時間の目安

```python
# レビューの効率的な時間配分
review_time_guide = {
    "small_pr":   {"lines": "< 100",   "time": "15分以内"},
    "medium_pr":  {"lines": "100-300",  "time": "30分以内"},
    "large_pr":   {"lines": "300-500",  "time": "60分以内"},
    "too_large":  {"lines": "> 500",    "time": "分割を依頼"},
}

# レスポンスタイム SLA
response_sla = {
    "initial_review":  "24時間以内",    # 最初のレビュー
    "re_review":       "8時間以内",     # 修正後の再レビュー
    "urgent_hotfix":   "2時間以内",     # 緊急修正
}
```

---

## 3. コメントの分類と書き方

### 3.1 コメントプレフィックス

```
[MUST]     必ず修正が必要（マージブロッカー）
[SHOULD]   できれば修正してほしい
[NIT]      些細な指摘（修正任意）
[QUESTION] 質問・確認事項
[PRAISE]   良いコードへの称賛
[FYI]      参考情報の共有

使用例:
  [MUST] SQL インジェクションの脆弱性があります。
         パラメータバインドを使用してください。

  [SHOULD] この関数が40行あるので、バリデーション部分を
           別メソッドに抽出すると可読性が向上します。

  [NIT] 変数名 `d` → `delivery_date` の方が意図が明確です。

  [PRAISE] このテストケースの境界値の網羅性が素晴らしいです。
```

### 3.2 提案型コメント

```python
# BAD: 否定だけのコメント
# 「このコードは読みにくいです」

# GOOD: 具体的な改善案を提示
# [SHOULD] ネストが深くなっています。
# 早期リターンパターンに変更すると可読性が向上します：
#
# Before:
def process(order):
    if order:
        if order.is_valid():
            if order.items:
                # 処理...
                pass

# Suggested:
def process(order):
    if not order:
        return
    if not order.is_valid():
        raise ValueError("Invalid order")
    if not order.items:
        raise ValueError("Empty items")
    # 処理...
```

### 3.3 GitHub Suggestion 機能

```python
# GitHub の Suggestion 構文で直接修正を提案

# レビューコメントで以下のように書く:
#
# [NIT] 定数名は UPPER_SNAKE_CASE にしましょう。
#
# ```suggestion
# MAX_RETRY_COUNT = 3
# TIMEOUT_SECONDS = 30
# ```
#
# → 作者はワンクリックで適用可能
```

---

## 4. 自動化との組み合わせ

```
レビューの役割分担

  自動化 (CI) が担当:
  ├── コードスタイル (Ruff, ESLint)
  ├── 型チェック (MyPy, TypeScript)
  ├── テスト実行
  ├── カバレッジ計測
  ├── セキュリティスキャン (Bandit, Snyk)
  └── 依存関係の脆弱性チェック

  人間が担当:
  ├── ビジネスロジックの正確性
  ├── 設計・アーキテクチャの妥当性
  ├── 可読性と命名の適切さ
  ├── テストケースの十分性
  └── コンテキスト依存の判断

  ★ 自動化できることは自動化し、人間は高次の判断に集中
```

---

## 5. 比較表

| レビュー手法 | 対象 | コスト | 欠陥発見率 | 知識共有効果 |
|------------|------|-------|:--------:|:----------:|
| PR レビュー (非同期) | コード差分 | 低 | 中 | 中 |
| ペアプログラミング | リアルタイム | 高 | 高 | 高 |
| モブプログラミング | チーム全体 | 最高 | 最高 | 最高 |
| 自動レビュー (CI) | 静的解析 | 最低 | 低 (パターン限定) | なし |
| アーキテクチャレビュー | 設計文書 | 中 | 高 (設計レベル) | 高 |

| 観点 | 自動化可能 | 人間が必要 |
|------|:--------:|:--------:|
| コードスタイル | 完全自動化 | -- |
| 型安全性 | 完全自動化 | -- |
| テスト通過 | 完全自動化 | -- |
| ビジネスロジック | -- | 必須 |
| 設計判断 | -- | 必須 |
| 命名の適切さ | 部分自動化 | 必須 |
| テストの十分性 | 部分自動化 | 必須 |

---

## 6. アンチパターン

### アンチパターン 1: 人格攻撃になるレビュー

```
BAD:
  「なんでこんな書き方するんですか？普通はこう書きます」
  「このコードは素人レベルです」
  → 心理的安全性の崩壊、レビュー文化の衰退

GOOD:
  「[SHOULD] この部分、早期リターンパターンを使うと
   ネストが減って可読性が上がります。以下のようにいかがでしょう？」
  「[PRAISE] このエラーハンドリングの設計は参考になります」
  → コードに対するフィードバック、人に対する敬意
```

### アンチパターン 2: LGTM スタンプ

```
BAD:
  「LGTM」(1分でレビュー完了、400行のPR)
  → レビューの意味がない、品質保証にならない

GOOD:
  - 最低1つは具体的なコメントを残す
  - 良い点も指摘する ([PRAISE])
  - PR が大きすぎる場合は分割を依頼する
  - 理解できない箇所は [QUESTION] で質問する
```

---

## 7. FAQ

### Q1. レビュアーは何人が適切か？

**A.** 1-2名が最適。3名以上になると「誰かが見てくれるだろう」効果（社会的手抜き）が発生する。重要な変更やアーキテクチャに関わる変更は2名、通常の変更は1名で十分。CODEOWNERS ファイルで自動アサインを設定し、ドメイン知識を持つ適切なレビュアーに振り分ける。

### Q2. レビューで意見が対立した場合は？

**A.** (1) 客観的根拠（パフォーマンスベンチマーク、公式ドキュメント）で議論する。(2) 3コメント以上往復したらオフライン（ビデオ通話）で直接話す。(3) チームのコーディング規約に明記して今後の基準にする。(4) 合意できない場合はテックリードが最終判断する。個人の好みの問題は議論せず、チーム規約に任せる。

### Q3. セルフレビューのポイントは？

**A.** PR 作成後、レビュー依頼前に自分で差分を確認する。チェックポイント: (1) デバッグ用コード（print, console.log）が残っていないか。(2) コミットメッセージは変更内容を正確に反映しているか。(3) 不要な変更（フォーマットのみの差分）が混ざっていないか。(4) テストを追加したか。セルフレビューで指摘事項の30%は事前に除去できる。

---

## まとめ

| 項目 | ポイント |
|------|---------|
| 5軸チェック | 正確性、可読性、保守性、セキュリティ、パフォーマンス |
| PR サイズ | 200行以下が最適。400行超は分割必須 |
| レスポンスタイム | 初回24時間以内、再レビュー8時間以内 |
| コメント分類 | MUST / SHOULD / NIT / QUESTION / PRAISE で明確化 |
| 提案型フィードバック | 否定ではなく具体的な改善案を提示 |
| 自動化との分担 | スタイル・型・テストは CI、ロジック・設計は人間 |
| 心理的安全性 | コードへのフィードバック、人への敬意 |

---

## 次に読むべきガイド

- [API設計](./03-api-design.md) — レビュー対象となる API の設計原則
- [テスト原則](../01-practices/04-testing-principles.md) — テストコードのレビュー観点
- [技術的負債](../02-refactoring/03-technical-debt.md) — レビューで負債の蓄積を防ぐ

---

## 参考文献

1. **Software Engineering at Google** — Titus Winters et al. (O'Reilly, 2020) — Google のコードレビュープラクティス
2. **The Art of Readable Code** — Dustin Boswell & Trevor Foucher (O'Reilly, 2011) — 可読性の原則
3. **Google Engineering Practices: Code Review** — https://google.github.io/eng-practices/review/
4. **SmartBear: Best Practices for Code Review** — https://smartbear.com/learn/code-review/best-practices-for-peer-code-review/
