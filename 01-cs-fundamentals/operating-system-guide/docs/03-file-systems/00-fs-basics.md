# ファイルシステムの基礎

> ファイルシステムは「ディスク上のバイト列を、人間が理解できるファイルとディレクトリの階層構造に変換する」仕組み。

## この章で学ぶこと

- [ ] ファイルシステムの基本構造を理解する
- [ ] inodeとディレクトリの仕組みを説明できる
- [ ] ジャーナリングの必要性を知る

---

## 1. ファイルシステムの構造

```
ディスクの物理構造 → ファイルシステムの論理構造:

  物理: セクタ(512B/4KB)の連続
  ┌──┬──┬──┬──┬──┬──┬──┬──┬──┬──┐
  │S0│S1│S2│S3│S4│S5│S6│S7│S8│S9│...
  └──┴──┴──┴──┴──┴──┴──┴──┴──┴──┘

  論理: ファイルとディレクトリの階層
  /
  ├── home/
  │   └── user/
  │       ├── document.txt
  │       └── photo.jpg
  ├── etc/
  │   └── config.yaml
  └── var/
      └── log/

ext4の基本レイアウト:
  ┌──────┬──────────┬──────────┬──────────┬──────┐
  │Boot  │ Block    │ inode    │ inode    │Data  │
  │Block │ Group    │ Table    │ Bitmap   │Blocks│
  │      │Descriptor│          │ + Block  │      │
  │      │          │          │ Bitmap   │      │
  └──────┴──────────┴──────────┴──────────┴──────┘

  Superblock: ファイルシステム全体のメタデータ
  → ブロックサイズ、総ブロック数、空きブロック数等
```

---

## 2. inodeとディレクトリ

```
inode（index node）:
  ファイルのメタデータを格納する構造体

  ┌──────────────────────────────┐
  │ inode #12345                 │
  │ ファイルタイプ: 通常ファイル │
  │ パーミッション: rwxr-xr-x   │
  │ 所有者: uid=1000            │
  │ グループ: gid=1000          │
  │ サイズ: 4096 bytes          │
  │ タイムスタンプ:             │
  │   atime: 最終アクセス時刻   │
  │   mtime: 最終変更時刻       │
  │   ctime: メタデータ変更時刻 │
  │ リンク数: 1                 │
  │ データブロックポインタ:      │
  │   直接: [B1][B2]...[B12]   │
  │   間接: [→ ブロック群]      │
  │   二重間接: [→→ ブロック群] │
  │   三重間接: [→→→ ...]      │
  └──────────────────────────────┘

  注意: inodeにはファイル名は含まれない！
  → ファイル名はディレクトリが管理

ディレクトリ:
  ファイル名とinode番号の対応表

  /home/user/ のディレクトリエントリ:
  ┌──────────────┬──────────┐
  │ ファイル名    │ inode番号│
  ├──────────────┼──────────┤
  │ .            │ 201      │
  │ ..           │ 100      │
  │ document.txt │ 12345    │
  │ photo.jpg    │ 12346    │
  └──────────────┴──────────┘

ハードリンク vs シンボリックリンク:
  ハードリンク: 同じinodeを指す別名
  → ln original.txt link.txt
  → inode同一、リンクカウント+1
  → ディレクトリ不可、パーティション跨ぎ不可

  シンボリックリンク: パスを格納する特別なファイル
  → ln -s /path/to/original symlink
  → 別のinode、パス文字列を格納
  → ディレクトリ可、パーティション跨ぎ可
  → リンク先が削除されるとダングリングリンク
```

---

## 3. ジャーナリング

```
問題: 書き込み中に電源断が発生したら？

  ファイル作成の手順:
  1. inodeを割り当て
  2. ディレクトリにエントリ追加
  3. データブロックに書き込み

  → ステップ2の後に電源断
  → inodeは存在するがデータがない = 不整合

ジャーナリング:
  変更を「ジャーナル（ログ）」に先に書き込む

  ┌──────────────────────────────────┐
  │ 1. ジャーナルに変更を記録         │
  │    (どのブロックをどう変更するか) │
  │ 2. 実際のデータを書き込み         │
  │ 3. ジャーナルの記録を削除         │
  └──────────────────────────────────┘

  電源断が発生した場合:
  → 起動時にジャーナルを確認
  → 未完了の変更を再実行（リプレイ）またはロールバック
  → fsckの長時間実行が不要に

  ジャーナリングモード（ext4）:
  - journal:  データ+メタデータをジャーナリング（最安全、最遅）
  - ordered:  メタデータをジャーナリング、データは先に書く（デフォルト）
  - writeback: メタデータのみジャーナリング（最速、データ消失リスク）

CoW（Copy-on-Write）ファイルシステム:
  Btrfs, ZFS はジャーナルの代わりにCoWを使用
  → データを上書きせず、新しい場所に書き込み
  → アトミックな更新、スナップショットが高速
```

---

## 4. VFS（Virtual File System）

```
VFS: Linuxの統一ファイルシステムインターフェース

  アプリケーション
     │ open(), read(), write()
     ↓
  ┌──────────────────────────────┐
  │ VFS (Virtual File System)    │
  │ → 統一API                    │
  └──┬────┬────┬────┬────┬──────┘
     ↓    ↓    ↓    ↓    ↓
   ext4  XFS  Btrfs NTFS  NFS
   (実際のファイルシステム実装)

  VFSの4つの主要オブジェクト:
  1. superblock: ファイルシステムのメタデータ
  2. inode: ファイルのメタデータ
  3. dentry: ディレクトリエントリ（キャッシュ）
  4. file: 開いているファイルの状態

  → どのFSでも同じAPIでアクセス可能
  → 新しいFSの追加が容易
```

---

## 実践演習

### 演習1: [基礎] — inode の確認

```bash
# inodeの確認
ls -li                        # inode番号表示
stat filename                 # 詳細なメタデータ
df -i                         # inode使用状況

# ハードリンクとシンボリックリンク
echo "hello" > original.txt
ln original.txt hardlink.txt
ln -s original.txt symlink.txt
ls -li original.txt hardlink.txt symlink.txt
# → hardlinkはinode同一、symlinkは異なるinode
```

### 演習2: [応用] — ファイルシステムの調査

```bash
# マウントされたファイルシステムの確認
mount | column -t
df -Th                        # タイプ付きで表示

# ファイルシステムの詳細情報（Linux, ext4）
sudo dumpe2fs /dev/sda1 | head -30
sudo tune2fs -l /dev/sda1     # superblock情報
```

---

## FAQ

### Q1: なぜinodeが枯渇するのか？

小さなファイルが大量にある場合、ディスク容量に余裕があってもinode数が上限に達することがある（例: メールサーバーの大量メール）。`df -i` で確認可能。ext4ではmkfs時のオプションで初期inode数を指定できる。

### Q2: ext4, XFS, Btrfsの選び方は？

- **ext4**: 最も安定。デスクトップ、一般サーバーに最適。最大16TB
- **XFS**: 大ファイル、高並列I/Oに強い。RHELのデフォルト
- **Btrfs**: スナップショット、圧縮、RAID機能内蔵。SUSEのデフォルト

---

## まとめ

| 概念 | ポイント |
|------|---------|
| inode | ファイルのメタデータ。名前は含まない |
| ディレクトリ | 名前→inode番号の対応表 |
| ジャーナリング | 不整合防止。電源断からの高速復旧 |
| VFS | 統一API。異なるFSを透過的にアクセス |

---

## 次に読むべきガイド
→ [[01-fs-implementations.md]] — 主要FS実装

---

## 参考文献
1. Silberschatz, A. et al. "Operating System Concepts." 10th Ed, Ch.13-15, 2018.
2. Love, R. "Linux Kernel Development." 3rd Ed, Ch.13, 2010.
