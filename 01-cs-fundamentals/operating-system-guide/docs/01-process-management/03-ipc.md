# プロセス間通信（IPC）

> プロセスは独立したメモリ空間を持つため、データをやり取りするには明示的な通信手段が必要。

## この章で学ぶこと

- [ ] 主要なIPC手法を比較できる
- [ ] パイプ、ソケット、共有メモリの使い分けを理解する
- [ ] シグナルの仕組みを知る

---

## 1. IPC手法の全体像

```
IPC手法の比較:

┌────────────────┬──────────┬──────────┬───────────┬──────────┐
│ 手法           │ 方向     │ 速度     │ 関連性    │ 用途例   │
├────────────────┼──────────┼──────────┼───────────┼──────────┤
│ パイプ         │ 片方向   │ 中       │ 親子      │ ls | grep│
│ 名前付きパイプ │ 片方向   │ 中       │ 無関係可  │ ログ収集 │
│ シグナル       │ 通知のみ │ 速       │ 無関係可  │ kill, Ctrl+C│
│ メッセージキュー│ 双方向  │ 中       │ 無関係可  │ タスクキュー│
│ 共有メモリ     │ 双方向   │ 最速     │ 無関係可  │ DB、キャッシュ│
│ ソケット       │ 双方向   │ 中〜遅   │ 無関係可  │ ネットワーク│
│ Unixドメイン   │ 双方向   │ 速       │ 同一マシン│ Docker, DB│
│  ソケット      │          │          │           │          │
│ mmap           │ 双方向   │ 最速     │ 無関係可  │ ファイル共有│
└────────────────┴──────────┴──────────┴───────────┴──────────┘
```

---

## 2. パイプ

```
無名パイプ（Pipe）:
  親子プロセス間のバイトストリーム

  $ ls -la | grep ".md" | wc -l

  ls ──→ [パイプ] ──→ grep ──→ [パイプ] ──→ wc
  stdout    stdin     stdout     stdin

  カーネル内のバッファ（通常64KB）
  → バッファが満杯なら書き込み側がブロック
  → バッファが空なら読み込み側がブロック

名前付きパイプ（FIFO）:
  ファイルシステム上に名前を持つパイプ
  → 無関係なプロセス間で通信可能

  $ mkfifo /tmp/myfifo
  $ echo "hello" > /tmp/myfifo &  # 書き込み
  $ cat /tmp/myfifo                # 読み込み → "hello"
```

---

## 3. シグナル

```
シグナル: プロセスへの非同期通知

  主要なシグナル:
  ┌──────────┬──────┬──────────────────────┐
  │ シグナル  │ 番号 │ 動作                  │
  ├──────────┼──────┼──────────────────────┤
  │ SIGHUP   │ 1    │ 端末切断 / 設定再読込 │
  │ SIGINT   │ 2    │ Ctrl+C（割り込み）    │
  │ SIGQUIT  │ 3    │ Ctrl+\（コアダンプ）  │
  │ SIGKILL  │ 9    │ 強制終了（捕捉不可）  │
  │ SIGSEGV  │ 11   │ セグフォ（不正メモリ）│
  │ SIGTERM  │ 15   │ 正常終了要求          │
  │ SIGSTOP  │ 19   │ 一時停止（捕捉不可）  │
  │ SIGCONT  │ 18   │ 再開                  │
  │ SIGCHLD  │ 17   │ 子プロセス終了通知    │
  │ SIGUSR1  │ 10   │ ユーザー定義1         │
  └──────────┴──────┴──────────────────────┘

  $ kill -TERM 1234    # PID 1234にSIGTERM送信
  $ kill -9 1234       # PID 1234をSIGKILL（強制終了）
  $ kill -HUP $(cat /var/run/nginx.pid)  # nginx設定再読込

  SIGKILL vs SIGTERM:
  SIGTERM: プロセスが捕捉して後処理可能（推奨）
  SIGKILL: 即座に強制終了（最終手段）
  → 必ずSIGTERMを先に送り、応答がなければSIGKILL
```

---

## 4. 共有メモリとmmap

```
共有メモリ:
  複数プロセスが同じ物理メモリ領域をマッピング
  → IPC最速（カーネルを経由しない）
  → 同期は自前で行う必要あり（セマフォ等）

  Process A             Process B
  ┌──────────┐         ┌──────────┐
  │仮想メモリ │         │仮想メモリ │
  │  ┌─────┐ │         │ ┌─────┐  │
  │  │共有 │─│────┐────│─│共有 │  │
  │  │領域 │ │    │    │ │領域 │  │
  │  └─────┘ │    │    │ └─────┘  │
  └──────────┘    │    └──────────┘
                  ↓
            物理メモリ上の
            同一領域

mmap:
  ファイルをメモリにマッピング
  → ファイルI/Oをメモリアクセスで実現
  → カーネルのページキャッシュを直接利用
  → 大きなファイルの効率的な読み書き
```

---

## 5. ソケット

```
Unixドメインソケット:
  同一マシン内のプロセス間通信
  → TCPソケットより高速（ネットワークスタック不要）
  → ファイルシステム上にソケットファイルを作成

  用途: Docker, PostgreSQL, MySQL, nginx

  $ ls -la /var/run/docker.sock
  srw-rw---- 1 root docker 0 ... /var/run/docker.sock

TCPソケット:
  ネットワーク越しの通信にも使用可能
  → 最も汎用的なIPC（マシン間通信対応）
  → オーバーヘッドは大きい
```

---

## 実践演習

### 演習1: [基礎] — パイプの実践

```bash
# 以下のパイプラインの各段階の出力を確認せよ
ps aux | awk '{print $1}' | sort | uniq -c | sort -rn | head -5

# 名前付きパイプを使って2つのターミナル間で通信せよ
# ターミナル1:
mkfifo /tmp/chat
cat /tmp/chat

# ターミナル2:
echo "Hello from terminal 2" > /tmp/chat
```

### 演習2: [応用] — シグナルハンドリング

```python
import signal, sys, time

def handler(signum, frame):
    print(f"\nシグナル {signum} を受信。終了処理中...")
    sys.exit(0)

signal.signal(signal.SIGTERM, handler)
signal.signal(signal.SIGINT, handler)

print(f"PID: {os.getpid()}. Ctrl+C または kill で終了")
while True:
    time.sleep(1)
```

---

## FAQ

### Q1: DockerはなぜUnixドメインソケットを使うのか？

Docker CLIとDockerデーモンは同一マシン上で通信するため、TCPよりも高速で認証管理が容易なUnixドメインソケットが最適。ソケットファイルのパーミッションでアクセス制御でき、ネットワークスタックのオーバーヘッドもない。

### Q2: パイプとメッセージキューの違いは？

パイプは**バイトストリーム**（区切りなし）。メッセージキューは**メッセージ単位**（境界あり、優先度付き）。パイプは使い捨て（プロセス終了で消滅）だが、メッセージキューは明示的に削除するまで存続する。

---

## まとめ

| IPC手法 | 速度 | 用途 |
|---------|------|------|
| パイプ | 中 | シェルコマンド連携 |
| シグナル | 速 | プロセス制御（終了、再読込） |
| 共有メモリ | 最速 | 大量データ共有 |
| Unixドメインソケット | 速 | ローカルサービス通信 |
| TCPソケット | 中〜遅 | ネットワーク通信 |

---

## 次に読むべきガイド
→ [[../02-memory-management/00-virtual-memory.md]] — 仮想メモリ

---

## 参考文献
1. Kerrisk, M. "The Linux Programming Interface." No Starch Press, Ch.43-57, 2010.
2. Stevens, W. R. "UNIX Network Programming, Vol.2: IPC." Prentice Hall, 1998.
