# OSの歴史と進化

> OSの歴史は「抽象化の積み重ね」の歴史である -- ハードウェアの複雑さから人間を解放する戦いの記録。

## この章で学ぶこと

- [ ] OSの進化の主要なマイルストーンを知る
- [ ] バッチ処理→タイムシェアリング→GUIの流れを理解する
- [ ] 現代OSのルーツを辿れる
- [ ] 各時代のOS設計思想がなぜ生まれたかを理解する
- [ ] Unix/Linux/Windowsの歴史的背景を詳しく知る

---

## 1. OSの進化年表

### 1.1 1940-1950年代: OS以前の時代

```
コンピュータの黎明期:

  1943-1945: ENIAC（Electronic Numerical Integrator and Computer）
  ┌──────────────────────────────────────────────┐
  │ - 世界初の汎用電子コンピュータ（米陸軍）      │
  │ - 重量30トン、18,000本の真空管                │
  │ - プログラミング = 配線を物理的に変更         │
  │ - OSという概念は存在しない                    │
  │ - オペレーター（多くは女性数学者）が手動操作  │
  └──────────────────────────────────────────────┘

  1949: EDSAC（Electronic Delay Storage Automatic Calculator）
  → ストアードプログラム方式の実用化
  → プログラムをメモリに格納して実行
  → フォン・ノイマン・アーキテクチャの実装

  1950年代前半の典型的なコンピュータ利用:
  ┌──────────────────────────────────────────────┐
  │ 1. プログラマがパンチカードにプログラムを記述 │
  │ 2. オペレーターにカードの束を渡す             │
  │ 3. オペレーターがカードをリーダーに投入       │
  │ 4. コンピュータが1つのジョブを実行           │
  │ 5. 結果がプリンターに出力                     │
  │ 6. 次のジョブの準備（テープ交換等）に数分     │
  │ 7. この間、高価なCPUは完全にアイドル状態     │
  │                                              │
  │ 問題: CPUの利用効率が極めて低い              │
  │ → 1秒1ドル相当の高価なマシンが遊んでいる    │
  │ → 人間の作業がボトルネック                   │
  └──────────────────────────────────────────────┘

  この問題を解決するために、最初のOSが生まれた。
```

### 1.2 1950年代後半: バッチ処理の時代

```
1950年代: バッチ処理の時代
  ┌──────────────────────────────────────────┐
  │ パンチカード → コンピュータ → 結果出力    │
  │ 人間がプログラムを1つずつ投入             │
  │ OSは存在しない（オペレータが手動管理）    │
  │                                          │
  │ 1956: GM-NAA I/O（最初のOS）             │
  │ → IBM 704用のバッチ処理システム           │
  │ → ゼネラルモーターズとノースアメリカン航空が共同開発│
  │ → ジョブを自動的に次々実行               │
  │ → 人間の介入なしにジョブを切り替え       │
  └──────────────────────────────────────────┘

  バッチ処理OSの仕組み:
  ┌──────────────────────────────────────────────┐
  │ ┌─────────┐  ┌─────────┐  ┌─────────┐      │
  │ │ Job 1   │→│ Job 2   │→│ Job 3   │→ ... │
  │ │(FORTRAN)│  │(COBOL)  │  │(Assemb.)│      │
  │ └─────────┘  └─────────┘  └─────────┘      │
  │                                              │
  │ 常駐モニタ（Resident Monitor）:              │
  │ - メモリに常駐する小さなプログラム           │
  │ - ジョブの読み込みと実行を自動化             │
  │ - JCL（Job Control Language）でジョブを記述  │
  │                                              │
  │ JCLの例:                                     │
  │ $JOB                                         │
  │ $FORTRAN                                     │
  │ (FORTRANソースコード)                        │
  │ $LOAD                                        │
  │ $RUN                                         │
  │ (入力データ)                                 │
  │ $END                                         │
  └──────────────────────────────────────────────┘

  1959: SHARE Operating System (SOS)
  → IBM 709用のバッチ処理OS
  → ユーザーコミュニティSHAREが開発

  バッチ処理OSの限界:
  - CPUがI/O待ちの間、完全にアイドル
  - 対話的な操作が不可能
  - デバッグが極めて困難（結果は翌日返却）
  → これを解決するのがマルチプログラミング
```

### 1.3 1960年代: マルチプログラミングとタイムシェアリング

```
1960年代: マルチプログラミングとタイムシェアリング
  ┌──────────────────────────────────────────┐
  │ 1961: CTSS（Compatible Time-Sharing System）│
  │ → MIT。最初のタイムシェアリングOS         │
  │ → 複数ユーザーが同時にコンピュータを使用  │
  │ → Fernando Corbatóが開発                  │
  │ → Corbatóは2014年にチューリング賞受賞     │
  │                                          │
  │ CTSSの革新:                               │
  │ - 端末から対話的にプログラミング可能       │
  │ - エラーをその場で修正できる               │
  │ - ファイルシステムの原型                   │
  │ - メールシステムの原型                     │
  └──────────────────────────────────────────┘

  マルチプログラミングの原理:
  ┌──────────────────────────────────────────────┐
  │ 問題: Job AがI/O待ちの間、CPUは何もしていない│
  │                                              │
  │ 従来（シングルプログラミング）:              │
  │ Job A: ██████░░░░░░██████░░░░░░              │
  │ CPU:   ██████______██████______              │
  │ (░=I/O待ち  _=CPU空き)                       │
  │                                              │
  │ マルチプログラミング:                        │
  │ Job A: ██████░░░░░░██████░░░░░░              │
  │ Job B: ______██████░░░░░░██████              │
  │ CPU:   ████████████████████████ ← 常に稼働！ │
  │                                              │
  │ → CPUの利用率が飛躍的に向上                  │
  │ → 複数のジョブをメモリに同時に保持           │
  │ → メモリ保護が必要になる（ジョブ間の隔離）   │
  └──────────────────────────────────────────────┘

  1964: Multics（MULTiplexed Information and Computing Service）
  ┌──────────────────────────────────────────────────┐
  │ → MIT + Bell Labs + GE の共同プロジェクト        │
  │ → 野心的すぎて商業的には失敗                     │
  │ → しかしUnixに多大な影響を与えた                 │
  │                                                  │
  │ Multicsの革新的な概念:                           │
  │ - 仮想メモリ: セグメンテーション+ページング       │
  │ - ダイナミックリンク: 共有ライブラリの原型        │
  │ - 階層的ファイルシステム: ディレクトリの木構造    │
  │ - アクセス制御リスト（ACL）: セキュリティモデル  │
  │ - リング構造の保護: Ring 0-7の権限レベル         │
  │ - PLANプログラミング言語: PL/Iベースのシステム言語│
  │                                                  │
  │ 失敗の原因:                                      │
  │ - 過度に複雑な設計                               │
  │ - ハードウェア（GE 645）の性能不足               │
  │ - プロジェクト管理の問題                         │
  │ - Bell Labsが1969年に離脱                        │
  │   → Thompson & Ritchieが「シンプルなMultics」を構想│
  │   → これがUnixの誕生につながる                   │
  └──────────────────────────────────────────────────┘

  1964: IBM OS/360
  ┌──────────────────────────────────────────┐
  │ → 最初の汎用OS（複数機種で共通）         │
  │ → IBM System/360ファミリー全体で動作      │
  │ → Fred Brooks "Mythical Man-Month"の題材 │
  │                                          │
  │ OS/360の教訓:                             │
  │ - 「人月の神話」: 遅れたプロジェクトに    │
  │   人を追加するとさらに遅れる             │
  │ - 数百万行のコード、数千人の開発者       │
  │ - ソフトウェア工学の重要性を認識させた   │
  │ - バグだらけだったが、商業的には大成功   │
  │                                          │
  │ IBMの互換性戦略:                          │
  │ - 1つのOSで小型機から大型機まで対応       │
  │ - 「ソフトウェアの互換性」という概念の確立│
  │ - 現在のx86互換性の先駆け                │
  └──────────────────────────────────────────┘

  1965: THE（Technische Hogeschool Eindhoven）
  → Dijkstraによる階層構造OS
  → セマフォの発明（同期プリミティブ）
  → 構造化プログラミングの提唱
  → OSの設計をソフトウェア工学的に捉えた最初の例
```

### 1.4 1970年代: Unixの誕生

```
1970年代: Unixの誕生
  ┌──────────────────────────────────────────┐
  │ 1969: Unix（Ken Thompson & Dennis Ritchie）│
  │ → Multicsの反省から「シンプル」を追求     │
  │ → 最初はPDP-7上でアセンブラで記述        │
  │                                          │
  │ 1971: Unix Version 1 (PDP-11)            │
  │ → テキスト処理のためにBell Labsの特許部門に導入│
  │                                          │
  │ 1973: C言語でUnixを書き直し              │
  │ → 「OSを高級言語で書く」革命的な発想     │
  │ → 移植性が飛躍的に向上                   │
  │ → Dennis RitchieがC言語を設計            │
  │                                          │
  │ 1974: "The UNIX Time-Sharing System"論文  │
  │ → ACM Communications に掲載              │
  │ → 学術界に大きな反響                     │
  │                                          │
  │ Unix哲学:                                │
  │ 1. 1つのことをうまくやる                 │
  │ 2. テキストストリームで連携              │
  │ 3. 小さなツールを組み合わせる            │
  │ 4. できるだけ早くプロトタイプを作る       │
  │ 5. 移植性を重視する                      │
  └──────────────────────────────────────────┘

  Unixの分裂（Unix Wars）:
  ┌──────────────────────────────────────────────────┐
  │ 1977: BSD（Berkeley Software Distribution）      │
  │ → カリフォルニア大学バークレー校                 │
  │ → Bill Joy（後のSun共同創設者）が中心            │
  │ → TCP/IPネットワーキングの実装（DARPA資金）      │
  │ → vi エディタ、csh シェルの開発                  │
  │ → 仮想メモリの改良（ページドVM）                 │
  │                                                  │
  │ 1983: System V Release 1 (AT&T)                  │
  │ → AT&Tの商用Unix                                 │
  │ → System V vs BSD の「Unix戦争」                 │
  │                                                  │
  │ 2つの系統の違い:                                 │
  │ ┌──────────────┬──────────────────┐              │
  │ │ BSD          │ System V         │              │
  │ ├──────────────┼──────────────────┤              │
  │ │ TCP/IPネット │ STREAMS          │              │
  │ │ csh          │ sh (Bourne Shell)│              │
  │ │ vi           │ ed               │              │
  │ │ 仮想メモリ改良│ IPC (msg, shm)  │              │
  │ │ BSDライセンス│ 商用ライセンス   │              │
  │ └──────────────┴──────────────────┘              │
  │                                                  │
  │ → 最終的にPOSIXで標準化（1988年）               │
  │ → 両方の良い部分を統合                           │
  └──────────────────────────────────────────────────┘

  1979: Unix Version 7
  → 「最後の真のUnix」と呼ばれる
  → 最も影響力のあるバージョン
  → awk, make, tar, cpio 等のツールを含む
  → 多くのUnix系OSの基盤となった
```

### 1.5 1980年代: PCとGUI

```
1980年代: PCとGUI
  ┌──────────────────────────────────────────┐
  │ 1981: MS-DOS（Microsoft）                │
  │ → IBM PC用。コマンドライン               │
  │ → Tim Patersonが開発した QDOS を買収     │
  │ → CP/M（Gary Kildall）の互換OS          │
  │ → シングルタスク、メモリ保護なし         │
  │ → しかし IBM PCの普及とともに支配的に    │
  │                                          │
  │ 1983: GNU プロジェクト（Richard Stallman）│
  │ → 自由なUnix互換OSを目指す               │
  │ → GNUコンパイラ (gcc)                    │
  │ → GNUユーティリティ (coreutils)          │
  │ → Emacs エディタ                         │
  │ → GPLライセンスの創設                    │
  │ → カーネル (GNU Hurd) は完成せず         │
  │ → Linuxカーネルと組み合わさってGNU/Linux │
  │                                          │
  │ 1984: Macintosh（Apple）                 │
  │ → 初の商業的成功を収めたGUI OS           │
  │ → Xerox PARCのAltoに着想                 │
  │ → Steve Jobsが PARC を訪問して着想を得る│
  │ → マウス操作、ウィンドウ、アイコン       │
  │ → 128KBメモリ、9インチモノクロ画面       │
  │ → 「1984」のスーパーボウル CM            │
  │                                          │
  │ 1987: MINIX（Andrew Tanenbaum）          │
  │ → 教育用マイクロカーネルOS               │
  │ → 教科書 "Operating Systems: Design and  │
  │   Implementation" の付録                 │
  │ → Linusに影響を与えた                    │
  │ → Tanenbaum-Torvalds議論（1992年）:     │
  │   「Linuxはモノリシックで時代遅れ」      │
  │   → 結果的にLinuxが世界を席巻            │
  └──────────────────────────────────────────┘

  GUIの系譜:
  ┌──────────────────────────────────────────────────┐
  │ 1973: Xerox Alto                                  │
  │ → 世界初のGUIコンピュータ                         │
  │ → マウス、ウィンドウ、WYSIWYG、イーサネット      │
  │ → 商業化されず（研究用）                          │
  │                                                  │
  │ 1981: Xerox Star (8010)                           │
  │ → Altoの商業版だが価格が高すぎて失敗             │
  │                                                  │
  │ 1984: Apple Macintosh                             │
  │ → GUIを一般消費者に普及させた最初のPC            │
  │                                                  │
  │ 1985: Windows 1.0 (Microsoft)                     │
  │ → MS-DOS上のGUIシェル                             │
  │ → タイル型ウィンドウ（重ね合わせ不可）           │
  │ → 商業的にはほぼ失敗                             │
  │                                                  │
  │ 1987: Windows 2.0                                 │
  │ → 重ね合わせウィンドウを実現                     │
  │ → Apple が著作権侵害で訴訟                       │
  │                                                  │
  │ 1990: Windows 3.0                                 │
  │ → 初めて商業的に成功したWindows                   │
  │ → 386プロテクトモード対応                        │
  │ → 「Solitaire」が搭載                            │
  └──────────────────────────────────────────────────┘
```

### 1.6 1990年代: Linux, Windows, Web

```
1990年代: Linux, Windows, Web
  ┌──────────────────────────────────────────┐
  │ 1991: Linux（Linus Torvalds）            │
  │ → 「趣味のOS」として開始                 │
  │ → フィンランドのヘルシンキ大学の学生     │
  │ → GPLライセンスでオープンソース           │
  │ → 世界中の開発者が貢献                   │
  │                                          │
  │ Linuxの最初の投稿（1991年8月25日）:      │
  │ "Hello everybody out there using minix - │
  │  I'm doing a (free) operating system     │
  │  (just a hobby, won't be big and         │
  │  professional like gnu) for 386(486) AT  │
  │  clones."                                │
  │                                          │
  │ Linuxの急成長:                            │
  │ 1991: v0.01（10,000行）                  │
  │ 1994: v1.0（176,000行）                  │
  │ 1996: v2.0（マルチプロセッサ対応）       │
  │ 2003: v2.6（数百万行）                   │
  │ 2025: v6.x（約3,000万行）               │
  └──────────────────────────────────────────┘

  ┌──────────────────────────────────────────┐
  │ 1993: Windows NT                         │
  │ → 本格的な32bit OS（Dave Cutler設計）    │
  │ → 現在のWindowsの基盤                    │
  │ → VMS設計者による「正しいOS」の設計      │
  │                                          │
  │ Windows NTの設計目標:                     │
  │ - 完全な32bitアーキテクチャ              │
  │ - メモリ保護（プロセス隔離）             │
  │ - プリエンプティブマルチタスク            │
  │ - マルチプロセッサ対応                    │
  │ - ポータビリティ（x86, Alpha, MIPS, PPC）│
  │ - POSIX, OS/2サブシステム対応            │
  │ - NTFS（ジャーナリングファイルシステム）  │
  │ - Win32 API                               │
  └──────────────────────────────────────────┘

  ┌──────────────────────────────────────────┐
  │ 1995: Windows 95                         │
  │ → GUIの普及、Start Menu                  │
  │ → PCの一般家庭への普及                   │
  │ → プラグ＆プレイ                         │
  │ → 長いファイル名のサポート               │
  │ → 発売日に行列ができるほどの社会現象     │
  │ → ローリングストーンズ "Start Me Up"     │
  │                                          │
  │ 1998: Windows 98                         │
  │ → USB対応、Internet Explorer 4統合       │
  │ → まだDOSベース（不安定）                │
  │                                          │
  │ 2000: Windows 2000 / Windows Me          │
  │ → NT系: 安定、企業向け                   │
  │ → Me系: DOS系最後、不安定で悪評          │
  │                                          │
  │ 2001: Windows XP                         │
  │ → NT系とDOS系の統合                      │
  │ → 消費者向けでもNTカーネルに             │
  │ → 13年間サポート（2014年まで）           │
  │ → 史上最も長く使われたWindows            │
  └──────────────────────────────────────────┘

  1990年代のオープンソース運動:
  ┌──────────────────────────────────────────────┐
  │ 1991: Linux カーネル (GPL)                    │
  │ 1993: Debian プロジェクト発足                 │
  │ 1993: FreeBSD 1.0 リリース                    │
  │ 1994: Red Hat Linux 1.0                       │
  │ 1995: Apache HTTP Server                      │
  │ 1998: "Open Source" 用語の創出                │
  │ 1998: Netscapeがソースコード公開 → Mozilla    │
  │ 1999: GNOME 1.0, KDE 1.0                     │
  │                                               │
  │ 「大聖堂とバザール」(Eric Raymond, 1997):    │
  │ → 大聖堂方式: 少数の設計者が閉鎖的に開発    │
  │ → バザール方式: 多数の開発者がオープンに開発 │
  │ → Linuxはバザール方式の成功例                │
  │ → "Given enough eyeballs, all bugs are shallow"│
  │   （十分な目があれば、どんなバグも浅い）     │
  └──────────────────────────────────────────────┘
```

### 1.7 2000年代以降: モバイルとクラウド

```
2000年代〜: モバイルとクラウド
  ┌──────────────────────────────────────────┐
  │ 2001: Mac OS X（macOS）                  │
  │ → NeXTSTEP + FreeBSD = Darwin            │
  │ → Unix基盤の商用デスクトップOS           │
  │ → Aqua GUI（水面のような美しいUI）       │
  │ → Terminal.appでUnixコマンドが使える     │
  │ → 正式なUNIX 03認証を取得               │
  │                                          │
  │ Apple の OS 戦略:                         │
  │ 1997: NeXT買収、Steve Jobs復帰           │
  │ 2001: Mac OS X 10.0 "Cheetah"           │
  │ 2001-2019: 大型ネコ科の名前（→ 地名に変更）│
  │ 2020: macOS Big Sur (macOS 11)           │
  │ 2020: Apple Silicon (M1) 対応            │
  └──────────────────────────────────────────┘

  ┌──────────────────────────────────────────┐
  │ 2007: iPhone OS（iOS）                   │
  │ → モバイルOS時代の幕開け                 │
  │ → マルチタッチインターフェース           │
  │ → App Storeエコシステム（2008年〜）      │
  │ → スマートフォン革命の引き金             │
  │                                          │
  │ iOSの技術的特徴:                          │
  │ - XNUカーネル（macOSと共通基盤）         │
  │ - サンドボックスモデル（アプリ隔離）     │
  │ - Objective-C → Swift                    │
  │ - Metal GPU API（OpenGL ES → Metal）     │
  │ - Core ML（オンデバイスAI推論）          │
  └──────────────────────────────────────────┘

  ┌──────────────────────────────────────────┐
  │ 2008: Android                            │
  │ → Linux カーネル上に構築                  │
  │ → 世界最大のモバイルOS                   │
  │ → Googleが2005年にAndroid社を買収        │
  │ → オープンソース（AOSP）                 │
  │                                          │
  │ Androidのアーキテクチャ:                  │
  │ ┌────────────────────────────┐           │
  │ │ Applications               │           │
  │ │ (Java/Kotlin → APK)       │           │
  │ ├────────────────────────────┤           │
  │ │ Android Framework          │           │
  │ │ (Activity, Service等)      │           │
  │ ├────────────────────────────┤           │
  │ │ ART (Android Runtime)      │           │
  │ │ (Dalvik VM → ART)         │           │
  │ ├────────────────────────────┤           │
  │ │ HAL (Hardware Abstraction) │           │
  │ ├────────────────────────────┤           │
  │ │ Linux Kernel               │           │
  │ │ (Binder IPC, ashmem等拡張) │           │
  │ └────────────────────────────┘           │
  └──────────────────────────────────────────┘

  ┌──────────────────────────────────────────────┐
  │ 2013: Docker                                  │
  │ → コンテナ技術でOS仮想化を革新               │
  │ → Solomon HykesがdotCloudで開発              │
  │ → Linuxのnamespace + cgroups を使いやすく    │
  │                                              │
  │ Dockerの影響:                                 │
  │ - 「Build, Ship, Run Anywhere」              │
  │ - DevOpsの加速                               │
  │ - マイクロサービスアーキテクチャの普及       │
  │ - Kubernetesの登場（2014年、Google）         │
  │ - クラウドネイティブ開発の標準に             │
  │                                              │
  │ 2014: Kubernetes (K8s)                       │
  │ → Googleの社内システム Borg/Omega がルーツ   │
  │ → コンテナオーケストレーションの標準に       │
  │ → CNCF（Cloud Native Computing Foundation）  │
  └──────────────────────────────────────────────┘

  ┌──────────────────────────────────────────┐
  │ 2020: Apple Silicon（M1）                │
  │ → ARM + macOS でPC性能の常識を覆す       │
  │ → 高性能 + 低消費電力の両立             │
  │ → x86からARM移行の成功例                │
  │ → Rosetta 2でx86バイナリを変換実行      │
  │ → 統合メモリアーキテクチャ               │
  │                                          │
  │ 2024-2025: AI PCの時代                   │
  │ → NPU（Neural Processing Unit）内蔵PC   │
  │ → Apple M4, Qualcomm Snapdragon X Elite │
  │ → Intel Meteor Lake / Arrow Lake         │
  │ → OSレベルでのAI機能統合                │
  │ → Windows: Copilot, Recall              │
  │ → macOS: Apple Intelligence             │
  └──────────────────────────────────────────┘
```

---

## 2. 重要な概念の進化

### 2.1 マルチタスクの進化

```
マルチタスクの進化:

  バッチ処理（1950s）:
  Job1 ──────→ Job2 ──────→ Job3
  → 1つずつ順番に実行

  マルチプログラミング（1960s）:
  Job1 ██░░██░░██
  Job2 ░░██░░██░░
  → I/O待ちの間に他のジョブを実行

  タイムシェアリング（1960s）:
  User1 █░░█░░█░░
  User2 ░█░░█░░█░
  User3 ░░█░░█░░█
  → 各ユーザーに短い時間を交互に割り当て

  協調的マルチタスク（1980s-90s）:
  → プロセスが自発的にCPUを譲る
  → Windows 3.x, Classic Mac OS
  → 1プロセスが暴走すると全体がフリーズ

  プリエンプティブマルチタスク（1990s〜）:
  → OSがプロセスを強制的に切り替え
  → 1つのプロセスが暴走しても他に影響しない
  → 現代の標準
  → Unix (1969), Windows NT (1993), macOS (2001)

  リアルタイムマルチタスク:
  → 期限（デッドライン）内に確実にタスクを完了
  → Rate Monotonic Scheduling, Earliest Deadline First
  → VxWorks, QNX, FreeRTOS
```

### 2.2 メモリ管理の進化

```
メモリ管理の進化:

  1. 固定パーティション（1950s-60s）:
     ┌────────────────┐
     │ OS             │ 固定サイズ
     ├────────────────┤
     │ パーティション1│ 32KB
     ├────────────────┤
     │ パーティション2│ 64KB
     ├────────────────┤
     │ パーティション3│ 128KB
     └────────────────┘
     → ジョブをサイズに合うパーティションに配置
     → 内部フラグメンテーション（余った部分が無駄）

  2. 可変パーティション（1960s）:
     → ジョブのサイズに合わせてパーティションを動的に作成
     → 外部フラグメンテーション（隙間が散在）
     → コンパクション（ジョブを詰め直す）で解決

  3. ページング（1960s-70s）:
     ┌──────────────────────────────────────────┐
     │ 仮想アドレス空間    物理メモリ            │
     │ ┌────┐              ┌────┐               │
     │ │Page0│ ──────────→ │Frame5│             │
     │ ├────┤              ├────┤               │
     │ │Page1│ ──────────→ │Frame2│             │
     │ ├────┤              ├────┤               │
     │ │Page2│ ──→ ディスク │Frame8│             │
     │ ├────┤              └────┘               │
     │ │Page3│ ──────────→ Frame12             │
     │ └────┘                                   │
     │ → 4KBのページ単位で管理                  │
     │ → 連続した仮想アドレスが不連続な物理メモリに│
     │ → ページテーブルで変換                    │
     └──────────────────────────────────────────┘

  4. 仮想メモリ（1960s〜現在）:
     → 物理メモリ + ディスク（スワップ）= 巨大なアドレス空間
     → デマンドページング: 使われたページだけメモリに読む
     → ページフォルト: アクセスされたページが物理メモリにない
       → OSがディスクから読み込んで続行
     → 各プロセスが独立した広大なアドレス空間を持つ

  5. 現代のメモリ管理技術:
     ┌──────────────────────────────────────────────┐
     │ Huge Pages: 2MB/1GBの大きなページ            │
     │ → TLBミスを減らす（データベース、VM向け）     │
     │                                               │
     │ NUMA-aware: メモリの物理的位置を意識          │
     │ → マルチソケットサーバーで重要                │
     │                                               │
     │ Memory Ballooning: VMのメモリを動的に調整     │
     │ → 仮想化環境でのメモリ効率化                 │
     │                                               │
     │ KSM (Kernel Same-page Merging):               │
     │ → 同一内容のページを統合                      │
     │ → 仮想化環境でのメモリ節約                   │
     │                                               │
     │ zram/zswap: メモリ内圧縮スワップ              │
     │ → ディスクI/Oなしでメモリを節約              │
     └──────────────────────────────────────────────┘
```

### 2.3 ファイルシステムの進化

```
ファイルシステムの進化:

  1950s: 磁気テープ（シーケンシャルアクセスのみ）
  1960s: FAT（Floppy Disk用、フラットな構造）
  1970s: Unix File System（inode、階層構造）
  1980s: FAT16（MS-DOS）、HFS（Macintosh）
  1990s: ext2（Linux）、NTFS（Windows NT）
  2000s: ext3/ext4（ジャーナリング）、ZFS（Sun）
  2010s: Btrfs（Linux）、APFS（Apple）
  2020s: bcachefs（Linux 6.7で統合）

  ジャーナリングファイルシステムの革新:
  ┌──────────────────────────────────────────────┐
  │ 問題: 書き込み中に電源断 → ファイルシステム破損│
  │                                               │
  │ 解決: ジャーナル（変更ログ）を先に書く         │
  │ 1. ジャーナルに変更内容を記録                  │
  │ 2. 実際のデータを書き込み                      │
  │ 3. ジャーナルのエントリを完了マーク             │
  │                                               │
  │ 電源断時:                                      │
  │ - ジャーナルを再生して一貫性を回復             │
  │ - fsck不要（起動が高速）                       │
  │                                               │
  │ ext3/ext4, NTFS, XFS, JFS がジャーナリング対応 │
  └──────────────────────────────────────────────┘

  Copy-on-Write (CoW) ファイルシステム:
  ┌──────────────────────────────────────────────┐
  │ ZFS, Btrfs, APFS:                             │
  │ - 上書きせず、新しい場所に書く                │
  │ - 一貫性が常に保たれる                        │
  │ - スナップショットが瞬時に作成可能            │
  │ - データの重複排除が可能                      │
  │ - チェックサムでデータの破損を検出            │
  │                                               │
  │ ZFSの特徴（企業向けストレージの決定版）:     │
  │ - 128bitアドレス空間（事実上無限の容量）     │
  │ - RAID-Z（パリティベースの冗長化）           │
  │ - オンラインデータ圧縮                       │
  │ - ARC（Adaptive Replacement Cache）          │
  │ - 暗号化、重複排除、スナップショット         │
  └──────────────────────────────────────────────┘
```

### 2.4 セキュリティの進化

```
OSセキュリティの進化:

  1960s: パスワード認証（CTSS で初めて導入）
  1970s: Unix権限モデル（owner/group/other、rwx）
  1980s: アクセス制御リスト（ACL）
  1990s: ファイアウォール、暗号化ファイルシステム
  2000s: SELinux（NSA）、ASLR、DEP/NX
  2010s: サンドボックス、コンテナ隔離、UEFI Secure Boot
  2020s: ゼロトラスト、eBPF によるセキュリティ監視

  現代OSのセキュリティ機能:
  ┌──────────────────────────────────────────────────┐
  │ ASLR (Address Space Layout Randomization):       │
  │ → メモリアドレスをランダム化                     │
  │ → バッファオーバーフロー攻撃を困難に             │
  │                                                  │
  │ DEP/NX (Data Execution Prevention):              │
  │ → データ領域でのコード実行を禁止                 │
  │ → スタック上のシェルコード実行を防止             │
  │                                                  │
  │ Stack Canary:                                    │
  │ → スタック上にカナリア値を配置                   │
  │ → バッファオーバーフローを検出                   │
  │                                                  │
  │ Secure Boot:                                     │
  │ → ブートプロセスの各段階で署名を検証             │
  │ → ブートキット（起動時のマルウェア）を防止       │
  │                                                  │
  │ eBPF:                                            │
  │ → カーネル内で安全にプログラムを実行             │
  │ → ネットワーク、セキュリティ、トレーシング       │
  │ → Cilium, Falco 等のセキュリティツールの基盤     │
  └──────────────────────────────────────────────────┘
```

---

## 3. OSの系譜図

```
  Multics (1964)
    │
    ├──→ Unix (1969) ──────────────────────────────────┐
    │      ├── BSD (1977) ──→ FreeBSD ──→ macOS/iOS   │
    │      │                 → OpenBSD（セキュリティ重視）
    │      │                 → NetBSD（移植性重視）     │
    │      ├── System V ──→ Solaris, AIX, HP-UX       │
    │      └── Philosophy ──→ GNU (1983)               │
    │                          └── + Linux (1991)      │
    │                               ├── Ubuntu         │
    │                               ├── RHEL           │
    │                               ├── Android        │
    │                               ├── Chrome OS      │
    │                               └── SteamOS        │
    │
  CP/M (1974) ──→ MS-DOS (1981) ──→ Windows 95/98/Me │
                                                       │
  VMS (1977) ──→ Windows NT (1993) ──→ Win 2000/XP    │
                                    ──→ Win 7/10/11    │
                                                       │
  Xerox Alto (1973) ──→ Macintosh (1984)               │
                    ──→ Windows GUI                     │
                                                       │
  NeXTSTEP (1989) ──→ Mac OS X (2001) ──→ macOS       │
                                                       │
  新しい流れ:                                          │
  Linux Kernel ──→ Android (2008)                      │
  Linux Kernel ──→ Chrome OS (2011)                    │
  Zircon (μkernel) ──→ Fuchsia (Google, 2016-)        │
  Redox (Rust) ──→ 次世代Unix-likeOS                   │

各OSの影響関係:
┌────────────────────────────────────────────────────┐
│ Multics → Unix: シンプルさの追求                    │
│ Unix → BSD: 学術的改良、ネットワーキング            │
│ Unix → Linux: オープンソースでの再実装              │
│ BSD → macOS: NeXTSTEP経由でAppleに                 │
│ VMS → Windows NT: Dave Cutlerが設計思想を持ち込む  │
│ Xerox Alto → Mac, Windows: GUIの概念               │
│ Plan 9 → Linux /proc, /sys: 仮想ファイルシステム   │
│ MINIX → Linux: Linusの出発点                       │
│ Linux → Docker/K8s: コンテナ技術の基盤             │
│ Linux → Android: モバイルOSの基盤                  │
└────────────────────────────────────────────────────┘
```

---

## 4. OSの未来

```
現在進行中の変革:

  1. AI統合OS:
     ┌──────────────────────────────────────────────┐
     │ - Windows: Copilot, Windows Recall           │
     │ - macOS: Apple Intelligence                  │
     │ - Linux: ML推論の最適化（CUDA, ROCm統合）    │
     │                                              │
     │ OSレベルのAI機能:                            │
     │ - 自然言語でのシステム操作                    │
     │ - インテリジェントな通知管理                  │
     │ - アプリ横断的なコンテキスト理解             │
     │ - 予測的なリソース管理                       │
     └──────────────────────────────────────────────┘

  2. Rust製OS:
     ┌──────────────────────────────────────────────┐
     │ - LinuxカーネルにRustサポート追加（6.1〜）    │
     │ - Redox OS: Rustで書かれたマイクロカーネルOS │
     │ - Android: 新コードの一部がRustに移行        │
     │ → メモリ安全性の根本的改善                   │
     │ → C言語のメモリバグ（70%が脆弱性の原因）を排除│
     └──────────────────────────────────────────────┘

  3. WebAssembly (Wasm) OS:
     ┌──────────────────────────────────────────────┐
     │ - WASIがPOSIXの後継になる可能性              │
     │ - コンテナの代替としてのWasm                 │
     │ - Fermyon Spin, Wasmtime                     │
     │ → ポータブルで軽量なアプリケーション環境     │
     └──────────────────────────────────────────────┘

  4. Unikernel と MicroVM:
     ┌──────────────────────────────────────────────┐
     │ - AWS Firecracker: MicroVM（Lambda/Fargate）  │
     │ - gVisor: ユーザー空間カーネル（Google）      │
     │ - Kata Containers: VMベースのコンテナ         │
     │ → セキュリティと効率性の新しいバランス        │
     └──────────────────────────────────────────────┘
```

---

## 実践演習

### 演習1: [基礎] -- OS情報の確認

```bash
# 自分のOSの情報を確認
# Linux:
uname -a
cat /etc/os-release
cat /proc/version
hostnamectl  # systemd環境

# macOS:
sw_vers
uname -a
system_profiler SPSoftwareDataType

# カーネルバージョン、ビルド日、アーキテクチャを記録せよ

# カーネルの設定を確認（Linux）
cat /boot/config-$(uname -r) | grep CONFIG_PREEMPT
# → プリエンプションモデルの確認

# ブートログの確認
dmesg | head -50
journalctl -b | head -50  # systemd環境

# ハードウェア情報
lscpu          # CPU情報
lsblk          # ブロックデバイス
lspci          # PCIデバイス
lsusb          # USBデバイス
```

### 演習2: [応用] -- Unix哲学の実践

```bash
# パイプで小さなツールを組み合わせて以下を実現せよ:

# 1. /etc/passwdからシェルの使用統計を取る
cat /etc/passwd | cut -d: -f7 | sort | uniq -c | sort -rn

# 2. アクセスログからステータスコード別の集計
cat access.log | awk '{print $9}' | sort | uniq -c | sort -rn

# 3. ディレクトリ内のファイルサイズトップ10
du -sh * 2>/dev/null | sort -rh | head -10

# 4. プロセスのメモリ使用量ランキング
ps aux --sort=-%mem | awk 'NR<=11{printf "%-10s %5s %s\n", $1, $4, $11}'

# 5. ネットワーク接続の状態別カウント（Linux）
ss -tan | awk 'NR>1{print $1}' | sort | uniq -c | sort -rn

# 6. 自分で同様のパイプラインを3つ考えて実行せよ
# ヒント: ps, netstat, df, du, wc, grep, awk, find, xargs を活用
```

### 演習3: [応用] -- OS歴史の調査レポート

```
以下のいずれかのテーマについて、2000字以上のレポートを書け:

1. Unix戦争（BSD vs System V）の経緯と影響
   - 技術的な違い
   - ライセンスの問題
   - POSIXによる統一
   - 現代への影響

2. Linux vs MINIX 議論（Tanenbaum-Torvalds debate）
   - モノリシック vs マイクロカーネルの議論
   - 両者の主張
   - 30年後の評価
   - 現代のOS設計への影響

3. Windowsの進化（MS-DOS → Windows 11）
   - アーキテクチャの変遷
   - GUI の進化
   - NT カーネルの設計思想
   - WSL2 による Linux との融合

4. Apple のOS戦略（Classic Mac OS → macOS → iOS）
   - NeXT買収の意義
   - Unix基盤への移行
   - iOSとmacOSの統合（Apple Silicon）
   - エコシステムの強さ
```

### 演習4: [発展] -- 各世代のOSをエミュレータで体験

```
以下のOSをエミュレータで体験し、操作感の変化を記録せよ:

1. SIMH（System Simulator）:
   → PDP-11上のUnix V6を体験
   → ed エディタでのファイル編集
   → シェルの操作（Thompson shell）

2. DOSBox:
   → MS-DOS 6.22を体験
   → コマンドライン操作（dir, copy, type, edit）
   → 640KBメモリの制約を体感

3. PCem / 86Box:
   → Windows 3.1 の GUI を体験
   → ファイルマネージャ、ペイントブラシ

4. QEMU:
   → Linuxの初期バージョン（0.01は無理だが1.0系）を起動
   → 最小構成のLinuxの動作を確認

5. ブラウザベースのエミュレータ:
   → copy.sh/v86/ でWindows 95, Linux等を体験
   → archive.org の各種OSエミュレーション

各OSについて以下を記録:
- 起動にかかる時間
- 利用可能なコマンド/操作
- メモリ管理の違い
- マルチタスクの有無
- 現代のOSとの比較
```

---

## FAQ

### Q1: なぜLinuxには多くのディストリビューションがあるのか？

Linuxカーネルはオープンソースであるため、誰でもカーネル+独自のパッケージ管理+独自の設定を組み合わせてディストリビューションを作れる。目的に応じた最適化が異なるため多様性が生まれた（サーバー向けRHEL、デスクトップ向けUbuntu、セキュリティ向けKali、教育向けEdubuntu等）。これは「自由」の証であり、同時に初心者を混乱させる原因でもある。主要なディストリビューションは10程度に集約されつつある。

### Q2: macOSはなぜUnixベースなのか？

Apple がNeXT社を買収（1997年）した際に、Steve Jobsが開発したNeXTSTEP（Mach+BSD）が基盤となった。Darwin（macOSのカーネル）はMachマイクロカーネル+FreeBSDコンポーネントで構成され、正式にUNIX 03認証を取得している。Classic Mac OS（System 1-9）は独自OSだったが、モダンなメモリ保護やプリエンプティブマルチタスクを持たず限界があった。NeXTSTEPの採用により、macOSは安定したUnix基盤と美しいGUIを両立できるようになった。

### Q3: Windows NTとWindows 95は何が違ったのか？

Windows 95はMS-DOS上に構築された16/32bitハイブリッドで不安定だった。一方Windows NTはVMS設計者Dave Cutlerがゼロから設計した完全な32bit OSで、メモリ保護、プリエンプティブマルチタスク、NTFSを備えた。NT系は企業向け（NT 4.0, 2000）として位置づけられ、コンシューマー向け（95, 98, Me）と別ラインだった。Windows XP（2001年）でこの2つのラインが統合され、コンシューマーもNTカーネルの恩恵を受けるようになった。

### Q4: BSDとLinuxは何が違うのか？

技術的には両方ともUnix系OSだが、主要な違いは以下の通り:
1. **カーネル**: BSDはカーネル+ユーザーランドが一体開発。Linuxはカーネルのみ（ユーザーランドはGNU等）
2. **ライセンス**: BSDライセンス（寛容）vs GPL（コピーレフト）
3. **開発モデル**: BSDはコア開発チームが統制。Linuxは分散的（Linusが最終決定）
4. **ドライバ**: Linuxの方がハードウェアサポートが豊富
5. **用途**: FreeBSDはネットワーク機器（Netflix, WhatsApp）、OpenBSDはセキュリティが重要な用途に強い

### Q5: 次世代のOSはどのようなものになるか？

いくつかの方向性が議論されている:
1. **マイクロカーネルの復権**: seL4（形式検証）、Fuchsia（Zircon）
2. **Rust製OS**: メモリ安全性を言語レベルで保証
3. **AI統合**: OSがユーザーの意図を理解し、自律的に最適化
4. **Wasm OS**: WebAssemblyベースのポータブルなOS環境
5. **量子OS**: 量子コンピュータのリソースを管理するOS（研究段階）
6. **脳コンピュータOS**: BCIからの入力を処理するOS（将来）

---

## まとめ

| 時代 | 革新 | 代表OS | 設計思想 |
|------|------|--------|----------|
| 1950s | バッチ処理 | GM-NAA I/O | CPU利用率の向上 |
| 1960s | タイムシェアリング | Multics, CTSS | 対話的コンピューティング |
| 1970s | Unix誕生、C言語 | Unix | シンプルさ、移植性 |
| 1980s | PC、GUI | MS-DOS, Macintosh | 個人用コンピュータ |
| 1990s | オープンソース | Linux, Windows NT | 自由、堅牢性 |
| 2000s | モバイル、クラウド | iOS, Android, Docker | ユビキタス、仮想化 |
| 2020s | AI統合、ARM | Apple Silicon, AI PC | 効率性、知能化 |

---

## 次に読むべきガイド
→ [[../01-process-management/00-processes.md]] -- プロセスの概念

---

## 参考文献
1. Ritchie, D. & Thompson, K. "The UNIX Time-Sharing System." CACM, 1974.
2. Raymond, E. "The Art of Unix Programming." Addison-Wesley, 2003.
3. Campbell-Kelly, M. "From Airline Reservations to Sonic the Hedgehog: A History of the Software Industry." MIT Press, 2003.
4. Brinch Hansen, P. "Classic Operating Systems: From Batch Processing to Distributed Systems." Springer, 2001.
5. Brooks, F. "The Mythical Man-Month." Anniversary Edition, Addison-Wesley, 1995.
6. Ceruzzi, P. "A History of Modern Computing." MIT Press, 2003.
7. Salus, P. "A Quarter Century of UNIX." Addison-Wesley, 1994.
8. DiBona, C. et al. "Open Sources: Voices from the Open Source Revolution." O'Reilly, 1999.
