# OSとは何か

> オペレーティングシステムは「ハードウェアの複雑さを隠蔽し、アプリケーションに統一的なインターフェースを提供する」ソフトウェアである。

## この章で学ぶこと

- [ ] OSの役割と基本機能を説明できる
- [ ] カーネルとユーザー空間の違いを理解する
- [ ] OSの基本構造（モノリシック、マイクロカーネル等）を区別できる

---

## 1. なぜOSが必要か

```
OSがない世界:

  アプリケーション → ハードウェアを直接操作

  問題:
  ┌──────────────────────────────────────────┐
  │ 1. 全アプリがハードウェアの詳細を知る必要  │
  │    → ディスクのセクタ番号を直接指定？       │
  │    → GPUのレジスタを直接操作？              │
  │                                            │
  │ 2. リソースの競合                           │
  │    → 2つのアプリが同時にプリンタを使いたい  │
  │    → メモリを好き勝手に使って他を破壊       │
  │                                            │
  │ 3. セキュリティなし                         │
  │    → どのアプリも全データにアクセス可能      │
  │    → 悪意あるプログラムがやりたい放題        │
  └──────────────────────────────────────────┘

OSの役割:
  ┌──────────────────────────────────────────┐
  │ アプリケーション（ブラウザ、エディタ等）    │
  ├──────────────────────────────────────────┤
  │ OS（カーネル）                             │
  │  ├─ プロセス管理:  CPUの時間を分配          │
  │  ├─ メモリ管理:    メモリを安全に分配        │
  │  ├─ ファイルシステム: データの永続化         │
  │  ├─ I/O管理:      デバイスへの統一API       │
  │  └─ セキュリティ:  アクセス制御             │
  ├──────────────────────────────────────────┤
  │ ハードウェア（CPU, メモリ, ディスク, NIC等） │
  └──────────────────────────────────────────┘

  OSの2つの顔:
  1. リソースマネージャー: CPU、メモリ、ディスク等を管理・分配
  2. 抽象化レイヤー: ハードウェアの複雑さを隠蔽し簡単なAPIを提供
```

---

## 2. カーネルとユーザー空間

```
CPUの動作モード（x86の場合）:

  Ring 0（カーネルモード）:
  → 全ハードウェアに直接アクセス可能
  → 特権命令を実行可能
  → OSカーネルが動作

  Ring 3（ユーザーモード）:
  → ハードウェアに直接アクセス不可
  → 特権命令は例外（トラップ）が発生
  → 一般アプリケーションが動作

  ┌───────────────────────────────────────┐
  │  ユーザー空間（Ring 3）                │
  │  ┌──────┐ ┌──────┐ ┌──────┐          │
  │  │Chrome│ │VSCode│ │Slack │ ...       │
  │  └──┬───┘ └──┬───┘ └──┬───┘          │
  │     │        │        │               │
  │═════╪════════╪════════╪═══════════════│
  │     │  システムコール（境界）           │
  │═════╪════════╪════════╪═══════════════│
  │  カーネル空間（Ring 0）                │
  │  ┌──────────────────────────────┐     │
  │  │ プロセス管理 │ メモリ管理    │     │
  │  │ ファイルシステム│ ネットワーク │     │
  │  │ デバイスドライバ               │     │
  │  └──────────────────────────────┘     │
  │  ハードウェア                          │
  └───────────────────────────────────────┘

システムコール（syscall）:
  ユーザー空間からカーネルの機能を呼び出す唯一の窓口

  例（Linux）:
  open()   → ファイルを開く
  read()   → ファイルから読む
  write()  → ファイルに書く
  fork()   → 新しいプロセスを作る
  exec()   → プログラムを実行する
  mmap()   → メモリをマッピング
  socket() → ネットワーク通信

  コスト:
  ユーザーモード → カーネルモードの切替は高コスト（数千サイクル）
  → システムコールの回数を減らすことがパフォーマンスの鍵
  → io_uring (Linux 5.1): 非同期I/Oでsyscall回数を削減
```

---

## 3. カーネルアーキテクチャ

```
1. モノリシックカーネル:
   全OS機能が1つの巨大なバイナリ

   ┌──────────────────────────────────┐
   │ カーネル空間                      │
   │ ┌────┬────┬────┬────┬────┐       │
   │ │プロ│メモ│FS  │Net │ドラ│       │
   │ │セス│リ  │    │    │イバ│       │
   │ └────┴────┴────┴────┴────┘       │
   │ 全てが同一アドレス空間で動作       │
   └──────────────────────────────────┘

   利点: 高速（関数呼び出しで済む）
   欠点: 1つのバグで全体がクラッシュ、巨大化
   例: Linux, FreeBSD

2. マイクロカーネル:
   最小限の機能のみカーネルに、残りはユーザー空間

   ┌──────────────────────────────────┐
   │ ユーザー空間                      │
   │ ┌────┐ ┌────┐ ┌────┐ ┌────┐    │
   │ │FS  │ │Net │ │ドラ│ │アプ│    │
   │ │サーバ││サーバ││イバ│ │リ  │    │
   │ └──┬─┘ └──┬─┘ └──┬─┘ └──┬─┘    │
   │────│──────│──────│──────│───── │
   │ カーネル: IPC + スケジューリング   │
   │           + メモリ管理（最小限）   │
   └──────────────────────────────────┘

   利点: 安定性（サーバーが落ちてもカーネルは生存）
   欠点: IPC（プロセス間通信）のオーバーヘッド
   例: MINIX, QNX, seL4, GNU Hurd

3. ハイブリッドカーネル:
   モノリシックの性能 + マイクロカーネルの設計思想

   例: Windows NT, macOS (XNU), DragonFly BSD
   → 実質的にはモノリシックに近い実装が多い

4. Unikernel:
   アプリ+必要なOS機能のみを1つのイメージにパック

   ┌──────────────────┐
   │ アプリ + OS機能   │  ← 1つのバイナリ
   └──────────────────┘

   利点: 極小サイズ、高速起動、攻撃面が最小
   欠点: シングルアプリ、デバッグ困難
   例: MirageOS, Unikraft

比較:
┌──────────────┬──────────┬──────────┬──────────┐
│ 種類         │ 性能     │ 安定性   │ 採用例   │
├──────────────┼──────────┼──────────┼──────────┤
│ モノリシック  │ ◎       │ △       │ Linux    │
│ マイクロ     │ △       │ ◎       │ QNX      │
│ ハイブリッド │ ○       │ ○       │ Windows  │
│ Unikernel   │ ◎       │ ○       │ クラウド  │
└──────────────┴──────────┴──────────┴──────────┘
```

---

## 4. 主要なOSファミリー

```
Unix系:
  1969: Unix (AT&T Bell Labs — Thompson, Ritchie)
    ├── BSD系: FreeBSD, OpenBSD, NetBSD
    │   └── macOS / iOS (Darwin = Mach + FreeBSD)
    ├── System V系
    │   └── Solaris, AIX, HP-UX
    └── Linux (1991, Linus Torvalds)
        ├── Debian系: Ubuntu, Linux Mint
        ├── Red Hat系: RHEL, CentOS, Fedora, Rocky
        ├── Arch系: Arch Linux, Manjaro
        ├── Android (Linux カーネル)
        └── Chrome OS (Linux カーネル)

Windows系:
  MS-DOS (1981)
    └── Windows 3.1 → 95 → 98 → Me（DOS ベース）
  Windows NT (1993)
    └── NT → 2000 → XP → Vista → 7 → 8 → 10 → 11

その他:
  z/OS: IBM メインフレーム
  VxWorks: 組み込みリアルタイムOS
  Fuchsia: Google の次世代OS（Zircon マイクロカーネル）

現在のシェア（2025年概算）:
  デスクトップ: Windows 72%, macOS 16%, Linux 4%
  サーバー:     Linux 80%+, Windows 15%
  モバイル:     Android 72%, iOS 27%
  スーパーコンピュータ: Linux 100% (TOP500)
```

---

## 5. OSの抽象化

```
OSが提供する主要な抽象化:

  物理リソース    →    OS抽象化
  ────────────────────────────────
  CPU             →    プロセス/スレッド
  物理メモリ      →    仮想アドレス空間
  ディスクセクタ  →    ファイル/ディレクトリ
  ネットワーク    →    ソケット
  ディスプレイ    →    ウィンドウ
  タイマー        →    時刻API

  「Everything is a file」（Unix哲学）:
  /dev/sda        → ディスク
  /dev/null       → 捨て場
  /proc/cpuinfo   → CPU情報
  /dev/urandom    → 乱数
  /dev/tty        → 端末
  → 全てをファイルとして統一的に扱える

  POSIX（Portable Operating System Interface）:
  Unix系OSの標準API仕様
  → POSIXに準拠したプログラムは移植性が高い
  → Linux, macOS, BSD は概ねPOSIX準拠
  → Windows はWSL2でLinux互換環境を提供
```

---

## 実践演習

### 演習1: [基礎] — システムコールの追跡

```bash
# straceでシステムコールを観察（Linux）
strace ls /tmp 2>&1 | head -30

# macOS の場合は dtruss
sudo dtruss ls /tmp 2>&1 | head -30

# 観察ポイント:
# 1. execve() → プログラムの起動
# 2. openat() → ファイルを開く
# 3. getdents() → ディレクトリエントリを読む
# 4. write() → 結果を出力
# 5. close() → ファイルを閉じる

# 課題: 以下のコマンドのsyscallを比較せよ
# - echo "hello" vs printf "hello"
# - cat file vs less file
```

### 演習2: [応用] — カーネルモジュール概念

```
以下の質問に答えよ:

1. Linuxカーネルモジュール（.ko）の役割は何か？
2. lsmod, modprobe, rmmod の違いを説明せよ
3. モノリシックカーネルでありながら、
   なぜLinuxは動的にモジュールを追加できるのか？
4. /proc/modules と lsmod の関係は？
```

### 演習3: [発展] — OS設計の比較

```
以下の要件に最適なOSアーキテクチャを選択し、理由を述べよ:

1. 自動車の制御システム（ブレーキ、ステアリング）
2. Webサーバー（大量リクエスト処理）
3. IoTセンサーデバイス（バッテリー駆動、最小リソース）
4. クラウドのFaaS（Function as a Service）基盤

各ケースで「モノリシック / マイクロ / Unikernel」の
どれが適切か、パフォーマンス・安全性・開発コストの観点で議論せよ
```

---

## FAQ

### Q1: LinuxはUnixなのか？

厳密には「Unixではない」。LinuxはUnixのソースコードを使わずにゼロから書かれた「Unix互換」のOS。AT&TのUnixライセンスは不要。ただしPOSIX互換であり、Unix哲学を踏襲しているため「Unix系（Unix-like）」と呼ばれる。

### Q2: カーネルとOSの違いは？

カーネルはOSの中核部分（ハードウェア管理、プロセス管理等）。OSはカーネル+シェル+ユーティリティ+ライブラリの総称。Linuxは厳密にはカーネル名で、Ubuntu等のディストリビューション全体がOS。

### Q3: なぜサーバーはLinuxが圧倒的か？

1. 無料（ライセンスコストゼロ）
2. オープンソース（カスタマイズ自由）
3. 安定性（数年間の無停止運用が可能）
4. コマンドライン中心（リモート管理に最適）
5. コミュニティとエコシステムの充実

---

## まとめ

| 概念 | ポイント |
|------|---------|
| OSの役割 | リソース管理 + ハードウェア抽象化 |
| カーネル | Ring 0で動作。全ハードウェアにアクセス可能 |
| システムコール | ユーザー空間→カーネルの唯一の窓口 |
| アーキテクチャ | モノリシック(Linux) vs マイクロ(QNX) vs ハイブリッド(Windows) |
| Unix哲学 | Everything is a file。小さなツールを組み合わせる |

---

## 次に読むべきガイド
→ [[01-os-history.md]] — OSの歴史と進化

---

## 参考文献
1. Silberschatz, A. et al. "Operating System Concepts." 10th Ed, Wiley, 2018.
2. Tanenbaum, A. "Modern Operating Systems." 4th Ed, Pearson, 2014.
3. Arpaci-Dusseau, R. & A. "Operating Systems: Three Easy Pieces." 2018.
