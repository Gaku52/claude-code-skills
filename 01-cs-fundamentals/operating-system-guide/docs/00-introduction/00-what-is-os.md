# OSとは何か

> オペレーティングシステムは「ハードウェアの複雑さを隠蔽し、アプリケーションに統一的なインターフェースを提供する」ソフトウェアである。

## この章で学ぶこと

- [ ] OSの役割と基本機能を説明できる
- [ ] カーネルとユーザー空間の違いを理解する
- [ ] OSの基本構造（モノリシック、マイクロカーネル等）を区別できる
- [ ] システムコールの仕組みと主要なsyscallを把握する
- [ ] POSIXやUnix哲学の意義を理解する
- [ ] 主要なOSファミリーの特徴と歴史的背景を知る

---

## 1. なぜOSが必要か

```
OSがない世界:

  アプリケーション → ハードウェアを直接操作

  問題:
  ┌──────────────────────────────────────────┐
  │ 1. 全アプリがハードウェアの詳細を知る必要  │
  │    → ディスクのセクタ番号を直接指定？       │
  │    → GPUのレジスタを直接操作？              │
  │                                            │
  │ 2. リソースの競合                           │
  │    → 2つのアプリが同時にプリンタを使いたい  │
  │    → メモリを好き勝手に使って他を破壊       │
  │                                            │
  │ 3. セキュリティなし                         │
  │    → どのアプリも全データにアクセス可能      │
  │    → 悪意あるプログラムがやりたい放題        │
  └──────────────────────────────────────────┘

OSの役割:
  ┌──────────────────────────────────────────┐
  │ アプリケーション（ブラウザ、エディタ等）    │
  ├──────────────────────────────────────────┤
  │ OS（カーネル）                             │
  │  ├─ プロセス管理:  CPUの時間を分配          │
  │  ├─ メモリ管理:    メモリを安全に分配        │
  │  ├─ ファイルシステム: データの永続化         │
  │  ├─ I/O管理:      デバイスへの統一API       │
  │  └─ セキュリティ:  アクセス制御             │
  ├──────────────────────────────────────────┤
  │ ハードウェア（CPU, メモリ, ディスク, NIC等） │
  └──────────────────────────────────────────┘

  OSの2つの顔:
  1. リソースマネージャー: CPU、メモリ、ディスク等を管理・分配
  2. 抽象化レイヤー: ハードウェアの複雑さを隠蔽し簡単なAPIを提供
```

### 1.1 OSの具体的な機能

```
OSが提供する主要機能の詳細:

  1. プロセス管理:
     ┌────────────────────────────────────────────────┐
     │ - プロセスの生成と終了                          │
     │ - CPUスケジューリング（どのプロセスをいつ実行）  │
     │ - プロセス間通信（パイプ、ソケット、共有メモリ） │
     │ - 同期と排他制御（mutex、セマフォ）              │
     │ - シグナル処理（SIGKILL, SIGTERM 等）           │
     │                                                 │
     │ 例: Chromeを起動すると                          │
     │   → OSが新しいプロセスを生成                    │
     │   → メモリ空間を割り当て                        │
     │   → CPUの時間スライスを配分                     │
     │   → 複数タブを別プロセスで隔離                  │
     └────────────────────────────────────────────────┘

  2. メモリ管理:
     ┌────────────────────────────────────────────────┐
     │ - 仮想メモリ: 物理メモリ以上のアドレス空間を提供│
     │ - ページング: メモリを4KBのページ単位で管理      │
     │ - メモリ保護: プロセス間のメモリ隔離             │
     │ - メモリマッピング: ファイルをメモリに直接対応付け│
     │ - スワップ: 使っていないページをディスクに退避   │
     │                                                 │
     │ 例: 8GBの物理メモリで複数アプリを動かす          │
     │   → 各プロセスが独自の仮想アドレス空間を持つ    │
     │   → 合計20GBのメモリ要求でも動作可能            │
     │   → 使われないページはディスクにスワップ         │
     └────────────────────────────────────────────────┘

  3. ファイルシステム:
     ┌────────────────────────────────────────────────┐
     │ - ファイルの作成、読み書き、削除                 │
     │ - ディレクトリ（フォルダ）の階層構造             │
     │ - アクセス権限の管理（owner, group, other）      │
     │ - ジャーナリング: 不意の電源断からデータを保護   │
     │ - マウント: 異なるストレージデバイスを統合       │
     │                                                 │
     │ 主要なファイルシステム:                          │
     │   ext4: Linux標準（ジャーナリング、最大1EB）     │
     │   APFS: macOS/iOS（CoW、暗号化、スナップショット）│
     │   NTFS: Windows（ACL、ジャーナリング、圧縮）     │
     │   Btrfs: Linux次世代（CoW、RAID、スナップショット）│
     │   ZFS: 企業向け（チェックサム、RAID-Z、圧縮）    │
     │   XFS: 大規模ファイル向け（高並列I/O）           │
     └────────────────────────────────────────────────┘

  4. I/O管理:
     ┌────────────────────────────────────────────────┐
     │ - デバイスドライバ: ハードウェアとの通信を抽象化 │
     │ - バッファリング: I/Oを効率化するためのバッファ  │
     │ - 割り込み処理: デバイスからの通知を処理         │
     │ - DMA（Direct Memory Access）: CPUを介さないデータ転送│
     │ - I/Oスケジューリング: ディスクアクセスの最適化  │
     │                                                 │
     │ デバイスドライバの役割:                          │
     │   アプリ → write() → VFS → ファイルシステム     │
     │                        → ブロック層              │
     │                        → デバイスドライバ        │
     │                        → ハードウェア(SSD/HDD)   │
     └────────────────────────────────────────────────┘

  5. ネットワーク管理:
     ┌────────────────────────────────────────────────┐
     │ - TCP/IPプロトコルスタックの実装                 │
     │ - ソケットAPI: アプリケーションのネットワーク通信 │
     │ - ファイアウォール: パケットフィルタリング       │
     │ - ルーティング: パケットの転送先決定             │
     │ - ネットワークデバイスドライバ                   │
     │                                                 │
     │ Linuxのネットワークスタック:                     │
     │   アプリ → socket() → TCP/UDP → IP → NIC Driver │
     │   → iptables/nftables でフィルタリング           │
     │   → tc (traffic control) で帯域制御              │
     └────────────────────────────────────────────────┘

  6. セキュリティ:
     ┌────────────────────────────────────────────────┐
     │ - ユーザー認証: ログイン、パスワード、生体認証  │
     │ - アクセス制御: ファイル権限、ケーパビリティ    │
     │ - 暗号化: ディスク暗号化、通信暗号化            │
     │ - 監査: セキュリティイベントのログ記録           │
     │ - サンドボックス: アプリの権限を制限             │
     │                                                 │
     │ Linuxのセキュリティモジュール:                   │
     │   SELinux: 強制アクセス制御（Red Hat系）         │
     │   AppArmor: パス名ベースのアクセス制御（Ubuntu） │
     │   seccomp: システムコールのフィルタリング        │
     │   namespaces + cgroups: コンテナ隔離の基盤       │
     └────────────────────────────────────────────────┘
```

### 1.2 OSがなかった時代の実際

```
OSなしのプログラミング（1950年代）:

  手順:
  1. パンチカードにプログラムを書く
  2. コンピュータ室に持参し、オペレータに渡す
  3. プログラムがマシンに投入される（数時間〜数日待ち）
  4. 結果が紙に印刷されて返却される
  5. バグがあれば1からやり直し

  問題点:
  - CPUの稼働率が極めて低い（プログラム投入中はアイドル）
  - プログラマが直接ハードウェアのアドレスを計算
  - I/Oデバイスのタイミングを手動で管理
  - エラーが発生するとマシン全体が停止

  OSの登場で解決されたこと:
  ┌────────────────────────────────────────────────┐
  │ バッチ処理OS（1950年代後半）:                   │
  │ → ジョブを自動で次々に実行                     │
  │ → CPUの稼働率が飛躍的に向上                    │
  │                                                 │
  │ マルチプログラミングOS（1960年代）:             │
  │ → 複数のジョブをメモリに同時に保持             │
  │ → I/O待ち中に別のジョブを実行                  │
  │                                                 │
  │ タイムシェアリングOS（1960年代後半）:           │
  │ → 複数ユーザーが端末から同時にアクセス         │
  │ → 「対話的な」コンピュータ利用が可能に         │
  └────────────────────────────────────────────────┘

現代でもOSなしの環境:
  - Arduino: 単一プログラムが直接ハードウェアを制御
  - ベアメタルプログラミング: 組み込み機器のファームウェア
  - ブートローダー: GRUB, U-Boot（OS起動前に動作）
  → OSなしだと得られるもの: 低レイテンシ、小フットプリント
  → 失うもの: マルチタスク、メモリ保護、抽象化
```

---

## 2. カーネルとユーザー空間

```
CPUの動作モード（x86の場合）:

  Ring 0（カーネルモード）:
  → 全ハードウェアに直接アクセス可能
  → 特権命令を実行可能
  → OSカーネルが動作

  Ring 3（ユーザーモード）:
  → ハードウェアに直接アクセス不可
  → 特権命令は例外（トラップ）が発生
  → 一般アプリケーションが動作

  ┌───────────────────────────────────────┐
  │  ユーザー空間（Ring 3）                │
  │  ┌──────┐ ┌──────┐ ┌──────┐          │
  │  │Chrome│ │VSCode│ │Slack │ ...       │
  │  └──┬───┘ └──┬───┘ └──┬───┘          │
  │     │        │        │               │
  │═════╪════════╪════════╪═══════════════│
  │     │  システムコール（境界）           │
  │═════╪════════╪════════╪═══════════════│
  │  カーネル空間（Ring 0）                │
  │  ┌──────────────────────────────┐     │
  │  │ プロセス管理 │ メモリ管理    │     │
  │  │ ファイルシステム│ ネットワーク │     │
  │  │ デバイスドライバ               │     │
  │  └──────────────────────────────┘     │
  │  ハードウェア                          │
  └───────────────────────────────────────┘

  Ring 1, 2:
  → x86には4つのリングがあるが、ほとんどのOSは
    Ring 0（カーネル）とRing 3（ユーザー）のみ使用
  → VMX root/non-rootモード: 仮想化のための追加モード（VT-x）
```

### 2.1 システムコール（syscall）の詳細

```
システムコール（syscall）:
  ユーザー空間からカーネルの機能を呼び出す唯一の窓口

  システムコールの呼び出し手順:
  ┌───────────────────────────────────────────────────┐
  │ 1. アプリケーションがライブラリ関数を呼ぶ          │
  │    例: write(fd, buf, count)                       │
  │                                                    │
  │ 2. Cライブラリ（glibc）がsyscall番号をレジスタに   │
  │    設定し、syscall/int 0x80命令を実行               │
  │                                                    │
  │ 3. CPUがカーネルモードに切り替え                    │
  │    → Ring 3 → Ring 0                               │
  │    → スタックもカーネルスタックに切替               │
  │                                                    │
  │ 4. カーネルがsyscallハンドラを実行                  │
  │    → sys_write() 等のカーネル関数                   │
  │                                                    │
  │ 5. 結果をレジスタに格納し、ユーザーモードに復帰    │
  │    → Ring 0 → Ring 3                               │
  └───────────────────────────────────────────────────┘

  主要なシステムコール（Linux）:

  プロセス管理:
  ┌──────────────────────────────────────────────────────┐
  │ fork()      → 現在のプロセスをコピーして子プロセス作成│
  │ exec()      → 現在のプロセスを別のプログラムに置換    │
  │ wait()      → 子プロセスの終了を待つ                  │
  │ exit()      → プロセスを終了                          │
  │ getpid()    → プロセスIDを取得                        │
  │ kill()      → プロセスにシグナルを送信                │
  │ clone()     → スレッドの生成（Linux固有）             │
  └──────────────────────────────────────────────────────┘

  ファイル操作:
  ┌──────────────────────────────────────────────────────┐
  │ open()      → ファイルを開く                          │
  │ read()      → ファイルから読む                        │
  │ write()     → ファイルに書く                          │
  │ close()     → ファイルを閉じる                        │
  │ lseek()     → ファイルポジションを移動                │
  │ stat()      → ファイル情報を取得                      │
  │ mkdir()     → ディレクトリを作成                      │
  │ unlink()    → ファイルを削除                          │
  └──────────────────────────────────────────────────────┘

  メモリ管理:
  ┌──────────────────────────────────────────────────────┐
  │ mmap()      → メモリをマッピング                      │
  │ munmap()    → マッピングを解除                        │
  │ brk()       → ヒープのサイズを変更                    │
  │ mprotect()  → メモリの保護属性を変更                  │
  │ mlock()     → メモリページをロック（スワップアウト防止）│
  └──────────────────────────────────────────────────────┘

  ネットワーク:
  ┌──────────────────────────────────────────────────────┐
  │ socket()    → ソケットを作成                          │
  │ bind()      → ソケットにアドレスをバインド            │
  │ listen()    → 接続要求の待受を開始                    │
  │ accept()    → 接続を受け入れ                          │
  │ connect()   → サーバーに接続                          │
  │ send()      → データを送信                            │
  │ recv()      → データを受信                            │
  └──────────────────────────────────────────────────────┘

  コスト:
  ユーザーモード → カーネルモードの切替は高コスト（数千サイクル）
  → システムコールの回数を減らすことがパフォーマンスの鍵

  高速化技術:
  ┌──────────────────────────────────────────────────────┐
  │ vDSO (virtual Dynamic Shared Object):                │
  │ → カーネルが提供する仮想共有ライブラリ               │
  │ → gettimeofday() 等をユーザー空間で実行              │
  │ → syscallのオーバーヘッドを完全に回避                │
  │                                                      │
  │ io_uring (Linux 5.1+):                               │
  │ → 非同期I/Oの新しいインターフェース                  │
  │ → リングバッファでカーネルと共有                      │
  │ → syscall回数を劇的に削減                            │
  │ → 高性能Webサーバーやデータベースで採用              │
  │                                                      │
  │ VDSO + io_uring の効果:                              │
  │ 従来: read() → syscall → カーネル → 結果返却        │
  │ io_uring: SQE投入 → カーネルが非同期処理 → CQE取得  │
  │ → 1回のsyscallで複数のI/O操作をまとめて実行         │
  └──────────────────────────────────────────────────────┘
```

### 2.2 システムコールの実際の追跡

```bash
# straceでシステムコールを観察（Linux）
# "hello"を出力する際のsyscallを観察

$ strace echo "hello"
execve("/usr/bin/echo", ["echo", "hello"], ...) = 0
brk(NULL)                               = 0x55a123456000
access("/etc/ld.so.preload", R_OK)      = -1 ENOENT
openat(AT_FDCWD, "/etc/ld.so.cache", O_RDONLY|O_CLOEXEC) = 3
fstat(3, {st_mode=S_IFREG|0644, ...})   = 0
mmap(NULL, 76888, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7f1234567000
close(3)                                = 0
# ... (共有ライブラリのロード)
write(1, "hello\n", 6)                  = 6
close(1)                                = 0
close(2)                                = 0
exit_group(0)                           = ?
```

```c
// C言語でシステムコールを直接呼び出す例

#include <unistd.h>
#include <sys/syscall.h>
#include <fcntl.h>
#include <stdio.h>

int main() {
    // 方法1: ライブラリ関数経由（通常）
    int fd = open("test.txt", O_RDONLY);

    // 方法2: syscall() で直接呼び出し
    int fd2 = syscall(SYS_openat, AT_FDCWD, "test.txt", O_RDONLY);

    // 方法3: インラインアセンブリ（x86_64）
    // 通常は使わないが、仕組みの理解に有用
    long result;
    char *msg = "Hello from syscall!\n";
    __asm__ volatile (
        "mov $1, %%rax\n"    // syscall番号: write = 1
        "mov $1, %%rdi\n"    // fd: stdout = 1
        "mov %1, %%rsi\n"    // バッファ
        "mov $20, %%rdx\n"   // サイズ
        "syscall\n"          // syscall命令
        "mov %%rax, %0\n"
        : "=r" (result)
        : "r" (msg)
        : "rax", "rdi", "rsi", "rdx"
    );

    printf("syscall returned: %ld\n", result);
    return 0;
}
```

```python
# Pythonでシステムコールの挙動を確認
import os
import sys

# ファイルディスクリプタの確認
print(f"stdin:  fd={sys.stdin.fileno()}")    # 0
print(f"stdout: fd={sys.stdout.fileno()}")   # 1
print(f"stderr: fd={sys.stderr.fileno()}")   # 2

# os.open() は内部でopen() syscallを呼ぶ
fd = os.open("test.txt", os.O_CREAT | os.O_WRONLY, 0o644)
os.write(fd, b"Hello from Python syscall!\n")
os.close(fd)

# /proc/self/syscall で現在のsyscallを確認（Linux）
# /proc/self/fd でオープンしているファイルを確認
try:
    fds = os.listdir("/proc/self/fd")
    print(f"Open file descriptors: {fds}")
except FileNotFoundError:
    print("Not running on Linux")

# プロセス情報の取得
print(f"PID: {os.getpid()}")
print(f"PPID: {os.getppid()}")
print(f"UID: {os.getuid()}")
print(f"GID: {os.getgid()}")
```

---

## 3. カーネルアーキテクチャ

```
1. モノリシックカーネル:
   全OS機能が1つの巨大なバイナリ

   ┌──────────────────────────────────┐
   │ カーネル空間                      │
   │ ┌────┬────┬────┬────┬────┐       │
   │ │プロ│メモ│FS  │Net │ドラ│       │
   │ │セス│リ  │    │    │イバ│       │
   │ └────┴────┴────┴────┴────┘       │
   │ 全てが同一アドレス空間で動作       │
   └──────────────────────────────────┘

   利点: 高速（関数呼び出しで済む）
   欠点: 1つのバグで全体がクラッシュ、巨大化
   例: Linux, FreeBSD

   Linuxカーネルの規模:
   ┌──────────────────────────────────────────┐
   │ ソースコード: 約3,000万行（2025年時点）   │
   │ コミッター: 数千人                        │
   │ サポートアーキテクチャ: 30以上            │
   │ デバイスドライバ: カーネルの60%以上を占める│
   │ リリースサイクル: 約9-10週ごと            │
   └──────────────────────────────────────────┘

   Linuxの動的モジュール:
   → モノリシックだが、モジュールを動的にロード/アンロード可能
   → デバイスドライバ等を必要に応じてカーネルに追加
   → lsmod, modprobe, rmmod で管理
   → /lib/modules/<kernel-version>/ に格納

2. マイクロカーネル:
   最小限の機能のみカーネルに、残りはユーザー空間

   ┌──────────────────────────────────┐
   │ ユーザー空間                      │
   │ ┌────┐ ┌────┐ ┌────┐ ┌────┐    │
   │ │FS  │ │Net │ │ドラ│ │アプ│    │
   │ │サーバ││サーバ││イバ│ │リ  │    │
   │ └──┬─┘ └──┬─┘ └──┬─┘ └──┬─┘    │
   │────│──────│──────│──────│───── │
   │ カーネル: IPC + スケジューリング   │
   │           + メモリ管理（最小限）   │
   └──────────────────────────────────┘

   利点: 安定性（サーバーが落ちてもカーネルは生存）
   欠点: IPC（プロセス間通信）のオーバーヘッド
   例: MINIX, QNX, seL4, GNU Hurd

   seL4の特徴:
   ┌──────────────────────────────────────────────┐
   │ - 世界初の形式検証されたOSカーネル            │
   │ - 約8,700行のCコード + 600行のアセンブリ      │
   │ - 数学的に正しさが証明されている              │
   │ - 安全保障、航空、自動車分野で採用            │
   │ - 実行時エラーが発生しないことが保証されている│
   └──────────────────────────────────────────────┘

3. ハイブリッドカーネル:
   モノリシックの性能 + マイクロカーネルの設計思想

   例: Windows NT, macOS (XNU), DragonFly BSD
   → 実質的にはモノリシックに近い実装が多い

   macOS XNUカーネル:
   ┌──────────────────────────────────────────────────┐
   │ XNU = "X is Not Unix"                             │
   │                                                    │
   │ Mach マイクロカーネル（メッセージパッシング、VM）  │
   │ + BSD（POSIX API、VFS、ネットワーク）              │
   │ + I/O Kit（オブジェクト指向デバイスドライバ）       │
   │                                                    │
   │ → Machの設計思想 + BSDの実用性 = ハイブリッド     │
   │ → オープンソース（darwin-xnu）                     │
   └──────────────────────────────────────────────────┘

   Windows NTカーネル:
   ┌──────────────────────────────────────────────────┐
   │ HAL（Hardware Abstraction Layer）                  │
   │ + マイクロカーネル（スケジューラ、割り込み処理）   │
   │ + エグゼクティブ（I/O、VM、プロセス管理）          │
   │ + Win32サブシステム（GUI、API）                     │
   │ + WSL2サブシステム（Linux互換）                     │
   │                                                    │
   │ → Dave Cutler (VMS設計者) が設計                   │
   │ → 初期はマイクロカーネル志向だったが               │
   │   パフォーマンスのため機能をカーネルに取り込んだ   │
   └──────────────────────────────────────────────────┘

4. Unikernel:
   アプリ+必要なOS機能のみを1つのイメージにパック

   ┌──────────────────┐
   │ アプリ + OS機能   │  ← 1つのバイナリ
   └──────────────────┘

   利点: 極小サイズ、高速起動、攻撃面が最小
   欠点: シングルアプリ、デバッグ困難
   例: MirageOS, Unikraft, OSv

   ユースケース:
   - クラウドのマイクロサービス（最小フットプリント）
   - NFV（ネットワーク機能仮想化）
   - CDNエッジノード
   - IoTデバイス

5. Exokernel:
   カーネルはリソース保護のみ、管理はアプリに委任

   ┌──────────────────────────────────┐
   │ アプリ + LibOS（FS, Net等を実装）│
   │ ────────────────────────────     │
   │ Exokernel: リソース割当と保護のみ│
   └──────────────────────────────────┘

   → アプリがOS機能をカスタマイズ可能
   → 研究段階だが、コンテナやUnikernelに影響

比較:
┌──────────────┬──────────┬──────────┬──────────┬───────────┐
│ 種類         │ 性能     │ 安定性   │ 採用例   │ コード量  │
├──────────────┼──────────┼──────────┼──────────┼───────────┤
│ モノリシック  │ ◎       │ △       │ Linux    │ 数千万行  │
│ マイクロ     │ △       │ ◎       │ QNX      │ 数万行    │
│ ハイブリッド │ ○       │ ○       │ Windows  │ 数百万行  │
│ Unikernel   │ ◎       │ ○       │ クラウド  │ 数千行    │
│ Exokernel   │ ◎       │ △       │ 研究     │ 数千行    │
└──────────────┴──────────┴──────────┴──────────┴───────────┘
```

---

## 4. 主要なOSファミリー

```
Unix系:
  1969: Unix (AT&T Bell Labs — Thompson, Ritchie)
    ├── BSD系: FreeBSD, OpenBSD, NetBSD
    │   └── macOS / iOS (Darwin = Mach + FreeBSD)
    ├── System V系
    │   └── Solaris, AIX, HP-UX
    └── Linux (1991, Linus Torvalds)
        ├── Debian系: Ubuntu, Linux Mint, Raspberry Pi OS
        ├── Red Hat系: RHEL, CentOS Stream, Fedora, Rocky, AlmaLinux
        ├── Arch系: Arch Linux, Manjaro, EndeavourOS
        ├── SUSE系: openSUSE, SLES
        ├── Android (Linux カーネル + Dalvik/ART)
        ├── Chrome OS (Linux カーネル + Chrome ブラウザ)
        └── SteamOS (Linux カーネル + Steam)

Windows系:
  MS-DOS (1981)
    └── Windows 3.1 → 95 → 98 → Me（DOS ベース）
  Windows NT (1993)
    └── NT → 2000 → XP → Vista → 7 → 8 → 10 → 11

その他:
  z/OS: IBM メインフレーム（COBOL資産が稼働）
  VxWorks: 組み込みリアルタイムOS（火星探査機にも搭載）
  FreeRTOS: IoT向け軽量RTOS（AWS が管理）
  Zephyr: IoT向けRTOS（Linux Foundation）
  Fuchsia: Google の次世代OS（Zircon マイクロカーネル）
  HarmonyOS: Huawei のOS（マイクロカーネル）
  Redox: Rustで書かれたマイクロカーネルOS

現在のシェア（2025年概算）:
  デスクトップ: Windows 72%, macOS 16%, Linux 4%, Chrome OS 3%
  サーバー:     Linux 80%+, Windows 15%
  モバイル:     Android 72%, iOS 27%
  スーパーコンピュータ: Linux 100% (TOP500)
  組み込み/IoT: FreeRTOS, Linux, VxWorks, Zephyr が主要
  コンテナ:     Linux 99%+（Docker/K8sはLinuxカーネルに依存）
```

### 4.1 Linuxディストリビューションの選び方

```
用途別の推奨ディストリビューション:

  サーバー用途:
  ┌────────────────────────────────────────────────┐
  │ RHEL/Rocky Linux: エンタープライズ、長期サポート│
  │ Ubuntu Server: クラウド、初心者にも扱いやすい  │
  │ Debian: 安定重視、サーバー定番                 │
  │ Amazon Linux: AWSに最適化                      │
  │ Alpine Linux: コンテナ向け（軽量、5MB以下）    │
  └────────────────────────────────────────────────┘

  デスクトップ用途:
  ┌────────────────────────────────────────────────┐
  │ Ubuntu Desktop: 初心者向け、情報が豊富         │
  │ Fedora: 最新技術、GNOME                        │
  │ Linux Mint: Windows からの移行に最適           │
  │ Arch Linux: カスタマイズ重視、上級者向け       │
  │ Pop!_OS: 開発者向け、NVIDIA GPU対応            │
  └────────────────────────────────────────────────┘

  パッケージ管理の比較:
  ┌───────────┬──────────┬──────────────────────┐
  │ 系統      │ ツール   │ コマンド例            │
  ├───────────┼──────────┼──────────────────────┤
  │ Debian系  │ apt      │ apt install nginx    │
  │ Red Hat系 │ dnf/yum  │ dnf install nginx    │
  │ Arch系   │ pacman   │ pacman -S nginx      │
  │ SUSE系   │ zypper   │ zypper install nginx │
  │ Alpine   │ apk      │ apk add nginx        │
  │ 汎用     │ snap     │ snap install firefox │
  │ 汎用     │ flatpak  │ flatpak install ...  │
  └───────────┴──────────┴──────────────────────┘
```

---

## 5. OSの抽象化

```
OSが提供する主要な抽象化:

  物理リソース    →    OS抽象化
  ────────────────────────────────
  CPU             →    プロセス/スレッド
  物理メモリ      →    仮想アドレス空間
  ディスクセクタ  →    ファイル/ディレクトリ
  ネットワーク    →    ソケット
  ディスプレイ    →    ウィンドウ
  タイマー        →    時刻API

  抽象化のメリット:
  ┌──────────────────────────────────────────────────┐
  │ 1. 移植性: 同じプログラムが異なるハードウェアで動く│
  │ 2. 簡潔性: 複雑な操作を簡単なAPIで呼べる         │
  │ 3. 隔離性: プロセス間の干渉を防止                 │
  │ 4. 効率性: リソースを自動で最適に配分             │
  │ 5. セキュリティ: アクセス制御を強制               │
  └──────────────────────────────────────────────────┘

  「Everything is a file」（Unix哲学）:
  /dev/sda        → ディスク
  /dev/null       → 捨て場
  /proc/cpuinfo   → CPU情報
  /dev/urandom    → 乱数
  /dev/tty        → 端末
  /sys/class/net/ → ネットワークインターフェース情報
  /dev/video0     → Webカメラ
  → 全てをファイルとして統一的に扱える
  → read/write/open/close の4つの操作で統一

  Linuxの仮想ファイルシステム:
  ┌──────────────────────────────────────────────────┐
  │ /proc:                                           │
  │   /proc/<pid>/status    → プロセスの状態          │
  │   /proc/<pid>/maps      → メモリマッピング        │
  │   /proc/<pid>/fd/       → オープンファイル        │
  │   /proc/meminfo         → メモリ使用状況          │
  │   /proc/cpuinfo         → CPU情報                │
  │   /proc/loadavg         → ロードアベレージ        │
  │   /proc/net/tcp         → TCP接続情報             │
  │                                                   │
  │ /sys:                                             │
  │   /sys/class/           → デバイスクラス          │
  │   /sys/block/           → ブロックデバイス        │
  │   /sys/fs/              → ファイルシステム情報    │
  │   /sys/kernel/          → カーネルパラメータ      │
  │                                                   │
  │ /dev:                                             │
  │   /dev/sd*              → SCSIディスク            │
  │   /dev/nvme*            → NVMeデバイス            │
  │   /dev/tty*             → 端末デバイス            │
  │   /dev/loop*            → ループバックデバイス    │
  └──────────────────────────────────────────────────┘

  POSIX（Portable Operating System Interface）:
  Unix系OSの標準API仕様
  → POSIXに準拠したプログラムは移植性が高い
  → Linux, macOS, BSD は概ねPOSIX準拠
  → Windows はWSL2でLinux互換環境を提供

  POSIXが定義するもの:
  ┌──────────────────────────────────────────┐
  │ - システムコールインターフェース          │
  │ - 基本コマンド（ls, grep, awk等）       │
  │ - シェル言語（sh）                       │
  │ - スレッドAPI（pthread）                 │
  │ - 正規表現                               │
  │ - ファイル権限モデル                     │
  │ - シグナル処理                           │
  └──────────────────────────────────────────┘
```

### 5.1 Unix哲学の実践

```
Unix哲学の核心（Doug McIlroy）:

  1. 「1つのことをうまくやるプログラムを書け」
  2. 「プログラムの出力が別のプログラムの入力になるようにせよ」
  3. 「ソフトウェアは早く試作し、拙い部分は捨てて作り直せ」

  パイプの威力:
  ┌──────────────────────────────────────────────────────┐
  │ # アクセスログから、IPアドレスごとのリクエスト数を集計│
  │ cat access.log | awk '{print $1}' | sort | uniq -c | sort -rn | head -10│
  │                                                      │
  │ 各コマンドの役割:                                    │
  │ cat: ファイル内容を出力                              │
  │ awk: 1番目のフィールド（IPアドレス）を抽出          │
  │ sort: ソート                                        │
  │ uniq -c: 重複をカウント                             │
  │ sort -rn: 数値で逆順ソート                          │
  │ head -10: 上位10件を表示                            │
  │                                                      │
  │ → 6つの小さなプログラムの組み合わせで               │
  │   複雑なログ分析が実現できる                        │
  └──────────────────────────────────────────────────────┘

  Plan 9（Unixの後継研究OS）の革新:
  → 「全てがファイル」をネットワークまで拡張
  → /net/tcp でネットワーク接続をファイル操作
  → /proc でプロセスをファイル操作
  → 9P プロトコルでリモートリソースをマウント
  → この思想がLinuxの /proc, /sys に継承された
```

---

## 6. OSとコンテナ・仮想化

```
現代のOS機能: コンテナ技術

  コンテナの基盤となるLinuxカーネル機能:

  1. Namespace（名前空間）:
     リソースの可視性を隔離
     ┌──────────────────────────────────────────┐
     │ PID namespace:   プロセスIDの隔離         │
     │ Network namespace: ネットワークの隔離      │
     │ Mount namespace:  ファイルシステムの隔離   │
     │ UTS namespace:    ホスト名の隔離           │
     │ User namespace:   UID/GIDの隔離            │
     │ IPC namespace:    プロセス間通信の隔離     │
     │ Cgroup namespace: cgroupの隔離             │
     │ Time namespace:   時刻の隔離（Linux 5.6+）│
     └──────────────────────────────────────────┘

  2. Cgroups（Control Groups）:
     リソース使用量の制限
     ┌──────────────────────────────────────────┐
     │ CPU: 使用率の上限を設定                   │
     │ Memory: メモリ使用量の上限                 │
     │ I/O: ディスクI/Oの帯域制限               │
     │ PID: プロセス数の上限                     │
     │ → Dockerコンテナのリソース制限に使われる  │
     └──────────────────────────────────────────┘

  3. Union FS（OverlayFS等）:
     レイヤーベースのファイルシステム
     ┌──────────────────────────────────────────┐
     │ 読み書き層（コンテナ固有）               │
     │ ──────────────────────                   │
     │ 読み取り専用層3（アプリ）                │
     │ ──────────────────────                   │
     │ 読み取り専用層2（ライブラリ）            │
     │ ──────────────────────                   │
     │ 読み取り専用層1（ベースOS）              │
     │ → Docker イメージのレイヤー構造           │
     └──────────────────────────────────────────┘

  仮想マシン vs コンテナ:
  ┌─────────────────┬──────────────────────────────┐
  │ 仮想マシン       │ コンテナ                      │
  ├─────────────────┼──────────────────────────────┤
  │ ゲストOS全体    │ ホストOSのカーネルを共有      │
  │ 起動: 数十秒〜  │ 起動: ミリ秒〜数秒            │
  │ サイズ: GB      │ サイズ: MB                     │
  │ オーバーヘッド大 │ オーバーヘッド小              │
  │ 隔離性: 強      │ 隔離性: 中（カーネル共有）    │
  │ 用途: 異なるOS  │ 用途: 同一OS上のアプリ隔離    │
  └─────────────────┴──────────────────────────────┘
```

```bash
# コンテナの原理を手動で体験（Linux）

# 1. 新しいnamespaceでプロセスを起動
sudo unshare --pid --fork --mount-proc /bin/bash

# 2. ps を実行すると、自プロセスしか見えない
ps aux
# PID 1 が bash になっている（隔離されている）

# 3. cgroupでメモリ制限を設定
sudo mkdir /sys/fs/cgroup/memory/mycontainer
echo 100M > /sys/fs/cgroup/memory/mycontainer/memory.limit_in_bytes
echo $$ > /sys/fs/cgroup/memory/mycontainer/cgroup.procs

# 4. ネットワークnamespaceの作成
sudo ip netns add testns
sudo ip netns exec testns ip addr
# → ループバックインターフェースのみの隔離されたネットワーク
```

---

## 実践演習

### 演習1: [基礎] -- システムコールの追跡

```bash
# straceでシステムコールを観察（Linux）
strace ls /tmp 2>&1 | head -30

# macOS の場合は dtruss
sudo dtruss ls /tmp 2>&1 | head -30

# 観察ポイント:
# 1. execve() → プログラムの起動
# 2. openat() → ファイルを開く
# 3. getdents() → ディレクトリエントリを読む
# 4. write() → 結果を出力
# 5. close() → ファイルを閉じる

# 課題: 以下のコマンドのsyscallを比較せよ
# - echo "hello" vs printf "hello"
# - cat file vs less file

# 発展課題: syscallの統計を取る
strace -c ls /tmp 2>&1
# → 各syscallの呼び出し回数、所要時間を集計

# 特定のsyscallだけをフィルタリング
strace -e trace=open,read,write cat /etc/passwd 2>&1
```

### 演習2: [応用] -- カーネルモジュール概念

```bash
# Linuxカーネルモジュールの確認

# 現在ロードされているモジュールの一覧
lsmod

# 特定のモジュールの情報
modinfo ext4

# モジュールの依存関係
modprobe --show-depends usb_storage

# /proc/modules と lsmod の関係
cat /proc/modules | head -10
# → lsmod は /proc/modules を整形して表示しているだけ
```

```c
// 最小のLinuxカーネルモジュール（教育用）
// ファイル名: hello_module.c

#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Student");
MODULE_DESCRIPTION("Hello World Kernel Module");

static int __init hello_init(void) {
    printk(KERN_INFO "Hello from kernel module!\n");
    return 0;
}

static void __exit hello_exit(void) {
    printk(KERN_INFO "Goodbye from kernel module!\n");
}

module_init(hello_init);
module_exit(hello_exit);

// Makefile:
// obj-m += hello_module.o
// all:
//     make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules
// clean:
//     make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean

// ビルドとロード:
// make
// sudo insmod hello_module.ko
// dmesg | tail  → "Hello from kernel module!"
// sudo rmmod hello_module
// dmesg | tail  → "Goodbye from kernel module!"
```

### 演習3: [発展] -- OS設計の比較

```
以下の要件に最適なOSアーキテクチャを選択し、理由を述べよ:

1. 自動車の制御システム（ブレーキ、ステアリング）
   → ヒント: リアルタイム性、安全性、認証が重要
   → QNX (マイクロカーネル) or seL4 (形式検証済み)

2. Webサーバー（大量リクエスト処理）
   → ヒント: 性能、エコシステム、運用性が重要
   → Linux (モノリシック) + io_uring

3. IoTセンサーデバイス（バッテリー駆動、最小リソース）
   → ヒント: フットプリント、消費電力が重要
   → FreeRTOS or Zephyr

4. クラウドのFaaS（Function as a Service）基盤
   → ヒント: 起動速度、隔離、効率が重要
   → Unikernel or Firecracker (microVM)

各ケースで「モノリシック / マイクロ / Unikernel」の
どれが適切か、パフォーマンス・安全性・開発コストの観点で議論せよ

評価観点の例:
┌──────────────────────┬──────────┬──────────┬──────────┐
│ 観点                 │ ケース1  │ ケース2  │ ケース3  │
├──────────────────────┼──────────┼──────────┼──────────┤
│ パフォーマンス       │          │          │          │
│ 安全性・信頼性      │          │          │          │
│ 開発コスト          │          │          │          │
│ 保守性              │          │          │          │
│ 起動速度            │          │          │          │
│ メモリフットプリント│          │          │          │
│ 認証取得の容易さ    │          │          │          │
└──────────────────────┴──────────┴──────────┴──────────┘
```

### 演習4: [発展] -- OSの内部を探索する

```bash
# Linuxの内部状態を探索

# 1. CPU情報
cat /proc/cpuinfo | grep "model name" | head -1
nproc  # CPUコア数

# 2. メモリ情報
free -h
cat /proc/meminfo | head -10

# 3. プロセス情報
ps aux --sort=-%mem | head -10  # メモリ使用量トップ10
ps aux --sort=-%cpu | head -10  # CPU使用量トップ10

# 4. ファイルシステム情報
df -h            # ディスク使用量
mount | head -20 # マウント情報

# 5. ネットワーク情報
ss -tlnp        # リスニングポート（Linux）
# netstat -tlnp  # 旧コマンド

# 6. カーネル情報
uname -a         # カーネルバージョン
cat /proc/version

# 7. システムのブート時間
uptime
who -b

# 課題: 上記の情報を収集するスクリプトを作成し、
#       「サーバー健康診断レポート」を生成せよ
```

---

## FAQ

### Q1: LinuxはUnixなのか？

厳密には「Unixではない」。LinuxはUnixのソースコードを使わずにゼロから書かれた「Unix互換」のOS。AT&TのUnixライセンスは不要。ただしPOSIX互換であり、Unix哲学を踏襲しているため「Unix系（Unix-like）」と呼ばれる。正式なUNIX認証（Single UNIX Specification準拠）を取得しているのはmacOS、Solaris、AIX等で、LinuxはUNIX認証を取得していない（申請していない）。

### Q2: カーネルとOSの違いは？

カーネルはOSの中核部分（ハードウェア管理、プロセス管理等）。OSはカーネル+シェル+ユーティリティ+ライブラリの総称。Linuxは厳密にはカーネル名で、Ubuntu等のディストリビューション全体がOS。GNU/Linuxという呼称は、GNUプロジェクトのユーティリティ群（gcc, coreutils, bash等）とLinuxカーネルを組み合わせたものという意味。

### Q3: なぜサーバーはLinuxが圧倒的か？

1. 無料（ライセンスコストゼロ）
2. オープンソース（カスタマイズ自由）
3. 安定性（数年間の無停止運用が可能）
4. コマンドライン中心（リモート管理に最適）
5. コミュニティとエコシステムの充実
6. コンテナ技術（Docker/K8s）がLinux前提
7. クラウドプロバイダ（AWS, GCP, Azure）がLinuxを標準提供
8. 軽量（GUI不要でサーバーリソースを最大活用）

### Q4: リアルタイムOSとは何か？

リアルタイムOS（RTOS）は、決められた時間以内に確実に処理を完了することを保証するOS。ハードリアルタイム（締め切り厳守: 医療機器、自動車制御）とソフトリアルタイム（ベストエフォート: マルチメディア再生）がある。Linux自体は汎用OSだが、PREEMPT_RTパッチを適用することでソフトリアルタイム性能を得られる。

### Q5: WSL2はどのような仕組みか？

WSL2（Windows Subsystem for Linux 2）は、Windows上で完全なLinuxカーネルを動かす仕組み。Hyper-V仮想化技術を使って軽量なLinux VMを起動し、Windowsとのシームレスな統合（ファイル共有、ネットワーク共有、GPU共有）を提供する。従来のWSL1（syscall変換方式）と異なり、完全なLinuxカーネルが動作するためすべてのLinuxプログラムが動作する。

### Q6: OSを自作するにはどこから始めるべきか？

1. **OS理論の学習**: 「Operating Systems: Three Easy Pieces」（無料オンライン教科書）
2. **xv6**: MITの教育用OS（Unixのシンプルな実装、x86/RISC-V対応）
3. **OSDev Wiki**: OS開発のコミュニティリソース
4. **Writing an OS in Rust**: Philipp Oppermann のブログシリーズ
5. **30日でできる！OS自作入門**: 川合秀実著（日本語、x86）

---

## まとめ

| 概念 | ポイント |
|------|---------|
| OSの役割 | リソース管理 + ハードウェア抽象化 |
| カーネル | Ring 0で動作。全ハードウェアにアクセス可能 |
| システムコール | ユーザー空間→カーネルの唯一の窓口。数千サイクルのコスト |
| アーキテクチャ | モノリシック(Linux) vs マイクロ(QNX) vs ハイブリッド(Windows) |
| Unix哲学 | Everything is a file。小さなツールを組み合わせる |
| POSIX | Unix系OSの標準API仕様。移植性の鍵 |
| コンテナ | Namespace + Cgroups + Union FS で実現 |
| 仮想化 | VM（完全隔離）vs コンテナ（軽量隔離） |

---

## 次に読むべきガイド
→ [[01-os-history.md]] -- OSの歴史と進化

---

## 参考文献
1. Silberschatz, A. et al. "Operating System Concepts." 10th Ed, Wiley, 2018.
2. Tanenbaum, A. "Modern Operating Systems." 4th Ed, Pearson, 2014.
3. Arpaci-Dusseau, R. & A. "Operating Systems: Three Easy Pieces." 2018.
4. Love, R. "Linux Kernel Development." 3rd Ed, Addison-Wesley, 2010.
5. Kerrisk, M. "The Linux Programming Interface." No Starch Press, 2010.
6. McKusick, M. et al. "The Design and Implementation of the FreeBSD Operating System." 2nd Ed, 2014.
7. Russinovich, M. et al. "Windows Internals." 7th Ed, Microsoft Press, 2017.
8. Klein, G. et al. "seL4: Formal Verification of an OS Kernel." SOSP, 2009.
