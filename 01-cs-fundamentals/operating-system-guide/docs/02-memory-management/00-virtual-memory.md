# 仮想メモリ

> 仮想メモリは「物理メモリの限界を超え、各プロセスに独立した広大なアドレス空間を提供する」OSの最も重要な抽象化の一つ。

## この章で学ぶこと

- [ ] 仮想メモリの必要性と仕組みを理解する
- [ ] アドレス変換（MMU、ページテーブル）を説明できる
- [ ] TLBの役割を知る

---

## 1. なぜ仮想メモリが必要か

```
仮想メモリがない世界の問題:

  1. メモリ不足: 物理メモリ以上のプログラムを実行できない
  2. 断片化: メモリの空き領域がバラバラになる
  3. 保護なし: プロセスAがプロセスBのメモリを破壊できる
  4. 再配置: プログラムのロードアドレスが固定

仮想メモリの解決策:
  各プロセスに独立した仮想アドレス空間を提供
  → 物理メモリの配置を意識する必要なし

  Process A           Process B
  ┌──────────┐       ┌──────────┐
  │仮想アドレス│       │仮想アドレス│
  │0x0000    │       │0x0000    │  ← 同じアドレスだが
  │  :       │       │  :       │    別の物理メモリ
  │0xFFFF    │       │0xFFFF    │
  └────┬─────┘       └────┬─────┘
       │ MMU             │ MMU
       ↓                  ↓
  ┌──────────────────────────────┐
  │     物理メモリ（RAM）          │
  │ [A's data][B's data][空き]    │
  └──────────────────────────────┘
       ↕ スワップ
  ┌──────────────────────────────┐
  │     ディスク（スワップ領域）   │
  └──────────────────────────────┘

  3つの重要な機能:
  1. アドレス変換: 仮想 → 物理のマッピング
  2. メモリ保護: プロセス間の分離
  3. デマンドページング: 必要な時だけ物理メモリに読み込む
```

---

## 2. ページングの仕組み

```
ページング:
  仮想/物理メモリを固定サイズの「ページ」に分割

  一般的なページサイズ: 4KB（x86, ARM）
  ラージページ: 2MB, 1GB（パフォーマンス最適化）

  仮想アドレス → 物理アドレスの変換:

  仮想アドレス（例: 32bit）:
  ┌──────────────┬───────────┐
  │ ページ番号    │ オフセット │
  │ (20bit)      │ (12bit)   │
  └──────┬───────┴─────┬─────┘
         │              │
         ↓              │
  ┌──────────────┐      │
  │ ページテーブル │      │
  │ [0] → フレーム5│     │
  │ [1] → フレーム2│     │
  │ [2] → ディスク │     │ ← ページフォルト
  │ [3] → フレーム8│     │
  └──────┬───────┘      │
         │              │
         ↓              ↓
  ┌──────────────┬───────────┐
  │ フレーム番号  │ オフセット │
  └──────────────┴───────────┘
  = 物理アドレス

ページテーブルエントリ（PTE）:
  ┌──────────────────────────────────┐
  │ フレーム番号 | フラグ              │
  │              | Present(存在)      │
  │              | Read/Write(権限)   │
  │              | User/Supervisor    │
  │              | Dirty(変更済み)    │
  │              | Accessed(参照済み) │
  └──────────────────────────────────┘

多階層ページテーブル（x86-64: 4階層）:

  仮想アドレス(48bit):
  ┌─────┬─────┬─────┬─────┬────────────┐
  │PML4 │PDPT │ PD  │ PT  │ Offset     │
  │(9)  │(9)  │(9)  │(9)  │(12)        │
  └──┬──┴──┬──┴──┬──┴──┬──┴────────────┘
     │     │     │     │
     ↓     ↓     ↓     ↓
  [PML4]→[PDPT]→[PD]→[PT]→ 物理フレーム

  → メモリ節約: 使用していない範囲のテーブルを作らない
  → 64bit空間（256TB）を効率的に管理
```

---

## 3. TLB（Translation Lookaside Buffer）

```
問題: 毎回ページテーブルを辿ると遅い（4階層 = 4回メモリアクセス）

TLB: ページテーブルのキャッシュ（CPUに内蔵）

  仮想アドレス
       │
       ├──→ [TLB] ──→ ヒット! → 物理アドレス（1サイクル）
       │        │
       │     ミス
       │        ↓
       └──→ [ページテーブル] → 物理アドレス + TLBに登録
            （4回のメモリアクセス）

  TLBの特性:
  - サイズ: 数十〜数百エントリ（非常に小さい）
  - ヒット率: 通常99%以上（局所性の恩恵）
  - コンテキストスイッチ時: TLBフラッシュ（またはASID）

  TLBミスのコスト:
  ヒット: 1サイクル（〜1ns）
  ミス:   100サイクル以上（メモリアクセス4回）
  → TLBヒット率を保つことがパフォーマンスの鍵

  ラージページの利点:
  4KB: 4GBをカバーするには100万エントリ必要
  2MB: 4GBをカバーするには2048エントリで済む
  → TLBミスが大幅に減少
  → データベース、JVMで効果的
```

---

## 4. ページフォルトとデマンドページング

```
デマンドページング:
  プログラム起動時に全ページを読み込まない
  → アクセスされた時に初めて物理メモリに配置

  ページフォルトの処理:
  1. CPUが仮想アドレスにアクセス
  2. ページテーブルの Present ビットが 0
  3. ページフォルト例外が発生
  4. OSが処理:
     a. ディスクからページを読み込み
     b. ページテーブルを更新
     c. TLBを更新
  5. 命令を再実行

  ページ置換アルゴリズム（物理メモリが満杯の時）:

  1. FIFO: 最も古いページを追い出す
     → 簡単だがBéládyの異常（メモリ増やすとフォルト増加）

  2. LRU（Least Recently Used）: 最近使われていないページを追い出す
     → 最適に近いが実装コストが高い

  3. Clock（近似LRU）: Accessedビットを使った効率的な近似
     → Linuxが採用（改良版）

  4. OPT（最適）: 将来最も遅く使われるページを追い出す
     → 理論上最適だが未来予知が必要で実装不可能

  スラッシング:
  物理メモリが不足 → 頻繁にページフォルト → I/O待ち増大
  → CPU利用率が低下 → OSがさらにプロセスを投入 → 悪化
  → 対策: メモリ追加、スワップ最適化、OOM Killer
```

---

## 実践演習

### 演習1: [基礎] — メモリ使用量の確認

```bash
# メモリ情報の確認
free -h                    # Linux: メモリ使用状況
vm_stat                    # macOS: メモリ統計
cat /proc/meminfo          # Linux: 詳細メモリ情報

# プロセスのメモリマップ
cat /proc/self/maps        # Linux
pmap $$                    # Linux: 見やすい形式
vmmap $$                   # macOS

# ページフォルトの確認
/usr/bin/time -v ls 2>&1 | grep "page faults"  # Linux
```

### 演習2: [応用] — アドレス変換の手計算

```
ページサイズ4KB、32bit仮想アドレス空間で:

仮想アドレス 0x00003A7F のアクセス:
1. ページ番号とオフセットに分割せよ
2. ページテーブル: ページ3→フレーム7 の場合、物理アドレスは？
3. TLBにこのエントリがない場合の処理を説明せよ
```

---

## FAQ

### Q1: スワップとは何か？

物理メモリが不足した時に、使用頻度の低いページをディスク（スワップ領域）に退避すること。これによりプロセスは物理メモリ以上のメモリを使用できるが、ディスクI/Oは非常に遅い（RAMの10万倍遅い）ため、パフォーマンスが大幅に低下する。SSDで多少改善されたが、根本的にはRAMを増やすべき。

### Q2: OOM Killerとは？

Linux Out-Of-Memory Killer。メモリが完全に枯渇した時に、OSがプロセスを強制終了して空きメモリを確保する仕組み。各プロセスにoom_scoreが付与され、スコアが高いプロセスが優先的にkillされる。`/proc/<pid>/oom_score_adj` で調整可能。

### Q3: なぜ64bitでも48bitしかアドレスを使わないのか？

現在のx86-64は48bit仮想アドレス空間（256TB）を使用。64bit全て（16EB）は現時点で必要なく、ページテーブルの階層が深くなりすぎる。Intel 5-Level Pagingで57bit（128PB）に拡張可能。需要に応じて段階的に拡張される設計。

---

## まとめ

| 概念 | ポイント |
|------|---------|
| 仮想メモリ | プロセスごとに独立したアドレス空間 |
| ページング | 4KB単位で仮想→物理をマッピング |
| TLB | ページテーブルのキャッシュ。ヒット率99%+ |
| デマンドページング | 必要時にのみ物理メモリに配置 |
| ページ置換 | LRU/Clock。メモリ不足時にスラッシング |

---

## 次に読むべきガイド
→ [[01-paging.md]] — ページングとセグメンテーション

---

## 参考文献
1. Silberschatz, A. et al. "Operating System Concepts." 10th Ed, Ch.9-10, 2018.
2. Gorman, M. "Understanding the Linux Virtual Memory Manager." Prentice Hall, 2004.
