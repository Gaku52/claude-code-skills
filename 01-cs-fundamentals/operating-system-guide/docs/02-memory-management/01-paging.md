# ページングとセグメンテーション

> ページングとセグメンテーションはメモリ管理の2つのアプローチ。現代のOSはページングを主体としつつ、セグメンテーションの概念を部分的に活用する。

## この章で学ぶこと

- [ ] セグメンテーションとページングの違いを説明できる
- [ ] 内部断片化と外部断片化を理解する
- [ ] 現代のメモリ管理（Linux）の仕組みを知る

---

## 1. セグメンテーション

```
セグメンテーション:
  プログラムを論理的な単位（セグメント）に分割

  ┌──────────┐
  │ コードセグメント │  読み取り専用
  ├──────────┤
  │ データセグメント │  読み書き可
  ├──────────┤
  │ スタックセグメント│  LIFO
  ├──────────┤
  │ ヒープセグメント │  動的割当
  └──────────┘

  各セグメントは可変長
  → 外部断片化が発生（メモリの隙間が使えない）

  ┌────┐  ┌──┐  ┌──────┐  ┌────┐
  │ A  │  │空│  │  B   │  │ C  │
  └────┘  └──┘  └──────┘  └────┘
          ↑ この隙間にDが入らない（外部断片化）

  x86のセグメントレジスタ（レガシー）:
  CS: コードセグメント
  DS: データセグメント
  SS: スタックセグメント
  → 現代のx86-64ではフラットモデル（セグメント無効化）
```

---

## 2. ページングの詳細

```
ページング:
  固定サイズ（4KB）のページに分割
  → 外部断片化なし
  → 内部断片化は最大1ページ未満（平均2KB）

  内部断片化 vs 外部断片化:
  ┌──────────────────────────────────────────┐
  │ 外部断片化（セグメンテーション）:         │
  │ 空きメモリの合計は十分だが、連続していない│
  │ → コンパクション（移動）で解消可能       │
  │                                          │
  │ 内部断片化（ページング）:                 │
  │ ページの末尾の余り（最大4KB-1）が無駄    │
  │ → ラージページ(2MB)だと内部断片化が増大  │
  └──────────────────────────────────────────┘

逆引きページテーブル（Inverted Page Table）:
  物理フレームごとに1エントリ
  → メモリ節約（物理メモリサイズに比例）
  → ハッシュテーブルで検索
  → PowerPC, IA-64で採用

メモリマップトファイル（mmap）:
  ファイルを仮想メモリにマッピング
  → read()/write()なしでファイルアクセス
  → 複数プロセスでファイルを共有可能
  → データベースでよく使用（SQLite, LMDB）
```

---

## 3. Linuxのメモリ管理

```
Linuxのメモリ管理の全体像:

  ┌──────────────────────────────────────┐
  │ ユーザー空間                          │
  │ malloc() / free() / new / delete     │
  │         ↓                            │
  │ glibcアロケータ (ptmalloc2)          │
  │ または jemalloc / tcmalloc           │
  │         ↓                            │
  │ brk() / mmap() システムコール        │
  ├──────────────────────────────────────┤
  │ カーネル空間                          │
  │ ページアロケータ (Buddy System)       │
  │         ↓                            │
  │ SLABアロケータ (SLUB)               │
  │ → カーネルオブジェクトの効率的な管理   │
  │         ↓                            │
  │ ページテーブル管理                    │
  │ → 4階層ページテーブル (x86-64)       │
  └──────────────────────────────────────┘

  Buddy System:
  物理ページを2のべき乗サイズのブロックで管理
  → 1, 2, 4, 8, 16, ... ページ単位
  → 割り当て/解放が高速
  → 内部断片化がやや大きい

  SLUB:
  Buddy Systemの上で小さなオブジェクトを効率管理
  → sizeof(struct task_struct) = 数KBの割り当てに最適化
  → 同じサイズのオブジェクトをキャッシュ

  OOM Killer:
  メモリ枯渇時に最もメモリを消費するプロセスを強制終了
  /proc/<pid>/oom_score で確認可能
```

---

## 実践演習

### 演習1: [基礎] — メモリ断片化の理解

```
以下のメモリ割り当て/解放シーケンスで
外部断片化がどう発生するか図示せよ:

メモリ: 100KB
1. A: 20KB割り当て
2. B: 30KB割り当て
3. C: 15KB割り当て
4. A: 解放（20KB空き）
5. D: 25KB割り当て要求 → 空きは35KBあるが連続20KB+15KB...
```

### 演習2: [応用] — ページテーブルサイズ計算

```
32bit仮想アドレス空間、4KBページサイズ、PTE = 4バイトの場合:

1. 1階層ページテーブルのサイズは？
2. 2階層ページテーブルで、1MBのプロセスに必要なテーブルサイズは？
3. なぜ多階層が効率的か説明せよ
```

---

## FAQ

### Q1: mallocは何をしているのか？

glibcのmallocはbrk()/sbrk()でヒープを拡張するか、大きなサイズではmmap()で新しい領域を確保する。内部でフリーリストを管理し、解放された領域を再利用する。実際のページ割り当てはアクセス時（デマンドページング）。

### Q2: メモリオーバーコミットとは？

Linuxではmalloc成功≠物理メモリ確保。仮想メモリだけ予約し、実際にアクセスされるまで物理ページを割り当てない（オーバーコミット）。全プロセスが確保した仮想メモリの合計は物理メモリを超えることがある。足りなくなったらOOM Killer発動。

---

## まとめ

| 概念 | ポイント |
|------|---------|
| セグメンテーション | 可変長。外部断片化。現代ではほぼ不使用 |
| ページング | 固定長(4KB)。外部断片化なし。現代の主流 |
| 内部断片化 | ページ末尾の無駄。最大4KB-1 |
| Linuxメモリ | Buddy System + SLUB + デマンドページング |

---

## 次に読むべきガイド
→ [[02-memory-allocation.md]] — メモリ割り当て戦略

---

## 参考文献
1. Silberschatz, A. et al. "Operating System Concepts." 10th Ed, Ch.8-9, 2018.
2. Bovet, D. & Cesati, M. "Understanding the Linux Kernel." 3rd Ed, O'Reilly, 2005.
