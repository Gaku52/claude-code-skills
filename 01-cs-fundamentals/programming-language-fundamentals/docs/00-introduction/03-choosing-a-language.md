# 言語の選び方

> 最適な言語は「何を作るか」「誰が作るか」「どこで動かすか」で決まる。

## この章で学ぶこと

- [ ] プロジェクト要件に基づいて言語を選定できる
- [ ] 各言語の強み・弱み・適用領域を把握する
- [ ] 言語選定の判断フレームワークを活用できる

---

## 1. ドメイン別の定番言語

### Web開発

```
フロントエンド:
  JavaScript / TypeScript  ← 事実上の唯一の選択肢
  + フレームワーク: React, Vue, Svelte, Angular
  + メタフレームワーク: Next.js, Nuxt, SvelteKit

バックエンド（選択肢が豊富）:
  ┌──────────────┬─────────────────────────────────────┐
  │ 言語          │ 特徴・適用                          │
  ├──────────────┼─────────────────────────────────────┤
  │ TypeScript   │ フルスタック統一。中小規模に最適     │
  │ (Node.js)    │ npm エコシステム。リアルタイム得意    │
  ├──────────────┼─────────────────────────────────────┤
  │ Python       │ AI/ML連携、プロトタイプ、Django/Flask│
  │ (FastAPI)    │ 型ヒント + 非同期で高速化            │
  ├──────────────┼─────────────────────────────────────┤
  │ Go           │ 高パフォーマンス API、マイクロサービス│
  │              │ 標準ライブラリが充実、デプロイ容易    │
  ├──────────────┼─────────────────────────────────────┤
  │ Java/Kotlin  │ エンタープライズ、大規模チーム       │
  │ (Spring)     │ 堅牢な型、長期保守に強い             │
  ├──────────────┼─────────────────────────────────────┤
  │ Rust         │ 高パフォーマンス + メモリ安全        │
  │ (Axum/Actix) │ CPU密集型処理、システム寄りの API    │
  ├──────────────┼─────────────────────────────────────┤
  │ Ruby (Rails) │ 高速プロトタイピング、MVP 開発       │
  │              │ Convention over Configuration        │
  └──────────────┴─────────────────────────────────────┘
```

### モバイル

```
ネイティブ:
  iOS     → Swift（推奨）/ Objective-C（レガシー）
  Android → Kotlin（推奨）/ Java（レガシー）

クロスプラットフォーム:
  Flutter (Dart)      → UI重視、高パフォーマンス
  React Native (JS)   → Web開発者の参入が容易
  KMP (Kotlin)        → ロジック共有、UIはネイティブ
```

### データ・AI

```
データサイエンス    → Python（pandas, numpy, scikit-learn）
機械学習           → Python（PyTorch, TensorFlow）
データエンジニアリング → Python + SQL + Spark(Scala)
統計分析           → R / Python
```

### システム・インフラ

```
OS / ドライバ       → C / Rust
パフォーマンス重視  → C++ / Rust
CLI ツール          → Go / Rust
DevOps スクリプト   → Python / Bash / Go
コンテナ / クラウド → Go（Docker, K8s, Terraform）
```

---

## 2. 言語選定の判断フレームワーク

### スコアカード方式

```
評価項目（重み付け）:

  ┌─────────────────┬────┬──────┬────┬──────┬──────┐
  │ 項目             │重み│Python│ Go │ Rust │ Java │
  ├─────────────────┼────┼──────┼────┼──────┼──────┤
  │ チーム習熟度     │ 25%│  9   │ 5  │  3   │  7   │
  │ エコシステム     │ 20%│  9   │ 7  │  6   │  9   │
  │ 実行性能         │ 15%│  4   │ 8  │  10  │  7   │
  │ 開発速度         │ 15%│  9   │ 7  │  5   │  6   │
  │ 保守性           │ 10%│  6   │ 8  │  9   │  8   │
  │ 採用のしやすさ   │ 10%│  9   │ 6  │  5   │  8   │
  │ デプロイ容易性   │  5%│  6   │ 10 │  9   │  5   │
  ├─────────────────┼────┼──────┼────┼──────┼──────┤
  │ 加重スコア       │    │ 7.7  │ 6.7│  5.8 │ 7.2  │
  └─────────────────┴────┴──────┴────┴──────┴──────┘

  → この例ではPythonが最適という結論
  ※ 重みはプロジェクトの性質で変わる
```

### 制約ベース判断

```
if (ブラウザで動く必要がある):
    → JavaScript / TypeScript / Wasm

if (iOSアプリ):
    → Swift（ネイティブ） or Flutter/RN（クロス）

if (レイテンシ < 1ms が必要):
    → C++ / Rust（GCなし言語）

if (チームサイズ > 50人):
    → 静的型付け言語（TypeScript, Go, Java, Kotlin）

if (AI/ML が中核機能):
    → Python + (高速部分は C++/Rust)

if (プロトタイプを1週間で):
    → Python / Ruby / JavaScript

if (10年以上の保守が必要):
    → Java / C# / Go / TypeScript
```

---

## 3. 2025年の言語トレンド

```
成長中:
  Rust      → メモリ安全への需要増。Linux kernel、Android、AWS で採用
  TypeScript→ JavaScript の事実上の後継。大規模プロジェクトの標準
  Go        → クラウドネイティブの標準。シンプルさが武器
  Kotlin    → Android公式。サーバーサイドでも台頭
  Zig       → C の現代的代替候補。組み込み・システム

安定:
  Python    → AI/ML の覇権は当面続く。Web/スクリプトでも万能
  Java      → エンタープライズの基盤。GraalVM で進化中
  C#        → .NET の進化で再評価。ゲーム(Unity)で強い
  Swift     → Apple エコシステムの唯一の選択肢
  C/C++     → レガシー資産と性能要件で不滅

注目:
  Mojo      → Python構文 + C性能。AI/ML向け
  Gleam     → Erlang VM上の型付き関数型。Elixirの代替候補
  Roc       → Elm inspired な新しい関数型言語
```

---

## 4. よくある間違い

```
❌ 「一番人気の言語を選べば間違いない」
  → 人気は汎用性であって、特定領域での最適性ではない

❌ 「新しい言語の方が良い」
  → エコシステムの成熟度・採用実績が重要

❌ 「パフォーマンスが最も大事」
  → ほとんどのWebアプリでは言語の速度差は問題にならない
     ボトルネックはDB、ネットワーク、アルゴリズム

❌ 「チーム全員が1つの言語で統一すべき」
  → ポリグロット（複数言語併用）は合理的
     フロント=TS、バック=Go、スクリプト=Python は一般的

❌ 「言語のベンチマーク結果で選ぶ」
  → マイクロベンチマークは実アプリの性能を反映しない
```

---

## 実践演習

### 演習1: [基礎] — 言語特性の比較表作成
Python, Go, Rust を「型」「メモリ管理」「並行処理」「エコシステム」で比較する表を作成する。

### 演習2: [応用] — 言語選定レポート
「リアルタイム株価表示ダッシュボード」に最適な技術スタックを選定し、判断根拠を述べる。

### 演習3: [発展] — 新言語の30分評価
触ったことのない言語を1つ選び、30分で Hello World → FizzBuzz → 簡単な HTTP サーバーを実装する。

---

## FAQ

### Q1: フルスタックを1言語で統一するメリットは？
A: コンテキストスイッチの削減、コード共有、チーム全体でのコードレビューが容易になる。TypeScript（Node.js + React）が代表例。ただしバックエンドの性能要件が高い場合はGoやRustとの併用が合理的。

### Q2: 言語を切り替えるタイミングは？
A: 既存言語で解決困難な技術的制約に直面した時、チームの生産性が明らかに低下している時、エコシステムのサポートが終了する時。段階的な移行（新機能から別言語で）が低リスク。

### Q3: プログラミング言語の寿命は？
A: COBOL（1959年〜）が今も稼働している通り、言語自体の寿命は長い。重要なのは「エコシステムの活発さ」と「人材の獲得可能性」。

---

## まとめ

| 判断軸 | 最重要ポイント |
|-------|-------------|
| ドメイン | 領域ごとに定番がある。逆らわない |
| チーム | 習熟度が生産性に直結する |
| 性能 | 本当にボトルネックか測定してから判断 |
| エコシステム | 必要なライブラリの有無を事前確認 |
| 保守性 | 10年後も人材がいる言語か |
| トレンド | 流行に振り回されず本質で判断 |

---

## 次に読むべきガイド
→ [[../01-type-systems/00-static-vs-dynamic.md]] — 型システム

---

## 参考文献
1. "Stack Overflow Developer Survey 2024." stackoverflow.com.
2. "The State of Developer Ecosystem 2024." JetBrains.
3. "Programming Language Pragmatics." Scott, M. 4th Ed, Morgan Kaufmann, 2015.
