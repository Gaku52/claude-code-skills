# コンパイルとインタプリタ

> ソースコードから実行可能なプログラムへの変換方法は、言語の特性・開発体験・実行性能を大きく左右する。

## この章で学ぶこと

- [ ] コンパイルとインタプリタの内部動作を理解する
- [ ] JIT コンパイルの仕組みと利点を理解する
- [ ] 各方式のトレードオフを判断できる

---

## 1. コンパイル型言語

### コンパイルの流れ

```
ソースコード（.c, .rs, .go）
    ↓
┌─────────────────────────────┐
│ 1. 字句解析（Lexing）        │  トークンに分割
│    int x = 42;               │  → [int] [x] [=] [42] [;]
├─────────────────────────────┤
│ 2. 構文解析（Parsing）       │  AST（抽象構文木）を構築
│    VariableDecl              │
│    ├── Type: int             │
│    ├── Name: x               │
│    └── Value: 42             │
├─────────────────────────────┤
│ 3. 意味解析（Semantic）      │  型チェック、スコープ解決
│    x: int ✓                  │
├─────────────────────────────┤
│ 4. 中間表現（IR）生成        │  最適化しやすい中間形式
│    %x = alloca i32           │
│    store i32 42, i32* %x     │
├─────────────────────────────┤
│ 5. 最適化                    │  デッドコード削除、インライン化
│    定数畳み込み、ループ展開   │
├─────────────────────────────┤
│ 6. コード生成                │  ターゲット機械語に変換
│    mov eax, 42               │
├─────────────────────────────┤
│ 7. リンク                    │  ライブラリと結合
│    実行可能バイナリ完成       │
└─────────────────────────────┘
    ↓
実行可能ファイル（a.out, .exe）
```

### AOT（Ahead-Of-Time）コンパイルの利点と欠点

```
利点:
  ✓ 実行速度が高速（事前に最適化済み）
  ✓ 配布が容易（バイナリ1つ）
  ✓ コンパイル時にエラーを検出
  ✓ リバースエンジニアリングが困難

欠点:
  ✗ コンパイル時間がかかる（大規模プロジェクトで問題）
  ✗ プラットフォームごとにコンパイルが必要
  ✗ インクリメンタルな開発が遅い

代表的な言語:
  C, C++, Rust, Go, Swift, Haskell
```

---

## 2. インタプリタ型言語

### インタプリタの動作

```
ソースコード（.py, .rb）
    ↓
┌─────────────────────────────┐
│ 1. 字句解析 + 構文解析       │  AST を構築
├─────────────────────────────┤
│ 2. 逐次実行                  │  AST を辿りながら実行
│    または                    │
│    バイトコード変換 → VM実行  │  （CPython, Ruby MRI）
└─────────────────────────────┘
    ↓
  実行結果（即座に）
```

### CPython の実行モデル

```python
# Python のコードは内部的にバイトコードにコンパイルされる
import dis

def add(a, b):
    return a + b

dis.dis(add)
# 出力:
#   LOAD_FAST   0 (a)
#   LOAD_FAST   1 (b)
#   BINARY_ADD
#   RETURN_VALUE

# .pyc ファイル = コンパイル済みバイトコード
# __pycache__/ に自動キャッシュされる
```

### インタプリタの利点と欠点

```
利点:
  ✓ 即座に実行可能（REPL、対話的開発）
  ✓ プラットフォーム非依存（インタプリタがあれば動く）
  ✓ 動的な言語機能（eval, メタプログラミング）
  ✓ 開発サイクルが速い

欠点:
  ✗ 実行速度が遅い（10〜100倍の差）
  ✗ ランタイムエラーが実行時まで分からない
  ✗ 実行環境にインタプリタが必要

代表的な言語:
  Python(CPython), Ruby(MRI), PHP, Perl, Lua
```

---

## 3. JIT コンパイル

### JIT の仕組み

```
ソースコード
    ↓
バイトコード（事前コンパイル）
    ↓
┌─────────────────────────────────────────┐
│ JIT コンパイラ（実行中に動作）            │
│                                          │
│ 1. プロファイリング                       │
│    → どのコードが頻繁に実行されるか監視    │
│                                          │
│ 2. ホットスポット検出                     │
│    → 頻繁に実行されるコードを特定          │
│    （ループ、頻呼び出し関数）             │
│                                          │
│ 3. 最適化コンパイル                       │
│    → ホットコードだけを機械語にコンパイル   │
│    → 実行時の型情報を活用した最適化        │
│                                          │
│ 4. 脱最適化（Deoptimization）             │
│    → 前提が崩れたら再インタプリタ          │
└─────────────────────────────────────────┘
    ↓
  実行（ウォームアップ後はネイティブに近い速度）
```

### V8 エンジン（JavaScript）のパイプライン

```
JavaScript ソースコード
    ↓
  Parser → AST
    ↓
  Ignition（インタプリタ）→ バイトコード実行
    ↓  （ホットコード検出）
  TurboFan（最適化コンパイラ）→ 機械語
    ↓  （前提が崩れた場合）
  Deoptimize → Ignition に戻る

性能の推移:
  起動直後:  インタプリタで低速
  数秒後:    JIT により高速化
  安定後:    ネイティブコードに近い性能
```

### JVM（Java Virtual Machine）の階層的コンパイル

```
Java ソースコード
    ↓
  javac → バイトコード（.class）
    ↓
┌─────────────────────────────────────┐
│ JVM の実行層                         │
│                                      │
│ Level 0: インタプリタ                │
│ Level 1: C1 コンパイラ（簡易最適化） │
│ Level 2: C1 + プロファイリング       │
│ Level 3: C1 + フルプロファイリング   │
│ Level 4: C2 コンパイラ（最大最適化） │
│                                      │
│ 実行回数に応じて段階的に最適化が進む │
└─────────────────────────────────────┘

GraalVM: 多言語対応JIT
  → Java, JS, Python, Ruby, R を同一VM上で実行可能
  → AOT コンパイル（native-image）も可能
```

---

## 4. 現代の実行モデル

### WebAssembly（Wasm）

```
C/Rust/Go/etc.
    ↓  コンパイル
  .wasm（バイナリ形式）
    ↓  ブラウザ / ランタイム
  ストリーミングコンパイル → 実行

特徴:
  - ほぼネイティブの実行速度
  - ブラウザで安全に実行（サンドボックス）
  - 言語非依存（どの言語からもコンパイル可能）
  - WASI: ブラウザ外（サーバー等）でも実行可能
```

### トランスパイル

```
TypeScript → JavaScript
Kotlin → JVM バイトコード / JavaScript
Elm → JavaScript
Sass → CSS
JSX → JavaScript

利点:
  - 元の言語の表現力 + ターゲットのエコシステム
  - 漸進的な移行が可能（TSをJSプロジェクトに段階的に導入）
```

---

## 5. パフォーマンス比較

```
ベンチマーク参考値（フィボナッチ再帰 n=40）:

  言語             実行時間    方式
  ─────────────────────────────────
  C (gcc -O2)      0.15s      AOT
  Rust (release)   0.16s      AOT
  Go               0.45s      AOT
  Java             0.55s      JIT
  JavaScript(V8)   0.80s      JIT
  C# (.NET)        0.60s      JIT
  PyPy             1.20s      JIT
  CPython          15.0s      インタプリタ
  Ruby (MRI)       12.0s      インタプリタ

  ※ 実際のアプリケーション性能はI/O・アルゴリズム・
    最適化で大きく変わる。マイクロベンチマークは参考程度に。
```

---

## 実践演習

### 演習1: [基礎] — バイトコードの確認
Pythonの `dis` モジュールで簡単な関数のバイトコードを確認する。

### 演習2: [応用] — JIT の効果を計測
同じアルゴリズムを CPython と PyPy で実行し、JIT の効果を比較する。

### 演習3: [発展] — 簡易インタプリタの実装
四則演算を評価する簡易インタプリタを Python で実装する。

---

## FAQ

### Q1: 「コンパイル型 = 速い」は正しい？
A: 概ね正しいが例外もある。JIT は実行時情報を使って AOT より良い最適化が可能な場合がある。実用上はアルゴリズムの選択の方がはるかに重要。

### Q2: TypeScript はコンパイル型？
A: TypeScript は JavaScript にトランスパイルされる。型チェックはコンパイル時だが、実行時は JavaScript エンジン（JIT）が動く。分類としてはトランスパイル型。

### Q3: Go が速い理由は？
A: 静的型付け + AOT コンパイル + ガベージコレクタの最適化 + goroutine による効率的な並行処理。シンプルな言語仕様がコンパイラの最適化を容易にしている。

---

## まとめ

| 方式 | 代表言語 | 実行速度 | 開発速度 | ポータビリティ |
|------|---------|---------|---------|-------------|
| AOT コンパイル | C, Rust, Go | 最速 | 遅め | 低（再コンパイル必要） |
| インタプリタ | Python, Ruby | 遅い | 最速 | 高（インタプリタがあれば） |
| JIT | Java, JS | 高速 | 中程度 | 高（VM上で実行） |
| トランスパイル | TS, Kotlin | ターゲット依存 | 中程度 | ターゲット依存 |

---

## 次に読むべきガイド
→ [[02-paradigms-overview.md]] — プログラミングパラダイム

---

## 参考文献
1. Aho, A., Lam, M., Sethi, R. & Ullman, J. "Compilers: Principles, Techniques, and Tools." 2nd Ed, 2006.
2. Nystrom, R. "Crafting Interpreters." 2021.
