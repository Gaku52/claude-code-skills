# 配列と文字列

> 配列はメモリ上の連続した領域であり、そのシンプルさゆえにCPUキャッシュと最も相性が良いデータ構造である。

## この章で学ぶこと

- [ ] 配列のメモリレイアウトとアクセスパターンを理解する
- [ ] 静的配列と動的配列の違いを説明できる
- [ ] 文字列の内部表現と実務的な操作を理解する

## 前提知識

- メモリの基礎 → 参照: [[../01-hardware-basics/01-memory-hierarchy.md]]
- 計算量解析 → 参照: [[../03-algorithms/01-complexity-analysis.md]]

---

## 1. 配列の基礎

### 1.1 メモリレイアウト

```
配列: メモリ上の連続した領域に同じ型の要素を格納

  int arr[5] = {10, 20, 30, 40, 50};

  メモリ:
  アドレス:  0x100  0x104  0x108  0x10C  0x110
  値:        10     20     30     40     50
             arr[0] arr[1] arr[2] arr[3] arr[4]

  アクセス: arr[i] のアドレス = base + i × sizeof(element)
  → O(1) のランダムアクセス（これが配列の最大の強み）

  連続メモリの利点:
  1. キャッシュ効率が極めて高い（空間的局所性）
  2. プリフェッチが効果的
  3. アドレス計算が単純（加算1回）
```

### 1.2 操作の計算量

```
配列の基本操作:

  ┌──────────────────┬──────────┬────────────────────┐
  │ 操作             │ 計算量   │ 備考               │
  ├──────────────────┼──────────┼────────────────────┤
  │ アクセス arr[i]  │ O(1)     │ 最大の強み          │
  │ 先頭に挿入      │ O(n)     │ 全要素をシフト      │
  │ 末尾に挿入      │ O(1)*    │ *償却。リサイズ時O(n)│
  │ 中間に挿入      │ O(n)     │ 後続要素をシフト    │
  │ 先頭を削除      │ O(n)     │ 全要素をシフト      │
  │ 末尾を削除      │ O(1)     │                    │
  │ 中間を削除      │ O(n)     │ 後続要素をシフト    │
  │ 検索（未ソート） │ O(n)     │ 線形探索           │
  │ 検索（ソート済み）│ O(log n) │ 二分探索           │
  └──────────────────┴──────────┴────────────────────┘

  → 配列は「読み取り最適」のデータ構造
  → 挿入/削除が頻繁なら他のデータ構造を検討
```

### 1.3 動的配列

```python
# 動的配列: サイズが自動拡張する配列
# Python: list, Java: ArrayList, C++: std::vector, Rust: Vec

# 拡張戦略:
# 容量が足りなくなったら2倍に拡張（倍増戦略）
# → 挿入の償却計算量: O(1)

# Python listの内部動作:
import sys
lst = []
for i in range(20):
    lst.append(i)
    print(f"len={len(lst):2d}, "
          f"capacity≈{sys.getsizeof(lst) // 8:2d}, "
          f"size={sys.getsizeof(lst)}B")

# 出力例（CPythonの場合、容量は段階的に増加）:
# len= 1, capacity≈ 7, size= 56
# len= 5, capacity≈ 7, size= 56
# len= 9, capacity≈13, size=104
# ...

# 注意: Python list は「配列の配列」（ポインタの配列）
# → 要素はメモリ上で連続していない
# → numpy.array は真の連続配列（高速）
```

---

## 2. 文字列

### 2.1 各言語の文字列内部表現

```
文字列の内部表現:

  ┌──────────┬──────────────────┬──────────────────────┐
  │ 言語      │ 内部表現         │ 特徴                 │
  ├──────────┼──────────────────┼──────────────────────┤
  │ Python   │ Unicode (UCS-1/2/4)│ イミュータブル      │
  │ Java     │ UTF-16 char[]    │ イミュータブル       │
  │ JavaScript│ UTF-16          │ イミュータブル       │
  │ Go       │ UTF-8 []byte     │ イミュータブル       │
  │ Rust     │ UTF-8 Vec<u8>    │ 所有権あり          │
  │ C/C++    │ char[] (ASCII/UTF-8)│ ミュータブル、null終端│
  └──────────┴──────────────────┴──────────────────────┘

  イミュータブル文字列の影響:
  - 文字列の変更 = 新しい文字列を生成 → O(n)
  - ループ内での連結 → O(n²) になりやすい
  - 対策: StringBuilder, join, StringIO を使用
```

### 2.2 実務的な配列テクニック

```python
# 1. Two Pointers（2つのポインタ）
def remove_duplicates_sorted(arr):
    """ソート済み配列から重複を除去（インプレース）"""
    if not arr:
        return 0
    write = 1
    for read in range(1, len(arr)):
        if arr[read] != arr[read - 1]:
            arr[write] = arr[read]
            write += 1
    return write  # 新しい長さ

# 2. スライディングウィンドウ
def max_sum_subarray(arr, k):
    """長さkの連続部分配列の最大合計"""
    window = sum(arr[:k])
    best = window
    for i in range(k, len(arr)):
        window += arr[i] - arr[i - k]
        best = max(best, window)
    return best

# 3. プレフィックス和（累積和）
def prefix_sum(arr):
    """区間の合計をO(1)で求める前処理"""
    n = len(arr)
    ps = [0] * (n + 1)
    for i in range(n):
        ps[i + 1] = ps[i] + arr[i]
    return ps
# 区間[l, r)の合計 = ps[r] - ps[l]
```

---

## 3. 実践演習

### 演習1: 配列操作（基礎）
配列を時計回りに90度回転する関数を実装せよ。

### 演習2: 文字列操作（応用）
文字列が回文かどうかを判定する関数を実装せよ（英数字以外を無視、大文字小文字を区別しない）。

### 演習3: 2次元配列（発展）
スパイラル順で行列の要素を出力する関数を実装せよ。

---

## FAQ

### Q1: Python の list と tuple の違いは？
**A**: list はミュータブル（変更可能）、tuple はイミュータブル。tuple はハッシュ可能なので辞書のキーや集合の要素に使える。パフォーマンスは tuple がわずかに有利（メモリ確保が少ない）。

### Q2: 配列 vs リンクリスト、どちらを使うべき？
**A**: ほとんどの場合、配列（動的配列）が正解。キャッシュ効率が圧倒的に良く、ランダムアクセスがO(1)。リンクリストが有利なのは「先頭/末尾への頻繁な挿入削除」かつ「ランダムアクセス不要」の場合のみ。

---

## まとめ

| 概念 | ポイント |
|------|---------|
| 配列 | 連続メモリ。O(1)アクセス。キャッシュ最適 |
| 動的配列 | 倍増戦略で償却O(1)の追加 |
| 文字列 | 多くの言語でイミュータブル。連結に注意 |
| テクニック | Two Pointers, スライディングウィンドウ, プレフィックス和 |

---

## 次に読むべきガイド
→ [[01-linked-lists.md]] — 連結リスト

---

## 参考文献
1. Sedgewick, R. "Algorithms." Chapter 1.3: Bags, Queues, and Stacks.
2. Cormen, T. H. "Introduction to Algorithms." Chapter 10.
