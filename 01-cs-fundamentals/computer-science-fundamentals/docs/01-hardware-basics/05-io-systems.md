# I/Oシステム

> I/O（入出力）はコンピュータと外部世界をつなぐ窓であり、多くのアプリケーションのボトルネックはCPUではなくI/Oにある。

## この章で学ぶこと

- [ ] I/Oの基本概念（ポーリング、割り込み、DMA）を説明できる
- [ ] デバイスドライバの役割を理解する
- [ ] 非同期I/O（epoll、io_uring）の仕組みを説明できる

## 前提知識

- CPUとメモリの基礎 → 参照: [[00-cpu-architecture.md]], [[01-memory-hierarchy.md]]

---

## 1. I/Oの3つの方式

### 1.1 ポーリング（Polling）

```
ポーリング方式:

  CPU                     デバイス
  │                       │
  │──「準備できた？」─────→│
  │←─「まだ」────────────│
  │──「準備できた？」─────→│  ← CPUが繰り返し確認（ビジーウェイト）
  │←─「まだ」────────────│
  │──「準備できた？」─────→│
  │←─「できた！」────────│
  │──「データ頂戴」──────→│
  │←─ データ ────────────│
  │                       │

  利点: 実装が単純、低レイテンシ
  欠点: CPU時間を大量に消費（他の処理ができない）
  用途: NVMe SSDの高速I/O（割り込みのオーバーヘッドを避ける）
```

### 1.2 割り込み（Interrupt）

```
割り込み方式:

  CPU                     デバイス
  │                       │
  │──「読んでおいて」────→│
  │                       │
  │ (他の処理を実行)       │  ← CPUは他の仕事ができる
  │                       │
  │←─── 割り込み信号 ────│  ← デバイスが完了を通知
  │                       │
  │ [割り込みハンドラ実行] │
  │──「データ頂戴」──────→│
  │←─ データ ────────────│
  │                       │
  │ [元の処理に復帰]       │

  利点: CPUを効率的に使える
  欠点: コンテキストスイッチのオーバーヘッド（〜1-10μs）
  用途: キーボード、マウス、ネットワーク、一般的なI/O
```

### 1.3 DMA（Direct Memory Access）

```
DMA方式:

  CPU                DMAコントローラ          デバイス
  │                  │                        │
  │──「転送設定」──→│                        │
  │                  │──「データ転送開始」──→│
  │                  │                        │
  │ (他の処理を実行) │←─── データ ───────────│
  │                  │←─── データ ───────────│
  │                  │←─── データ ───────────│
  │                  │                        │
  │←── 完了割り込み ─│                        │
  │                  │                        │

  利点: CPUを介さずにメモリ↔デバイス間でデータ転送
  欠点: DMAコントローラが必要
  用途: ディスクI/O、ネットワーク、GPU転送

  例: 1GBのファイルをSSDからRAMにロード
    割り込み方式: CPUが1バイトずつ転送 → CPU 100%使用
    DMA方式: DMAが転送、CPUは他の仕事 → CPU ほぼ0%使用
```

---

## 2. デバイスドライバ

```
デバイスドライバの位置づけ:

  ┌──────────────────────────────────────────┐
  │  ユーザー空間 (User Space)               │
  │  ┌────────────────────────────────────┐ │
  │  │ アプリケーション                     │ │
  │  │ read(), write(), ioctl()           │ │
  │  └──────────────┬─────────────────────┘ │
  │                  │ システムコール          │
  ├──────────────────┼───────────────────────┤
  │  カーネル空間 (Kernel Space)             │
  │                  ▼                       │
  │  ┌────────────────────────────────────┐ │
  │  │ VFS (Virtual File System)          │ │
  │  │ → 統一インターフェース              │ │
  │  └──────────────┬─────────────────────┘ │
  │                  ▼                       │
  │  ┌────────────────────────────────────┐ │
  │  │ デバイスドライバ                    │ │
  │  │ → ハードウェア固有の操作            │ │
  │  │ → 割り込みハンドラの登録            │ │
  │  │ → DMA転送の制御                    │ │
  │  └──────────────┬─────────────────────┘ │
  │                  │                       │
  └──────────────────┼───────────────────────┘
                     ▼
  ┌────────────────────────────────────────┐
  │  ハードウェア（SSD、NIC、GPU等）         │
  └────────────────────────────────────────┘
```

---

## 3. 非同期I/Oの進化

### 3.1 select → poll → epoll → io_uring

| 方式 | 年代 | スケーラビリティ | 特徴 |
|------|------|---------------|------|
| **select** | 1983 | O(n) | FD上限1024、毎回全FD走査 |
| **poll** | 1986 | O(n) | FD上限なし、毎回全FD走査 |
| **epoll** | 2002 | O(1) | イベント駆動、Linux標準 |
| **kqueue** | 2000 | O(1) | BSD/macOS版のepoll |
| **io_uring** | 2019 | O(1) | ゼロコピー、カーネルバイパス |

### 3.2 epoll の仕組み

```
epoll の動作:

  ユーザー空間                    カーネル空間
  ┌───────────┐                  ┌────────────────┐
  │ アプリ    │                  │ epoll インスタンス│
  │           │ epoll_create()   │                │
  │           │──────────────→│ ┌────────────┐ │
  │           │                  │ │ 関心FDリスト│ │
  │           │ epoll_ctl(ADD)   │ └────────────┘ │
  │           │──────────────→│                │
  │           │                  │ ┌────────────┐ │
  │           │ epoll_wait()     │ │ Ready List │ │
  │           │──────────────→│ └────────────┘ │
  │           │ (ブロック)        │                │
  │           │                  │ ← デバイス割り込み
  │           │←── Ready FDs ──│                │
  │           │                  │                │
  └───────────┘                  └────────────────┘

  epollの利点:
  - 関心のあるFDだけを監視（O(1)のイベント通知）
  - 10万+の同時接続を効率的に処理（C10K問題の解決）
  - Node.js, Nginx, Redis の内部で使用
```

### 3.3 io_uring（Linux 5.1+）

```
io_uring の革新:

  従来のI/O:
    ユーザー空間 ──システムコール──→ カーネル空間
    (毎回コンテキストスイッチが発生)

  io_uring:
    ┌─────────────────────────────────────────────┐
    │  共有メモリ（Ring Buffer）                    │
    │                                             │
    │  Submission Queue (SQ)    Completion Queue (CQ)│
    │  ┌──┬──┬──┬──┐         ┌──┬──┬──┬──┐       │
    │  │op│op│op│  │         │  │  │ok│ok│       │
    │  └──┴──┴──┴──┘         └──┴──┴──┴──┘       │
    │   ↑ ユーザーが投入      ↓ カーネルが結果記入   │
    └─────────────────────────────────────────────┘

    利点:
    - システムコールなしでI/O要求を投入（ゼロコピー）
    - バッチ処理（複数のI/Oをまとめて投入）
    - 非同期のファイルI/O、ネットワークI/O、タイマー全て統一
    - SSDの性能を100%引き出せる
```

---

## 4. 実務でのI/O

### 4.1 Node.js のイベントループ

```javascript
// Node.js の非同期I/Oの内部:
// libuv → epoll (Linux) / kqueue (macOS)

const fs = require('fs');
const http = require('http');

// ファイル読み取り: 非同期I/O
fs.readFile('/path/to/file', (err, data) => {
    // libuv のスレッドプールでI/Oを実行
    // 完了時にコールバックをイベントキューに投入
    console.log(data);
});

// HTTPサーバー: epoll/kqueue で同時接続管理
const server = http.createServer((req, res) => {
    // 数万の同時接続を1スレッドで処理
    res.end('Hello');
});
server.listen(3000);

// イベントループの内部:
// while (true) {
//   events = epoll_wait(...)  // I/O完了を待つ
//   for (event of events) {
//     callback(event)  // コールバック実行
//   }
//   processTimers()  // タイマー処理
//   processNextTick() // process.nextTick
// }
```

---

## 5. 実践演習

### 演習1: I/O方式の選択（基礎）
以下のデバイスに適したI/O方式を選び、理由を述べよ:
1. キーボード入力
2. 4KBのSSDランダム読み取り（100万IOPS）
3. 10Gbpsネットワーク受信

### 演習2: 非同期I/Oの実装（応用）
Pythonのasyncioで同時に10個のHTTPリクエストを送信し、全結果を集約するコードを書け。

### 演習3: I/O性能測定（発展）
`strace` でアプリのシステムコールを観察し、I/Oのボトルネックを特定せよ。

---

## FAQ

### Q1: 「全てはファイル」とはどういう意味ですか？
**A**: UNIXの設計思想。デバイス（/dev/sda）、プロセス情報（/proc/）、ネットワークソケットも全て「ファイル」として統一的にread/writeできる。これにより、同じAPIで全てのI/Oを扱える。

### Q2: async/awaitとepollの関係は？
**A**: async/awaitは「構文糖」であり、内部的にはepoll/kqueueベースのイベントループが動いている。await時にスレッドをブロックせず、epollに登録して他のタスクに切り替える。

### Q3: io_uringはいつ使うべきですか？
**A**: 高スループットが必要なサーバー（DB、ストレージエンジン等）。一般的なWebアプリはepoll（Node.js、Nginx）で十分。

---

## まとめ

| 概念 | ポイント |
|------|---------|
| ポーリング | 単純だがCPU浪費。超低レイテンシ用途 |
| 割り込み | CPUを効率的に使える。一般的な方式 |
| DMA | CPU介さずデータ転送。大容量I/O向け |
| epoll/kqueue | O(1)のイベント駆動I/O。C10K問題の解決 |
| io_uring | ゼロコピーI/O。次世代のLinux I/O |

---

## 次に読むべきガイド
→ [[06-pcb-and-circuits.md]] — 電子回路と半導体の基礎

---

## 参考文献
1. Love, R. "Linux Kernel Development." 3rd Edition, Addison-Wesley, 2010.
2. Arpaci-Dusseau, R. H. "OSTEP: I/O Devices." https://pages.cs.wisc.edu/~remzi/OSTEP/
3. Axboe, J. "Efficient I/O with io_uring." Linux kernel documentation.
4. Stevens, W. R. "UNIX Network Programming." Vol.1, 3rd Edition.
