# アルゴリズムとは何か

> アルゴリズムとは「問題を解くための明確な手順」であり、プログラミングの本質はアルゴリズムの設計と実装である。

## この章で学ぶこと

- [ ] アルゴリズムの定義と5つの条件を説明できる
- [ ] 良いアルゴリズムと悪いアルゴリズムの違いを理解する
- [ ] 問題→アルゴリズム→コードの思考プロセスを身につける
- [ ] 主要なアルゴリズム設計戦略を使い分けられる
- [ ] アルゴリズムの正しさを証明する基本的な手法を理解する

## 前提知識

- 基本的なプログラミング経験

---

## 1. アルゴリズムの定義

### 1.1 アルゴリズムの5つの条件

```
アルゴリズム (Algorithm):
  有限の手順で問題を解決する、明確に定義された計算手続き

  5つの条件（Knuth, 1968）:

  1. 入力 (Input):
     → 0個以上の外部データを受け取る
     → 例: ソート → 数値の配列

  2. 出力 (Output):
     → 1個以上の結果を生成する
     → 例: ソート → 並べ替えた配列

  3. 明確性 (Definiteness):
     → 各ステップが曖昧さなく定義されている
     → ❌「適当にいい感じに並べる」
     → ✅「隣接する要素を比較し、左が大きければ交換する」

  4. 有限性 (Finiteness):
     → 有限回のステップで必ず終了する
     → 無限ループはアルゴリズムではない

  5. 有効性 (Effectiveness):
     → 各ステップが十分に基本的で、実行可能である
     → 「素数を全て列挙する」は無限なのでNG
     → 「N以下の素数を列挙する」はOK
```

### 1.2 アルゴリズムの語源と歴史

```
アルゴリズムの歴史:

  語源:
  - 9世紀のペルシャの数学者 アル・フワーリズミー（al-Khwārizmī）
  - 彼の名前のラテン語訳「Algoritmi」が由来
  - 著書『インドの計算法について』で十進法の計算手順を紹介

  歴史上の重要なアルゴリズム:
  ┌────────────────┬──────┬─────────────────────────────┐
  │ アルゴリズム     │ 年代  │ 概要                         │
  ├────────────────┼──────┼─────────────────────────────┤
  │ ユークリッドの   │ BC300│ 2数の最大公約数を求める        │
  │ 互除法          │      │ → 現存する最古のアルゴリズム    │
  │ エラトステネスの │ BC200│ 素数をふるいにかけて列挙       │
  │ ふるい          │      │                              │
  │ アル・フワーリズミ│ 830  │ 一次/二次方程式の解法         │
  │ の代数学        │      │ → 「代数学」の語源にもなった   │
  │ ニュートン法    │ 1669 │ 方程式の近似解を反復で求める   │
  │ ガウスの消去法  │ 1809 │ 連立一次方程式の解法          │
  │ バベッジの      │ 1837 │ 機械的な計算手順の概念        │
  │ 解析機関       │      │ → プログラムの原型            │
  │ チューリングマシン│ 1936│ 計算可能性の理論的基盤        │
  │ フォン・ノイマン │ 1945 │ プログラム内蔵方式            │
  │ マージソート    │ 1945 │ フォン・ノイマンが考案         │
  └────────────────┴──────┴─────────────────────────────┘

  「アルゴリズム」が現代的な意味を持つようになった転機:
  - 1936年: チューリングが「計算可能」を厳密に定義
  - 1945年: フォン・ノイマンがプログラム内蔵方式を提案
  - 1960年代: Knuthが『The Art of Computer Programming』を出版
  - → アルゴリズム解析が独立した研究分野に
```

### 1.3 日常のアルゴリズム

```
料理のレシピ = アルゴリズム:

  カレーの作り方:
  入力: 玉ねぎ2個, 肉300g, カレールー1箱, 水800ml
  出力: カレー4人前

  1. 玉ねぎを薄切りにする
  2. 鍋に油を入れ、中火で加熱する
  3. 玉ねぎを飴色になるまで炒める（約10分）
  4. 肉を加え、色が変わるまで炒める
  5. 水800mlを加え、沸騰させる
  6. 弱火で20分煮る
  7. 火を止め、ルーを割り入れて溶かす
  8. 弱火で5分煮る
  → 完成

  これはアルゴリズムの5条件を全て満たす:
  ✅ 入力: 食材
  ✅ 出力: カレー
  ✅ 明確性: 各ステップが具体的
  ✅ 有限性: 8ステップで終了
  ✅ 有効性: 各ステップは実行可能
```

```
日常のアルゴリズムの他の例:

  1. 辞書で単語を引く（二分探索）:
  ┌──────────────────────────────────────┐
  │ 入力: 辞書、探す単語                    │
  │ 出力: 単語の意味                        │
  │                                        │
  │ 1. 辞書のだいたい真ん中を開く            │
  │ 2. 開いたページの単語と探す単語を比較     │
  │ 3. 探す単語が「前」なら前半を探す         │
  │ 4. 探す単語が「後」なら後半を探す         │
  │ 5. 見つかるまで2-4を繰り返す             │
  │                                        │
  │ → 1000ページの辞書でも約10回で見つかる！  │
  └──────────────────────────────────────┘

  2. トランプの手札を並べ替える（挿入ソート）:
  ┌──────────────────────────────────────┐
  │ 入力: 手持ちのカード                    │
  │ 出力: 番号順に並んだカード               │
  │                                        │
  │ 1. 2枚目のカードを取り出す              │
  │ 2. 左側のカードと比較                   │
  │ 3. 正しい位置に挿入                     │
  │ 4. 次のカードで2-3を繰り返す             │
  │                                        │
  │ → 人間が自然にやるソート方法！           │
  └──────────────────────────────────────┘

  3. 迷路を解く（深さ優先探索 / 壁伝い法）:
  ┌──────────────────────────────────────┐
  │ 入力: 迷路（入口と出口がある）           │
  │ 出力: 入口から出口への経路               │
  │                                        │
  │ 壁伝い法:                               │
  │ 1. 右手を壁に付ける                     │
  │ 2. 壁に沿って歩く                       │
  │ 3. 出口に到達するまで繰り返す            │
  │                                        │
  │ → 単純だが確実に出口に到達する           │
  │   （単連結の迷路の場合）                 │
  └──────────────────────────────────────┘

  4. お釣りを計算する（貪欲法）:
  ┌──────────────────────────────────────┐
  │ 入力: お釣りの金額                      │
  │ 出力: 最少枚数の硬貨の組み合わせ         │
  │                                        │
  │ 1. 最も大きい硬貨から使えるだけ使う       │
  │    500円 → 100円 → 50円 → 10円          │
  │    → 5円 → 1円                          │
  │ 2. 残金が0になるまで繰り返す             │
  │                                        │
  │ 例: 680円のお釣り                       │
  │ 500円×1, 100円×1, 50円×1, 10円×3       │
  │ = 合計6枚                               │
  │                                        │
  │ → 日本の硬貨体系では最適解が得られる     │
  │   （常にそうとは限らない点が重要）       │
  └──────────────────────────────────────┘
```

### 1.4 アルゴリズムでないものの例

```
アルゴリズムではないもの:

  1. 「なんとなく並べ替える」
     → 明確性の欠如
     → 「何を基準に」「どう並べ替えるか」が不明

  2. 「素数を全て列挙せよ」
     → 有限性の違反
     → 素数は無限に存在するため終了しない

  3. 「配列の中から最適な要素を直感で選ぶ」
     → 有効性の欠如
     → 「直感」は計算手順として実行不可能

  4. while True: print("Hello")
     → 有限性の違反
     → 永遠に終了しない

  注意: アルゴリズムと「プログラム」の違い
  ┌──────────────────────────────────────┐
  │ アルゴリズム:                           │
  │ - 必ず有限時間で終了する                │
  │ - 言語に依存しない抽象的な手順          │
  │                                        │
  │ プログラム:                             │
  │ - 終了しなくてもよい（OSやサーバー等）   │
  │ - 特定のプログラミング言語で記述         │
  │                                        │
  │ → 全てのアルゴリズムはプログラムにできるが│
  │   全てのプログラムがアルゴリズムではない  │
  └──────────────────────────────────────┘
```

---

## 2. アルゴリズムの設計戦略

### 2.1 主要な設計パターン

```
アルゴリズム設計の7大戦略:

  ┌─────────────────┬──────────────────────────────────────┐
  │ 戦略            │ 概要                                  │
  ├─────────────────┼──────────────────────────────────────┤
  │ 全探索          │ 全ての可能性を試す（ブルートフォース） │
  │ 分割統治        │ 問題を分割→各個解決→結合              │
  │ 動的計画法      │ 部分問題の解を記憶して再利用           │
  │ 貪欲法          │ 各ステップで局所最適な選択をする       │
  │ バックトラック   │ 探索を進め、行き詰まったら戻る        │
  │ 二分探索        │ 範囲を半分に絞りながら探索             │
  │ グラフ探索      │ BFS/DFSで状態空間を探索               │
  └─────────────────┴──────────────────────────────────────┘
```

### 2.2 全探索（ブルートフォース）

```python
# 全探索: 全ての可能性を愚直に試す
# 長所: 確実に正解が得られる、実装が簡単
# 短所: 計算量が大きい

# 例1: パスワードの総当たり（4桁数字）
def brute_force_pin():
    """4桁のPINコードを全て試す"""
    for pin in range(10000):  # 0000-9999
        if try_pin(f"{pin:04d}"):
            return f"{pin:04d}"
    return None
# 計算量: O(10^4) = O(10000)

# 例2: 部分和問題
def subset_sum(nums, target):
    """numsの部分集合で合計がtargetになるものがあるか"""
    n = len(nums)
    # ビットマスクで全部分集合を列挙
    for mask in range(1 << n):  # 2^n 通り
        total = 0
        for i in range(n):
            if mask & (1 << i):
                total += nums[i]
        if total == target:
            return True
    return False
# 計算量: O(n × 2^n)

# 例3: 文字列のアナグラム判定（素朴な方法）
def is_anagram_brute(s1, s2):
    """s1とs2がアナグラムかを全順列で確認"""
    from itertools import permutations
    if len(s1) != len(s2):
        return False
    for perm in permutations(s1):
        if ''.join(perm) == s2:
            return True
    return False
# 計算量: O(n! × n) — 非常に非効率！

# 改善版: ソートで比較
def is_anagram_sort(s1, s2):
    return sorted(s1) == sorted(s2)
# 計算量: O(n log n) — 大幅に改善

# さらに改善: ハッシュマップで比較
from collections import Counter
def is_anagram_hash(s1, s2):
    return Counter(s1) == Counter(s2)
# 計算量: O(n) — 最適

# → 全探索は出発点。ここから効率の良い方法を考える。
```

### 2.3 分割統治法

```python
# 分割統治法: 問題を小さく分割→各個解決→結合
# 3つのステップ: Divide → Conquer → Combine

# 代表例1: マージソート
def merge_sort(arr):
    """分割→ソート→結合"""
    if len(arr) <= 1:
        return arr

    # Divide: 半分に分割
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])    # Conquer
    right = merge_sort(arr[mid:])   # Conquer

    # Combine: マージ
    return merge(left, right)

def merge(left, right):
    result = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            result.append(left[i])
            i += 1
        else:
            result.append(right[j])
            j += 1
    result.extend(left[i:])
    result.extend(right[j:])
    return result
# T(n) = 2T(n/2) + O(n) → O(n log n)

# 代表例2: 最近点対問題
def closest_pair(points):
    """2次元平面上のn個の点から最も近い2点を見つける

    全探索: O(n²) — 全ペアを調べる
    分割統治: O(n log n)

    1. x座標でソート
    2. 中央で左右に分割
    3. 左右それぞれで最近点対を再帰的に求める
    4. 左右にまたがるペアも確認（ストリップ領域）
    5. 最小を返す
    """
    # 詳細な実装は省略（概念の説明が目的）
    pass

# 代表例3: カラツバ法（高速乗算）
def karatsuba(x, y):
    """通常のO(n²)をO(n^1.585)に改善する乗算"""
    if x < 10 or y < 10:
        return x * y

    n = max(len(str(x)), len(str(y)))
    m = n // 2

    # x = a * 10^m + b
    # y = c * 10^m + d
    a, b = divmod(x, 10**m)
    c, d = divmod(y, 10**m)

    # 3回の再帰（通常は4回）
    ac = karatsuba(a, c)
    bd = karatsuba(b, d)
    ad_bc = karatsuba(a + b, c + d) - ac - bd

    return ac * 10**(2*m) + ad_bc * 10**m + bd
# T(n) = 3T(n/2) + O(n) → O(n^log₂3) ≈ O(n^1.585)
# → 4回の乗算を3回に減らしたのがポイント

# 分割統治が有効な条件:
# 1. 問題を同じ種類の小さい問題に分割できる
# 2. 小さい問題を独立に解ける
# 3. 部分解を効率的に結合できる
# 4. 基底ケースが自明に解ける
```

### 2.4 動的計画法（DP）

```python
# 動的計画法: 部分問題の解を記憶して再利用
# 2つの条件:
# 1. 最適部分構造: 最適解が部分問題の最適解から構成される
# 2. 重複部分問題: 同じ部分問題が繰り返し現れる

# 典型例: フィボナッチ数列

# ❌ 素朴な再帰: O(2^n) — 同じ計算を何度も繰り返す
def fib_naive(n):
    if n <= 1:
        return n
    return fib_naive(n-1) + fib_naive(n-2)

# 再帰ツリー（n=5の場合）:
#                fib(5)
#              /        \
#           fib(4)      fib(3)
#          /    \       /    \
#       fib(3) fib(2) fib(2) fib(1)
#       /  \
#    fib(2) fib(1)
# → fib(2)が3回、fib(3)が2回計算される！

# ✅ メモ化（トップダウンDP）: O(n)
def fib_memo(n, memo={}):
    if n in memo:
        return memo[n]
    if n <= 1:
        return n
    memo[n] = fib_memo(n-1, memo) + fib_memo(n-2, memo)
    return memo[n]

# ✅ テーブル（ボトムアップDP）: O(n)
def fib_table(n):
    if n <= 1:
        return n
    dp = [0] * (n + 1)
    dp[1] = 1
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]

# ✅ 空間最適化: O(n) 時間, O(1) 空間
def fib_optimal(n):
    if n <= 1:
        return n
    a, b = 0, 1
    for _ in range(2, n + 1):
        a, b = b, a + b
    return b

# DPの実用例: ナップサック問題
def knapsack(weights, values, capacity):
    """重さ制限内で価値を最大化する"""
    n = len(weights)
    # dp[i][w] = 最初のi個のアイテムで重さw以内の最大価値
    dp = [[0] * (capacity + 1) for _ in range(n + 1)]

    for i in range(1, n + 1):
        for w in range(capacity + 1):
            # アイテムiを入れない場合
            dp[i][w] = dp[i-1][w]
            # アイテムiを入れる場合
            if weights[i-1] <= w:
                dp[i][w] = max(dp[i][w],
                    dp[i-1][w - weights[i-1]] + values[i-1])

    return dp[n][capacity]
# 計算量: O(n × capacity)
```

### 2.5 貪欲法

```python
# 貪欲法: 各ステップで「その時点での最善」を選ぶ
# 長所: 高速、実装が簡単
# 短所: 必ずしも最適解が得られない

# 貪欲法で最適解が得られる例:

# 1. 活動選択問題
def activity_selection(activities):
    """重ならない最大数の活動を選択
    activities = [(start, end), ...]
    """
    # 終了時刻でソート（貪欲の選択基準）
    sorted_activities = sorted(activities, key=lambda x: x[1])

    selected = [sorted_activities[0]]
    for activity in sorted_activities[1:]:
        if activity[0] >= selected[-1][1]:  # 重なっていない
            selected.append(activity)

    return selected
# 計算量: O(n log n) (ソート) + O(n) = O(n log n)
# → 貪欲法で最適解が得られることが証明されている

# 2. ハフマン符号化
import heapq
def huffman_encoding(freq):
    """文字の出現頻度から最適な可変長符号を生成

    例: {'a': 5, 'b': 9, 'c': 12, 'd': 13, 'e': 16, 'f': 45}
    """
    # 最小ヒープを構築
    heap = [(f, c) for c, f in freq.items()]
    heapq.heapify(heap)

    while len(heap) > 1:
        # 最小の2つを取り出して結合（貪欲な選択）
        freq1, node1 = heapq.heappop(heap)
        freq2, node2 = heapq.heappop(heap)
        heapq.heappush(heap, (freq1 + freq2, (node1, node2)))

    return heap[0]
# → 最適な接頭符号が得られる（情報理論で証明済み）

# 貪欲法で最適解が得られない例:

# お釣り問題（特殊な硬貨体系）
# 硬貨: [1, 3, 4]、お釣り: 6
# 貪欲法: 4 + 1 + 1 = 3枚
# 最適解: 3 + 3 = 2枚！
# → この場合はDPが必要

# 貪欲法が使える条件:
# 1. 貪欲選択性質: 局所最適な選択が大局最適につながる
# 2. 最適部分構造: 残りの部分問題も同じ方法で解ける
# → この2つを証明する必要がある
```

### 2.6 バックトラッキング

```python
# バックトラッキング: 探索 + 行き詰まったら戻る
# 「系統的な試行錯誤」

# 典型例1: N-Queens問題
def solve_n_queens(n):
    """N×Nチェスボードにn個のクイーンを互いに攻撃し合わないように配置"""
    solutions = []
    board = [-1] * n  # board[row] = col

    def is_safe(row, col):
        for prev_row in range(row):
            prev_col = board[prev_row]
            # 同じ列または対角線上にないか確認
            if prev_col == col or \
               abs(prev_col - col) == abs(prev_row - row):
                return False
        return True

    def backtrack(row):
        if row == n:
            solutions.append(board[:])
            return

        for col in range(n):
            if is_safe(row, col):
                board[row] = col        # 選択
                backtrack(row + 1)      # 探索
                board[row] = -1         # 元に戻す（バックトラック）

    backtrack(0)
    return solutions

# 8-Queens: 解は92通り（回転・反転を区別する場合）
# 計算量: 最悪 O(n!)、枝刈りで大幅に削減

# 典型例2: 数独ソルバー
def solve_sudoku(board):
    """9×9の数独を解く"""
    def find_empty():
        for i in range(9):
            for j in range(9):
                if board[i][j] == 0:
                    return (i, j)
        return None

    def is_valid(num, pos):
        row, col = pos
        # 行チェック
        if num in board[row]:
            return False
        # 列チェック
        if num in [board[i][col] for i in range(9)]:
            return False
        # 3×3ボックスチェック
        box_row, box_col = 3 * (row // 3), 3 * (col // 3)
        for i in range(box_row, box_row + 3):
            for j in range(box_col, box_col + 3):
                if board[i][j] == num:
                    return False
        return True

    empty = find_empty()
    if not empty:
        return True  # 全マス埋まった → 完成

    row, col = empty
    for num in range(1, 10):
        if is_valid(num, (row, col)):
            board[row][col] = num       # 選択
            if solve_sudoku(board):     # 探索
                return True
            board[row][col] = 0         # バックトラック

    return False  # この状態からは解なし
```

### 2.7 問題解決のフレームワーク

```
問題→アルゴリズム→コードの思考プロセス:

  ステップ1: 問題を理解する
  ─────────────────────────
  - 入力は何か？出力は何か？
  - 制約条件は？（データサイズ、時間制限）
  - エッジケースは？

  ステップ2: 手作業で例を解く
  ─────────────────────────
  - 具体的な小さい例で手を動かす
  - パターンを見つける
  - 自分がどういう手順で解いているか意識する

  ステップ3: アルゴリズムを設計する
  ─────────────────────────
  - 手順を言葉で書き出す
  - 計算量を見積もる
  - もっと良い方法がないか検討する

  ステップ4: コードに変換する
  ─────────────────────────
  - 擬似コード → 実際のコード
  - エッジケースの処理を追加

  ステップ5: テストと検証
  ─────────────────────────
  - 正常系: 基本的な入力
  - 境界値: 空、1要素、最大値
  - 異常系: 不正な入力
```

```
設計戦略の選択フローチャート:

  問題を見たとき → まず全探索を考える（O(n!)? O(2^n)?）

  制約を確認:
  ├─ n ≤ 10      → 全探索でOK
  ├─ n ≤ 20      → ビット全探索、バックトラック
  ├─ n ≤ 500     → O(n³) DP
  ├─ n ≤ 5000    → O(n²) DP、全ペア
  ├─ n ≤ 10^6    → O(n log n) ソート+二分探索、分割統治
  └─ n ≤ 10^8    → O(n) 線形走査、貪欲法

  問題の性質を確認:
  ├─ 最適化問題（最大/最小）
  │   ├─ 部分問題に分解可能 → DP
  │   ├─ 局所最適=大域最適が証明可能 → 貪欲法
  │   └─ 答えの二分探索が可能 → 二分探索 + 判定関数
  ├─ 探索問題（存在するか/列挙）
  │   ├─ グラフ/ツリー構造 → BFS/DFS
  │   ├─ 制約充足 → バックトラック
  │   └─ 全パターン列挙 → 再帰/ビット全探索
  └─ 変換問題（AをBに変換）
      ├─ 最小手数 → BFS
      └─ 可能性の判定 → DFS/DP
```

### 2.8 具体例: 配列の最大値を見つける

```python
# 問題: 配列の中で最大の値を見つける
# 入力: 整数の配列 (空でない)
# 出力: 最大の値

# 方法1: 全探索（ブルートフォース）
def find_max_brute(arr):
    """全ての要素を1つずつ確認"""
    max_val = arr[0]
    for i in range(1, len(arr)):
        if arr[i] > max_val:
            max_val = arr[i]
    return max_val
# 計算量: O(n) — これ以上改善できない（全要素を見る必要がある）

# 方法2: 分割統治
def find_max_divide(arr, left, right):
    """配列を半分に分割して各最大値を比較"""
    if left == right:
        return arr[left]
    mid = (left + right) // 2
    left_max = find_max_divide(arr, left, mid)
    right_max = find_max_divide(arr, mid + 1, right)
    return max(left_max, right_max)
# 計算量: O(n) — 同じだが、並列化に適している

# 方法3: Python組み込み
max_val = max(arr)  # 内部的に方法1と同じ O(n)

# この問題ではO(n)が最適（下界）
# → 全ての要素を少なくとも1回は見なければ最大値は分からない
# → これを「情報理論的下界」と呼ぶ
```

### 2.9 具体例: 二数の合計問題（Two Sum）

```python
# 問題: 配列から合計が target になる2つの要素のインデックスを返す
# 入力: nums = [2, 7, 11, 15], target = 9
# 出力: [0, 1] (nums[0] + nums[1] = 2 + 7 = 9)

# 方法1: 全探索 O(n²)
def two_sum_brute(nums, target):
    """全てのペアを試す"""
    n = len(nums)
    for i in range(n):
        for j in range(i + 1, n):
            if nums[i] + nums[j] == target:
                return [i, j]
    return []

# 方法2: ハッシュマップ O(n)
def two_sum_hash(nums, target):
    """見た値を記録して補数を探す"""
    seen = {}  # 値 → インデックス
    for i, num in enumerate(nums):
        complement = target - num
        if complement in seen:
            return [seen[complement], i]
        seen[num] = i
    return []

# 方法3: ソート + 二分探索 O(n log n)
def two_sum_sort(nums, target):
    """ソートして両端から探す"""
    indexed = sorted(enumerate(nums), key=lambda x: x[1])
    left, right = 0, len(indexed) - 1
    while left < right:
        total = indexed[left][1] + indexed[right][1]
        if total == target:
            return [indexed[left][0], indexed[right][0]]
        elif total < target:
            left += 1
        else:
            right -= 1
    return []

# 比較:
# ┌─────────────┬───────────┬───────────┬────────────────┐
# │ 方法        │ 時間      │ 空間      │ 備考            │
# ├─────────────┼───────────┼───────────┼────────────────┤
# │ 全探索      │ O(n²)    │ O(1)     │ 最も単純        │
# │ ハッシュ    │ O(n)     │ O(n)     │ 最速、空間と引替│
# │ ソート+二分 │ O(n log n)│ O(n)     │ 中間的な選択    │
# └─────────────┴───────────┴───────────┴────────────────┘

# → 要件に応じて最適な方法を選択する
# - 速度重視 → ハッシュマップ
# - メモリ制約 → 全探索（インデックス不要なら方法3）
# - 複数回の検索 → ソート（前処理の後、各検索はO(log n)）
```

---

## 3. アルゴリズムの正しさの証明

### 3.1 ループ不変条件

```python
# ループ不変条件（Loop Invariant）:
# ループの各反復の前に成り立つ性質

def insertion_sort(arr):
    """挿入ソート"""
    for i in range(1, len(arr)):
        # ループ不変条件: arr[0:i] はソート済み
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
        # ループ不変条件: arr[0:i+1] はソート済み
    # 終了時: i = len(arr) なので arr[0:len(arr)] がソート済み ✓

# ループ不変条件の3つの性質:
# 1. 初期化: ループ開始前に成り立つ（arr[0:1]は自明にソート済み）
# 2. 維持:   反復のたびに維持される（各ステップでソート範囲が拡大）
# 3. 終了:   ループ終了時に目的の性質が成り立つ（全体がソート済み）
```

```python
# もう一つの例: 線形探索の正しさの証明

def linear_search(arr, target):
    """線形探索"""
    for i in range(len(arr)):
        # ループ不変条件: arr[0:i] に target は存在しない
        if arr[i] == target:
            return i
    # 終了時: arr[0:len(arr)] に target は存在しない
    return -1

# 証明:
# 初期化: i=0 の時、arr[0:0]（空集合）に target はない → 自明に成立 ✓
# 維持: 反復 i で arr[i] != target なら、arr[0:i+1] にも target はない
#        → 不変条件が i+1 でも成立 ✓
# 終了: i = len(arr) なら arr 全体に target がないことが証明済み
#        return -1 は正しい ✓
#        途中で arr[i] == target を見つけたら return i も正しい ✓
```

### 3.2 再帰の正しさ — 帰納法

```python
# 数学的帰納法によるアルゴリズムの正しさの証明

def factorial(n):
    """n! を再帰的に計算"""
    if n <= 1:    # 基底ケース
        return 1
    return n * factorial(n - 1)  # 再帰ケース

# 証明:
# 基底ケース: n=0, n=1 の時、1を返す → 0!=1, 1!=1 ✓
# 帰納ステップ:
#   factorial(k) = k! が正しいと仮定する（帰納法の仮定）
#   factorial(k+1) = (k+1) * factorial(k) = (k+1) * k! = (k+1)! ✓
# よって全ての n≥0 に対して factorial(n) = n! ✓
```

```python
# より複雑な例: マージソートの正しさの証明

def merge_sort(arr):
    if len(arr) <= 1:
        return arr  # 基底ケース
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)

# 証明（強帰納法）:
#
# 命題: 長さnの任意の配列に対して、merge_sort(arr)は
#        arrと同じ要素を持つソート済み配列を返す
#
# 基底ケース: n=0 または n=1
#   → 配列はそのまま返される → 自明にソート済み ✓
#
# 帰納ステップ: n>1 として、n未満の全ての入力で正しいと仮定
#   1. arr[:mid] の長さは n/2 < n → 帰納法の仮定より left はソート済み
#   2. arr[mid:] の長さは n-n/2 < n → 帰納法の仮定より right はソート済み
#   3. merge(left, right):
#      - left, right は共にソート済み
#      - merge は各ステップで小さい方を選ぶ
#      - → 結果はソート済み ✓
#      - 要素は追加も削除もされない
#      - → 元の要素が全て含まれる ✓
#
# よって全ての n≥0 に対して merge_sort は正しい ✓
```

### 3.3 背理法による正しさの証明

```python
# 背理法: 仮に正しくないと仮定して矛盾を導く

# 例: ダイクストラ法の正しさ（概略）
#
# 命題: ダイクストラ法は非負重みグラフの最短経路を正しく求める
#
# 証明（概略）:
# 背理法として、ダイクストラ法が最初に間違った最短距離を
# 確定するノード v が存在すると仮定する
#
# d[v] = ダイクストラが求めた距離
# δ(v) = 真の最短距離
# 仮定より d[v] > δ(v)
#
# 真の最短経路 s → ... → u → v を考える
# u は v の直前のノード
#
# u は v より先に処理されているので d[u] = δ(u)（v が「最初の」間違い）
# d[v] ≤ d[u] + w(u,v)  （ダイクストラの緩和操作より）
#      = δ(u) + w(u,v)   （d[u] = δ(u) より）
#      = δ(v)            （u→v は最短経路の一部より）
#
# よって d[v] ≤ δ(v) だが、d[v] ≥ δ(v) は自明
# → d[v] = δ(v) で矛盾！
#
# よってダイクストラ法は正しい ✓
```

---

## 4. アルゴリズムの分類

### 4.1 問題の種類別

```
問題の分類とアルゴリズム:

  ┌─────────────┬──────────────────┬─────────────────┐
  │ 問題の種類   │ 代表的アルゴリズム │ 実務での例       │
  ├─────────────┼──────────────────┼─────────────────┤
  │ 探索        │ 二分探索, ハッシュ │ DB検索, 辞書引き │
  │ ソート      │ クイックソート,    │ ランキング,      │
  │             │ マージソート       │ データ整理       │
  │ グラフ      │ BFS, DFS,        │ 経路探索,        │
  │             │ ダイクストラ       │ SNSの友達推薦    │
  │ 文字列      │ KMP, Rabin-Karp  │ 全文検索,        │
  │             │                  │ テキストエディタ  │
  │ 最適化      │ DP, 貪欲法       │ スケジューリング, │
  │             │                  │ リソース配分     │
  │ 数値計算    │ ニュートン法,     │ 科学シミュレーション│
  │             │ FFT              │ 信号処理         │
  │ 暗号        │ RSA, AES,        │ HTTPS,          │
  │             │ SHA-256          │ 電子署名         │
  │ 機械学習    │ 勾配降下法,       │ 推薦,           │
  │             │ 逆伝播           │ 画像認識         │
  └─────────────┴──────────────────┴─────────────────┘
```

### 4.2 計算可能性の観点から

```
問題の難しさの分類:

  ┌──────────────────────────────────────────────────┐
  │ P（Polynomial）: 多項式時間で解ける問題            │
  │ 例: ソート O(n log n)、最短経路 O(V+E)            │
  │                                                   │
  │ NP: 「解の検証」が多項式時間で可能な問題            │
  │ 例: 巡回セールスマン問題の解は検証は簡単（O(n)）   │
  │     だが「求める」のは困難                         │
  │                                                   │
  │ NP困難: NP以上に難しい問題                         │
  │ NP完全: NPかつNP困難                               │
  │                                                   │
  │ 未解決問題: P = NP か P ≠ NP か？                  │
  │ → CS最大の未解決問題（100万ドルのミレニアム賞金問題）│
  └──────────────────────────────────────────────────┘

  実務への影響:
  ┌──────────┬───────────────┬──────────────────────┐
  │ 分類     │ 意味          │ 対処法                │
  ├──────────┼───────────────┼──────────────────────┤
  │ P       │ 効率的に解ける │ そのまま実装          │
  │ NP完全  │ 効率解は多分   │ 近似アルゴリズム、     │
  │          │ 見つからない  │ ヒューリスティック    │
  │ 決定不能 │ 解けない      │ 制限を加えて部分解決  │
  └──────────┴───────────────┴──────────────────────┘

  NP完全問題の実例:
  - 巡回セールスマン問題（TSP）: 配送ルート最適化
  - グラフ彩色: スケジューリング、レジスタ割り当て
  - 充足可能性問題（SAT）: 論理回路の検証
  - ナップサック問題: リソース割り当て
  - ハミルトン路: 回路設計

  NP完全と分かったら:
  1. 入力サイズが小さいなら全探索でOK
  2. 近似アルゴリズム（最適の1.5倍以内の保証等）
  3. ヒューリスティック（遺伝的アルゴリズム、焼きなまし法）
  4. 特殊ケースを見つける（制約の追加で P になる場合）
```

### 4.3 実務で頻出するアルゴリズムパターン

```
実務でよく使うアルゴリズムパターン:

  1. 二分探索パターン
  ┌──────────────────────────────────────┐
  │ 場面: ソート済みデータでの検索         │
  │ 例: APIレート制限の閾値検索            │
  │     バージョン管理でのバグ導入コミット  │
  │     設定値の最適パラメータ探索         │
  └──────────────────────────────────────┘

  2. ハッシュマップパターン
  ┌──────────────────────────────────────┐
  │ 場面: O(1)ルックアップが必要           │
  │ 例: キャッシュ、重複排除              │
  │     カウンティング、グルーピング       │
  │     Two Sum のような探索最適化        │
  └──────────────────────────────────────┘

  3. スタック/キューパターン
  ┌──────────────────────────────────────┐
  │ 場面: 順序制約のある処理               │
  │ 例: 括弧の整合性チェック              │
  │     タスクのスケジューリング           │
  │     BFS/DFS                          │
  └──────────────────────────────────────┘

  4. 二ポインタ/スライディングウィンドウ
  ┌──────────────────────────────────────┐
  │ 場面: 配列/文字列の部分列処理          │
  │ 例: 連続部分配列の最大和              │
  │     重複なしの最長部分文字列          │
  │     マージ操作                        │
  └──────────────────────────────────────┘

  5. グラフ探索パターン
  ┌──────────────────────────────────────┐
  │ 場面: 関係性の探索                     │
  │ 例: 依存関係の解決（ビルド順序）       │
  │     ソーシャルグラフの分析            │
  │     到達可能性の判定                  │
  └──────────────────────────────────────┘

  6. DPパターン
  ┌──────────────────────────────────────┐
  │ 場面: 最適化問題                       │
  │ 例: 最長共通部分列（diff）            │
  │     編集距離（あいまい検索）           │
  │     経路数のカウント                  │
  └──────────────────────────────────────┘
```

---

## 5. 擬似コードの書き方

### 5.1 擬似コードの記法

```
擬似コード（Pseudocode）:
  特定のプログラミング言語に依存しない、
  アルゴリズムの手順を自然言語に近い形で記述したもの

基本的な記法:
  ┌──────────────────────────────────────────┐
  │ ■ 代入:       x ← 値                     │
  │ ■ 条件分岐:   if 条件 then ... else ...   │
  │ ■ ループ:     for i ← 1 to n do ...      │
  │               while 条件 do ...           │
  │ ■ 配列:       A[i] で i番目の要素          │
  │ ■ 関数:       function 名前(引数) → 戻り値│
  │ ■ コメント:   // この行はコメント          │
  │ ■ 入力:       read(x)                     │
  │ ■ 出力:       print(x)                    │
  │ ■ 戻り値:     return 値                   │
  └──────────────────────────────────────────┘

例: 二分探索の擬似コード

  function BINARY-SEARCH(A, target)
    left ← 0
    right ← length(A) - 1

    while left ≤ right do
      mid ← ⌊(left + right) / 2⌋

      if A[mid] = target then
        return mid
      else if A[mid] < target then
        left ← mid + 1
      else
        right ← mid - 1

    return -1  // not found
```

### 5.2 擬似コードからコードへの変換

```python
# 擬似コードをPython、Java、Go、TypeScriptに変換する例

# 擬似コード:
# function GCD(a, b)
#   while b ≠ 0 do
#     temp ← b
#     b ← a mod b
#     a ← temp
#   return a

# Python:
def gcd(a: int, b: int) -> int:
    while b != 0:
        a, b = b, a % b
    return a
```

```java
// Java:
public static int gcd(int a, int b) {
    while (b != 0) {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

```go
// Go:
func gcd(a, b int) int {
    for b != 0 {
        a, b = b, a%b
    }
    return a
}
```

```typescript
// TypeScript:
function gcd(a: number, b: number): number {
    while (b !== 0) {
        [a, b] = [b, a % b];
    }
    return a;
}
```

---

## 6. アルゴリズムの評価基準

### 6.1 時間計算量以外の評価基準

```
アルゴリズムの評価基準（包括的）:

  1. 時間計算量（Time Complexity）
     → 入力サイズに対する実行時間の成長率
     → 最悪 / 平均 / 最良ケース

  2. 空間計算量（Space Complexity）
     → 追加で必要なメモリ量
     → 入力データ自体を含めるか含めないか注意

  3. 正しさ（Correctness）
     → 全ての有効な入力に対して正しい出力を返すか
     → 証明方法: ループ不変条件、帰納法、背理法

  4. 安定性（Stability）
     → ソートアルゴリズム特有: 同値要素の相対順序を保持するか

  5. 適応性（Adaptivity）
     → 入力の特性（ほぼソート済み等）に応じて性能が改善するか
     → 例: 挿入ソートはほぼソート済みデータに O(n)

  6. オンライン性（Online）
     → データが逐次到着しても処理できるか
     → 例: 挿入ソートはオンライン、マージソートはオフライン

  7. 並列化可能性（Parallelizability）
     → マルチコア/GPUで効率的に並列化できるか
     → 例: マージソートは並列化に適する

  8. キャッシュ効率（Cache Efficiency）
     → CPUキャッシュを効率的に利用できるか
     → 例: クイックソートはキャッシュ効率が良い

  9. 実装の容易さ（Simplicity）
     → コードの複雑さ、バグの入りやすさ
     → 実務では重要な考慮点

  10. 定数倍の小ささ（Constant Factor）
      → Big-O が同じでも定数倍で実際の速度が異なる
      → 例: O(n) でも 2n と 100n では50倍の差
```

### 6.2 アルゴリズム選択の実務的判断

```
実務でのアルゴリズム選択の指針:

  ┌──────────────────────────────────────────────┐
  │ まず動くものを作れ。次に正しくしろ。           │
  │ 最後に速くしろ。                               │
  │                           — Kent Beck           │
  └──────────────────────────────────────────────┘

  1. 「十分に速い」を定義する
     - Webアプリ: 200ms以内のレスポンス
     - バッチ処理: SLA内で完了すること
     - リアルタイム: 16ms以内（60fps）

  2. 「最適なアルゴリズム」が最善とは限らない
     - n=100の時、O(n²)とO(n log n)の差は軽微
     - 読みやすさ・保守性も重要な評価基準
     - 標準ライブラリの実装を使えるなら使う

  3. プロファイリングしてからの最適化
     - 推測ではなく計測で判断（premature optimizationの回避）
     - ボトルネックを特定してから改善

  4. トレードオフの意識
     - 時間 vs 空間
     - 正確性 vs 速度
     - 実装コスト vs 性能改善

  判断フロー:
  ┌──────────────────────────────────────┐
  │ 1. 標準ライブラリに実装はあるか？      │
  │    → Yes → 使う                       │
  │    → No → 2へ                         │
  │                                       │
  │ 2. 最も単純な実装で十分速いか？         │
  │    → Yes → 使う                       │
  │    → No → 3へ                         │
  │                                       │
  │ 3. ボトルネックは計算量か定数倍か？     │
  │    → 計算量 → より良いアルゴリズムを選択│
  │    → 定数倍 → キャッシュ最適化等       │
  └──────────────────────────────────────┘
```

---

## 7. 実践演習

### 演習1: 日常のアルゴリズム（基礎）
以下の日常作業をアルゴリズムとして記述せよ（5条件を満たすように）:
1. 本棚で特定の本を探す
2. トランプを並べ替える
3. 自動販売機でお釣りを出すプロセス

### 演習2: 問題解決プロセス（応用）
「配列から重複する要素を全て取り除く」問題を、3つの異なる方法で解き、各計算量を比較せよ。

### 演習3: 設計戦略の選択（応用）
以下の各問題に最も適したアルゴリズム設計戦略を選び、理由と共に擬似コードを書け:
1. N人の中からK人を選ぶ全ての組み合わせを列挙
2. 連続する部分配列の中で最大の合計値を求める
3. グラフの全ての頂点を訪問する最短ルート（TSP）

### 演習4: 正しさの証明（発展）
二分探索アルゴリズムの正しさをループ不変条件を用いて証明せよ。ループ不変条件として「targetが配列に存在するならば、arr[left]〜arr[right]の範囲内に存在する」を使用せよ。

### 演習5: アルゴリズムの比較（発展）
同じ問題を3つの異なる設計戦略（全探索、DP、貪欲法）で解き、それぞれの利点・欠点を実測データと共に報告せよ。問題例: コイン問題（最少枚数で目標金額を作る）。

---

## FAQ

### Q1: アルゴリズムとデータ構造の関係は？
**A**: 密接に関連している。適切なデータ構造を選ぶことでアルゴリズムの効率が劇的に変わる。例: 探索→配列(O(n)) vs ハッシュテーブル(O(1))。「アルゴリズム + データ構造 = プログラム」（Wirth, 1976）。データ構造は「情報の整理方法」、アルゴリズムは「情報の処理手順」であり、車の両輪のような関係。

### Q2: アルゴリズムを学ぶとどんな実務に役立ちますか？
**A**: 直接的にはパフォーマンス最適化、システム設計、コーディング面接。間接的には問題分解力、論理的思考力、「計算量の感覚」が身につき、日常的なコーディングの質が向上する。具体例: データベースのインデックス設計にはB-Treeの知識が、キャッシュ戦略にはLRUアルゴリズムの知識が、検索機能の実装には文字列マッチングの知識が不可欠。

### Q3: 全てのアルゴリズムを暗記する必要がありますか？
**A**: いいえ。重要なのは「設計パターン」と「計算量の感覚」を身につけること。具体的な実装は必要な時に調べればよい。ただし基本的なソート・探索・グラフアルゴリズムは理解しておくべき。暗記ではなく「この問題にはどのパターンが使えそうか」を判断できる力が重要。

### Q4: アルゴリズムの問題が解けない時はどうすればよいですか？
**A**: いくつかのアプローチがある。(1) まず手作業で小さい例を解いてみる。(2) 問題を簡略化して解いてみる（制約を緩める）。(3) 似た問題に帰着できないか考える。(4) 逆から考える（出力から入力を逆算）。(5) 計算量の目標から逆算して使えるアルゴリズムを絞る。(6) 一度離れて別のことをする（脳の潜在的処理に任せる）。

### Q5: 競技プログラミングと実務でのアルゴリズムは違いますか？
**A**: 根本的には同じだが、重点が異なる。競技プログラミングは計算量の最適化と実装速度が重視される。実務では可読性、保守性、テスト容易性も重要。また実務では既存ライブラリの活用、チーム開発、段階的な改善が現実的なアプローチ。ただし競技プログラミングで鍛えたアルゴリズム思考力は実務でも大いに役立つ。

---

## まとめ

| 概念 | ポイント |
|------|---------|
| 定義 | 有限の明確な手順で問題を解く計算手続き |
| 5条件 | 入力、出力、明確性、有限性、有効性 |
| 設計戦略 | 全探索、分割統治、DP、貪欲法、バックトラック、二分探索、グラフ探索 |
| 正しさ | ループ不変条件、数学的帰納法、背理法で証明 |
| 思考法 | 理解→手計算→設計→実装→テスト |
| 分類 | P、NP、NP完全による問題の難しさの分類 |
| 実務 | 正しさ→可読性→性能の順で最適化 |

---

## 次に読むべきガイド
→ [[01-complexity-analysis.md]] — 計算量解析（Big-O記法）

---

## 参考文献
1. Cormen, T. H. et al. "Introduction to Algorithms (CLRS)." 4th Edition, MIT Press, 2022.
2. Knuth, D. E. "The Art of Computer Programming." Addison-Wesley, 1968-2022.
3. Skiena, S. S. "The Algorithm Design Manual." 3rd Edition, Springer, 2020.
4. Sedgewick, R. & Wayne, K. "Algorithms." 4th Edition, Addison-Wesley, 2011.
5. Kleinberg, J. & Tardos, E. "Algorithm Design." Pearson, 2005.
6. Garey, M. R. & Johnson, D. S. "Computers and Intractability: A Guide to the Theory of NP-Completeness." W.H. Freeman, 1979.
