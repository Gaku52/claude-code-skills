# コンピューティングの歴史

> 計算機の歴史は人類の「自動化への渇望」の歴史であり、現代のソフトウェア開発はその最新表現にすぎない。

## この章で学ぶこと

- [ ] 計算機の発展を5つの世代に分けて説明できる
- [ ] 各時代の革新がもたらした影響を理解する
- [ ] 現代技術の歴史的位置づけを説明できる
- [ ] プログラミング言語の進化の系譜を辿れる
- [ ] 技術のハイプサイクルを理解し、新技術を冷静に評価できる

## 前提知識

- 不要（本ガイドは歴史を通じてCSの必要性を理解するための章）

---

## 1. 機械式計算機時代（紀元前〜1940年代）

### 1.1 そろばん — 最古の計算ツール

人類初の計算支援装置は **そろばん（アバカス）** である。紀元前2700年頃のメソポタミアに起源を持ち、中国（算盤）、日本（そろばん）、ロシア（スチョーティ）など世界各地で独自に発展した。

そろばんは「位取り記数法」を物理的に体現する道具であり、現代のコンピュータにおけるレジスタの概念的な祖先と言える。

```
そろばんの仕組み（十進数 1,234 の表現）:

    千  百  十  一
    ┃   ┃   ┃   ┃
  ──●───○───○───○── ← 五珠（5の位）
    ┃   ┃   ┃   ┃
  ──○───●───○───○──
  ──○───●───●───●── ← 一珠（1の位）
  ──○───○───●───●──
  ──○───○───○───●──
    ┃   ┃   ┃   ┃
  ══╋═══╋═══╋═══╋══ ← 梁（はり）

  ● = 使用中の珠  ○ = 未使用の珠
  千=1, 百=2, 十=3, 一=4 → 1,234
```

そろばんの優れた点は、単なる計算ツールにとどまらず、「計算のアルゴリズム」を体現していることである。加算時の繰り上がり処理は、現代のCPUにおけるキャリーフラグ（Carry Flag）と同じ概念である。

### 1.2 パスカリーヌ（1642年）

**ブレーズ・パスカル**が17歳で設計した機械式計算機。歯車の連動により加減算を自動化した。税務官だった父の計算作業を助けるために作られた — 技術革新の動機が「面倒な作業の自動化」であることは、現代のソフトウェア開発と全く同じである。

パスカリーヌの仕組み:
- 10歯の歯車が各桁を表現
- 1つの歯車が1回転（0→9→0）すると、次の桁の歯車が1歯分進む（繰り上がり）
- この機構は現代のハードウェアカウンタの原理と同一

### 1.3 ライプニッツの計算機（1694年）

**ゴットフリート・ライプニッツ**がパスカリーヌを改良し、**乗除算にも対応**。ステップドラム機構を発明した。ライプニッツはまた**二進法の体系化**を行い、これが後のコンピュータの数値表現の基盤となる。

ライプニッツの二進法に関する洞察:

```
ライプニッツの二進法（1703年の論文より）:

  十進数   二進数      ライプニッツの表記
    0        0         「無」
    1        1         「有」（神の存在）
    2       10         哲学的に「無から有を創る」
    3       11
    4      100
    5      101
    ...

  ライプニッツは二進法を哲学的・宗教的に解釈したが、
  その数学的正確さは260年後にコンピュータの基盤となった。
  0と1だけで全ての計算が可能 — これこそがデジタルの本質。
```

### 1.4 ジャカードの織機（1804年）

**ジョセフ・マリー・ジャカール**が発明したパンチカード式自動織機は、CSの歴史において重要な位置を占める。穴の有無（0/1）で織りパターンをプログラムする仕組みは、**データとプログラムの分離**という概念の萌芽である。

```
ジャカード織機のパンチカード:

  ┌─────────────────────┐
  │ ○ ● ○ ● ● ○ ● ○   │  ○ = 穴あり（縦糸を上げる）
  │ ● ○ ● ○ ○ ● ○ ●   │  ● = 穴なし（縦糸を下げる）
  │ ○ ○ ● ● ○ ○ ● ●   │
  │ ● ● ○ ○ ● ● ○ ○   │  カードを差し替えるだけで
  │ ○ ● ● ○ ● ○ ○ ●   │  異なるパターンを織れる
  └─────────────────────┘  → 「プログラムの交換」と同じ概念

  このアイデアは後にバベッジの解析機関、
  IBMのパンチカードシステムへと受け継がれる。
```

### 1.5 バベッジの解析機関（1837年設計）

**チャールズ・バベッジ**の**解析機関（Analytical Engine）** は、完成こそしなかったが、現代のコンピュータの設計原理を先取りした驚異的な構想である:

| 解析機関の構成要素 | 現代の対応物 |
|------------------|------------|
| ミル（Mill） | CPU（演算装置） |
| ストア（Store） | メモリ |
| パンチカード入力 | プログラム入力 |
| 条件分岐 | if文 |
| ループ | forループ |
| プリンタ出力 | 出力装置 |

**エイダ・ラブレス**（バイロン卿の娘）は解析機関のためのアルゴリズム（ベルヌーイ数の計算）を記述し、**世界初のプログラマー**と呼ばれる。プログラミング言語Adaは彼女にちなんで名付けられた。

エイダ・ラブレスの先見性は特筆に値する。彼女は解析機関が「数以外のもの」も操作できることを予見した:

> "The Analytical Engine weaves algebraic patterns, just as the Jacquard loom weaves flowers and leaves."
> （解析機関は代数的パターンを織る。ジャカード織機が花や葉を織るように。）

この洞察は、コンピュータが「汎用的な記号操作機械」であることの最初の認識であり、音楽、画像、テキストの処理への道を開いた。

### 1.6 ブールの論理代数（1854年）

**ジョージ・ブール**が「思考の法則」を出版し、**ブール代数**を体系化した。AND、OR、NOTの論理演算は、現代のデジタル回路とプログラミングの基盤である。

```python
# ブール代数 — 現代プログラミングでの使用例
# 1854年にブールが体系化した論理は、そのまま現代のコードに使われている

# AND（論理積）
is_adult = age >= 18 and has_id == True

# OR（論理和）
can_enter = is_member or has_ticket

# NOT（否定）
is_invalid = not is_valid

# 複合条件（ブール代数の法則がそのまま適用される）
# ド・モルガンの法則: NOT(A AND B) = NOT A OR NOT B
# not (is_admin and is_active) == (not is_admin) or (not is_active)
```

**クロード・シャノンの修士論文（1937年）** がブール代数と電気回路を結びつけた。シャノンは「スイッチのON/OFF」がブール代数の「真/偽」に対応することを示し、これがデジタル回路設計の基盤となった。この修士論文は「20世紀で最も重要な修士論文」と呼ばれることがある。

### 1.7 チューリングの万能計算機（1936年）

**アラン・チューリング**は1936年の論文「On Computable Numbers」で**チューリングマシン**という抽象的な計算モデルを提案した。これはCSの理論的基盤であり、以下を証明した:

1. **万能チューリングマシン**: 任意のチューリングマシンの動作をシミュレートできる機械が存在する → **現代のプログラム内蔵式コンピュータの理論的根拠**
2. **停止問題の決定不能性**: 任意のプログラムが停止するかどうかを判定するアルゴリズムは存在しない → **完璧なバグ検出ツールは原理的に不可能**

```
チューリングマシンの動作モデル:

  ∞ ──┬──┬──┬──┬──┬──┬──┬──┬──┬── ∞
      │  │ 0│ 1│ 1│ 0│ 1│  │  │     ← 無限テープ（メモリ）
  ∞ ──┴──┴──┴──┴──┴──┴──┴──┴──┴── ∞
                  ▲
                  │
            ┌─────┴─────┐
            │  ヘッド    │ ← 読み書きヘッド
            │  状態: q3  │ ← 内部状態（有限個）
            └───────────┘

  動作規則（遷移関数）:
  (現在の状態, 読んだ記号) → (書く記号, ヘッド移動方向, 次の状態)

  例: (q3, 1) → (0, Right, q4)
  「状態q3で1を読んだら、0を書いて右に移動し、状態q4へ」
```

同時期に **アロンゾ・チャーチ** がラムダ計算という別の形式体系を提案し、チューリングマシンと同等の計算能力を持つことが証明された（チャーチ=チューリングの提唱）。ラムダ計算は後にLisp、Haskell、JavaScriptの関数型プログラミングの理論的基盤となった。

```python
# ラムダ計算の影響 — 現代の関数型プログラミング

# チャーチのラムダ計算（1936年）の概念が、
# 現代のプログラミングに直接反映されている

# ラムダ式（無名関数）
square = lambda x: x * x
print(square(5))  # 25

# 高階関数（関数を引数に取る関数）
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x ** 2, numbers))  # [1, 4, 9, 16, 25]

# カリー化（Currying）— ラムダ計算の重要概念
def add(x):
    return lambda y: x + y

add_5 = add(5)
print(add_5(3))  # 8

# これらの概念は1936年のラムダ計算から直接派生している
```

---

## 2. 真空管時代（1940年代〜1950年代）— 第1世代

### 2.1 コロッサス（1943年）

イギリスの**ブレッチリー・パーク**で開発された世界初の電子式プログラマブル計算機。ナチスドイツの暗号機「エニグマ」の解読に使用された。チューリング自身がこの施設で暗号解読に従事していた。

コロッサスの重要性:
- **1,500本の真空管**を使用した電子式計算機
- 秘密指定のため、その存在は1970年代まで公表されず
- 暗号解読という実用的な目的が技術革新を加速した
- 第二次世界大戦の終結を2年以上早めたと推定される

### 2.2 ENIAC（1945年）

**Electronic Numerical Integrator and Computer** — アメリカ初の汎用電子式コンピュータ。

| スペック | ENIAC (1945) | iPhone 15 (2023) |
|---------|-------------|-------------------|
| 重量 | 30トン | 171g |
| 消費電力 | 150kW | ~5W |
| 速度 | 5,000加算/秒 | ~10兆演算/秒 |
| メモリ | 20ワード | 6GB |
| 真空管 | 17,468本 | 0（160億トランジスタ） |
| 床面積 | 167m² | 手のひらサイズ |
| 価格 | 約$500,000 (1945) | $799 (2023) |

→ 約80年間で**2兆倍**の性能向上が手のひらサイズで実現された。

ENIACの運用における教訓:
- **プログラミングは配線変更**: ENIACのプログラム変更には数日かかった。6人の女性プログラマー（Kay McNulty, Betty Jennings, Betty Snyder, Marlyn Meltzer, Fran Bilas, Ruth Lichterman）がこの作業を担当し、後に「ENIAC Girls」として知られた
- **信頼性の問題**: 17,468本の真空管のうち、毎日数本が故障。平均故障間隔（MTBF）は数時間
- **この経験が「プログラム内蔵方式」の必要性を痛感させた**

### 2.3 フォン・ノイマン・アーキテクチャ（1945年）

**ジョン・フォン・ノイマン**が提案した**プログラム内蔵方式**は、現代のほぼ全てのコンピュータの基盤である。

```
フォン・ノイマン・アーキテクチャ:

  ┌─────────────────────────────────────────────┐
  │                                             │
  │  ┌───────────┐        ┌───────────────┐     │
  │  │   CPU     │        │   メモリ       │     │
  │  │ ┌───────┐ │ ←───→  │ ┌───────────┐ │     │
  │  │ │  ALU  │ │  バス   │ │ プログラム │ │     │
  │  │ └───────┘ │        │ │ (命令列)   │ │     │
  │  │ ┌───────┐ │        │ ├───────────┤ │     │
  │  │ │制御部 │ │        │ │ データ     │ │     │
  │  │ └───────┘ │        │ │            │ │     │
  │  │ ┌───────┐ │        │ └───────────┘ │     │
  │  │ │レジスタ│ │        └───────────────┘     │
  │  │ └───────┘ │                               │
  │  └───────────┘                               │
  │       ↕                                      │
  │  ┌───────────┐        ┌───────────────┐     │
  │  │  入力装置 │        │  出力装置      │     │
  │  └───────────┘        └───────────────┘     │
  │                                             │
  └─────────────────────────────────────────────┘

  核心的アイデア:
  ★ プログラム（命令）とデータを同じメモリに格納する
  → プログラムを「データとして」操作できる
  → 自己書き換えプログラム、コンパイラ、インタプリタが可能に
```

**フォン・ノイマン・ボトルネック**: CPUとメモリ間の帯域幅が性能のボトルネックになる問題。現代でもキャッシュ階層やプリフェッチで対処しているが、本質的には解決されていない。

### 2.4 最初のプログラミング — 機械語

```
; EDSAC (1949) のプログラム例 — 2つの数の加算
; 世界初のプログラム内蔵式コンピュータのコード

T0K    ; アキュムレータをクリア
H0D    ; 乗数レジスタにメモリ0番地の値をロード
A1D    ; アキュムレータにメモリ1番地の値を加算
T2D    ; 結果をメモリ2番地に格納
ZF     ; 停止

; この時代、プログラマは機械語を直接書いていた。
; バグ修正は配線の差し替えや紙テープの穴あけ直し。
```

### 2.5 グレース・ホッパーとコンパイラの誕生（1952年）

**グレース・ホッパー**は世界初のコンパイラ「A-0」を開発し、「プログラミング言語を人間に近づける」という革命を起こした。

- **「バグ」の語源**: ホッパーがMark IIコンピュータで蛾（bug）を発見し、ログブックに貼り付けた（1947年）。「デバッグ」の語源とされる
- **COBOL（1959年）**: ホッパーが主導した「ビジネス向け英語に近いプログラミング言語」
- **彼女の哲学**: 「許可を求めるより、許しを請う方が簡単だ」— イノベーションの本質

```cobol
      * COBOL (1959) — グレース・ホッパーの遺産
      * 英語に近い文法でビジネスロジックを記述
      *
       IDENTIFICATION DIVISION.
       PROGRAM-ID. HELLO-WORLD.
       PROCEDURE DIVISION.
           DISPLAY "HELLO, WORLD!".
           STOP RUN.

      * COBOLは2026年現在も銀行、保険、政府機関で稼働中
      * 世界のトランザクション処理の推定43%がCOBOLで動いている
      * レガシーシステムの移行は現代の大きな課題
```

---

## 3. トランジスタ・IC時代（1950年代〜1970年代）— 第2・第3世代

### 3.1 トランジスタの発明（1947年）

ベル研究所の**ショックレー、バーディーン、ブラッテン**が点接触型トランジスタを発明（1956年ノーベル物理学賞）。真空管に比べて:
- **小型**: 数mmサイズ
- **低消費電力**: 発熱が劇的に減少
- **高信頼性**: 真空管の寿命1,000時間→トランジスタは数十年
- **高速**: スイッチング速度が桁違いに向上

### 3.2 集積回路（IC）の発明（1958年）

**ジャック・キルビー**（Texas Instruments）と**ロバート・ノイス**（Fairchild/後のIntel共同創業者）が独立にICを発明。

→ 1つのシリコンチップ上に複数のトランジスタを集積。

この発明は「フェアチャイルドの8人の裏切り者（Traitorous Eight）」の物語と深く結びついている。ショックレー半導体研究所を離れた8人がフェアチャイルドセミコンダクターを設立し、シリコンバレーの基礎を築いた。後にロバート・ノイスとゴードン・ムーアがIntelを設立する。

### 3.3 ムーアの法則（1965年）

**ゴードン・ムーア**（Intel共同創業者）の観察:

> 「集積回路上のトランジスタ数は約2年ごとに倍増する」

```
ムーアの法則 — トランジスタ数の推移:

  年     チップ            トランジスタ数
  ─────────────────────────────────────────
  1971   Intel 4004              2,300
  1978   Intel 8086             29,000
  1985   Intel 386             275,000
  1993   Pentium            3,100,000
  2000   Pentium 4          42,000,000
  2006   Core 2 Duo        291,000,000
  2012   Core i7 Ivy     1,400,000,000
  2017   EPYC            19,200,000,000
  2022   Apple M2 Ultra  67,000,000,000
  2024   Apple M4 Max   〜120,000,000,000

  60年間で約5,000万倍の集積度向上。
  人類史上最も持続的な指数関数的成長。
```

ムーアの法則の社会的影響:

```
ムーアの法則が引き起こした「デモクラタイゼーション」:

  1960年代: コンピュータは政府と大企業のもの（数億円）
  1970年代: 大学と研究所に普及（数千万円）
  1980年代: 個人が所有可能に（数十万円）
  1990年代: インターネットで世界が繋がる
  2000年代: ポケットにスーパーコンピュータ（スマートフォン）
  2010年代: クラウドで誰でも大規模計算（AWS Lambda: 実質無料から）
  2020年代: AIが一般人でも利用可能に

  → 計算能力の「民主化」が社会を根本的に変革し続けている
```

### 3.4 プログラミング言語の大爆発（1950年代〜1970年代）

この時代は多くの重要なプログラミング言語が誕生した:

| 年 | 言語 | 設計者 | 特徴 | 現在の影響 |
|----|------|--------|------|-----------|
| 1957 | FORTRAN | John Backus (IBM) | 科学技術計算、最初の高水準言語 | 数値計算・HPCで現役 |
| 1958 | Lisp | John McCarthy (MIT) | 関数型、GC、マクロ | Clojure, Emacs Lisp |
| 1959 | COBOL | Grace Hopper他 | ビジネス処理、英語風 | 銀行・保険で現役 |
| 1964 | BASIC | Kemeny & Kurtz | 教育用、対話型 | Visual Basic の祖先 |
| 1970 | Pascal | Niklaus Wirth | 構造化プログラミング教育 | Delphi の祖先 |
| 1972 | C | Dennis Ritchie | システムプログラミング | OS, 組込み, C++/Java/Go/Rust の祖先 |
| 1972 | Smalltalk | Alan Kay (Xerox PARC) | 純粋OOP、GUIの先駆 | Ruby, Objective-C に影響 |
| 1973 | Prolog | Alain Colmerauer | 論理プログラミング | AIの推論エンジン |

### 3.5 UNIX誕生（1969年）

**ケン・トンプソン**と**デニス・リッチー**がベル研究所で**UNIX**を開発。

UNIXの革新:
- **Everything is a file**: デバイスもネットワークもファイルとして抽象化
- **パイプ**: 小さなプログラムを組み合わせて複雑な処理を実現
- **マルチユーザー/マルチタスク**: 複数人が同時利用可能
- **移植性**: C言語で書き直されたことで様々なハードウェアに移植可能に

現代のLinux、macOS、Android、iOS全てがUNIXの思想を受け継いでいる。

**UNIX哲学**: Doug McIlroyが定式化した設計原則は、現代のソフトウェア設計にも通用する:

```bash
# UNIX哲学の実践例

# 1. 「一つのことをうまくやれ」
# wc — 行数/単語数/バイト数をカウントするだけ
wc -l access.log
# → 150000

# 2. 「プログラムの出力を別のプログラムの入力にできるようにせよ」
# パイプで小さなツールを組み合わせる
cat access.log | grep "ERROR" | sort | uniq -c | sort -rn | head -10
# → エラーの出現頻度トップ10を表示

# 3. 「テキストストリームを普遍的なインターフェースとせよ」
# JSON, CSV, YAML... 全てテキスト
# この哲学は現代のマイクロサービスのAPI設計にも影響

# 現代の対応:
# UNIX パイプ → HTTP API → gRPC → メッセージキュー
# 「小さなサービスを組み合わせる」思想は不変
```

### 3.6 C言語の誕生（1972年）

**デニス・リッチー**がUNIXを移植可能にするために開発。

```c
/* C言語 (1972年) — "Hello, World" の元祖 */
/* K&R「プログラミング言語C」より */

#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}

/*
 * C言語の革新:
 * - 高水準言語でありながらハードウェアに近いレベルの制御が可能
 * - ポインタによる直接メモリ操作
 * - 構造体による複合データ型
 * - プリプロセッサによるメタプログラミング
 *
 * 2026年現在もLinuxカーネル、OS、組み込みシステムの主力言語。
 * C++、Java、C#、Go、Rust全てがCの影響を受けている。
 */
```

### 3.7 FORTRAN（1957年）— 最初の高水準言語

```fortran
C     FORTRAN (1957) — 科学技術計算用の最初の高水準言語
C     IBM 704用にジョン・バッカスのチームが開発
C
      PROGRAM FIBONACCI
      INTEGER N, A, B, TEMP
      N = 10
      A = 0
      B = 1
      DO 10 I = 1, N
        TEMP = A + B
        A = B
        B = TEMP
        WRITE(*,*) 'FIB(', I, ') = ', B
   10 CONTINUE
      END

C     FORTRANの革新:
C     - 機械語ではなく数学的な記法でプログラムが書ける
C     - コンパイラが最適化された機械語に変換
C     - プログラマの生産性が20倍以上向上
C     - 2026年現在も数値計算・HPC分野で現役
```

### 3.8 Lispとアラン・ケイの夢（1958年〜1970年代）

**Lisp**（1958年、John McCarthy）は、コンピュータサイエンスの歴史で最も影響力のある言語の一つ:

```lisp
;; Lisp (1958) — 世界で2番目に古い高水準言語
;; ガベージコレクション、マクロ、関数型プログラミングの先駆

;; フィボナッチ数列
(defun fibonacci (n)
  (if (<= n 1)
      n
      (+ (fibonacci (- n 1))
         (fibonacci (- n 2)))))

;; コードとデータの同形性（ホモイコニシティ）
;; Lispのコード自体がリスト（データ構造）
;; → メタプログラミング、マクロの基盤

;; Lispが先駆けた概念:
;; - ガベージコレクション（1959年） → Java, Python, Go, JavaScript
;; - 高階関数 → map, filter, reduce
;; - 再帰 → 全現代言語
;; - REPL（対話的実行） → Python, Node.js
;; - 動的型付け → Python, Ruby, JavaScript
```

**アラン・ケイ**（Xerox PARC）はSmalltalkを開発し、「パーソナルコンピュータ」と「オブジェクト指向プログラミング」のビジョンを示した。彼の有名な言葉:

> "The best way to predict the future is to invent it."
> （未来を予測する最善の方法は、それを発明することだ。）

---

## 4. PC時代（1970年代〜2000年代）— 第4世代

### 4.1 マイクロプロセッサの誕生

**Intel 4004**（1971年）: 世界初の商用マイクロプロセッサ。2,300個のトランジスタを1チップに集積。

**Intel 8080**（1974年）→ **Intel 8086**（1978年）→ **x86アーキテクチャ**の始まり。

### 4.2 パーソナルコンピュータ革命

| 年 | 製品 | 意義 |
|----|------|------|
| 1975 | Altair 8800 | 初の個人向けコンピュータキット |
| 1976 | Apple I | ウォズニアックが設計、Jobs が販売 |
| 1977 | Apple II | 初の大ヒットPC。表計算VisiCalcの登場 |
| 1981 | IBM PC | ビジネスPCの標準に。オープンアーキテクチャ |
| 1984 | Macintosh | GUI革命。マウスとウィンドウシステム |
| 1985 | Windows 1.0 | MS-DOSの上にGUIを載せた |
| 1991 | Linux 0.01 | Linuxトーバルズがカーネルを公開 |
| 1995 | Windows 95 | PCの大衆化を完成させた |

### 4.3 GUI革命

**Xerox PARC**（パロアルト研究所）が1970年代に開発した**Alto**に搭載されたGUI（グラフィカル・ユーザー・インターフェース）は:
- ウィンドウシステム
- マウス操作
- WYSIWYG（What You See Is What You Get）
- オブジェクト指向プログラミング（Smalltalk）

スティーブ・ジョブズがPARCを訪問し、このアイデアをMacintosh（1984年）に結実させた。

### 4.4 オープンソースの台頭

```
オープンソース運動の系譜:

  1983  GNU プロジェクト（Richard Stallman）
    │   「ソフトウェアは自由であるべき」
    │   GPL（GNU General Public License）
    │
  1991  Linux 0.01（Linus Torvalds）
    │   「趣味のOS。GNUのような大きなプロジェクトにはならない」
    │   → 世界最大のオープンソースプロジェクトに成長
    │
  1993  Debian, Red Hat → Linux ディストリビューション
    │
  1998  「オープンソース」という用語の誕生
    │   Eric Raymond "The Cathedral and the Bazaar"
    │
  1999  Apache が Web サーバー市場で圧倒的シェア
    │
  2005  Git（Linus Torvalds が開発）
    │   → 分散バージョン管理の革命
    │
  2008  GitHub 設立
    │   → オープンソースの「ソーシャルネットワーク」
    │
  2018  Microsoft が GitHub を買収（$7.5B）
    │   → 「かつてLinuxを癌と呼んだ会社」がオープンソースを抱擁
    │
  2026  OSS が世界のインフラの基盤に
       Linux: サーバーの96%, Android, クラウド基盤
       OSS依存のソフトウェアサプライチェーンが課題に
```

### 4.5 インターネットの商用化

```
インターネットの進化:

  1969  ARPANET（4ノード: UCLA, SRI, UCSB, Utah）
    │
  1971  電子メール発明（Ray Tomlinson、@記号の使用）
    │
  1973  TCP/IP プロトコル設計（Vint Cerf, Bob Kahn）
    │
  1983  ARPANET が TCP/IP に切り替え（インターネットの誕生日）
    │
  1989  World Wide Web 提案（Tim Berners-Lee, CERN）
    │
  1990  最初のWebブラウザ/サーバー（WorldWideWeb/httpd）
    │
  1993  Mosaic ブラウザ → 1994 Netscape Navigator
    │
  1995  商用インターネット開放、Amazon・eBay設立
    │
  1998  Google 設立
    │
  2004  Facebook, Web 2.0時代
    │
  2007  iPhone → モバイルインターネット時代
    │
  2023  生成AI時代（ChatGPT, Claude）
```

### 4.6 Python の誕生（1991年）

```python
# Python (1991) — Guido van Rossum が「退屈な週末」に開発を始めた
# 「コードは書くよりも読まれる回数のほうが多い」という哲学

def fibonacci(n):
    """フィボナッチ数列の最初のn項を生成する。

    Pythonの哲学を体現:
    - 読みやすさ重視（インデント強制）
    - 簡潔な構文（型宣言不要）
    - バッテリー同梱（豊富な標準ライブラリ）
    """
    a, b = 0, 1
    result = []
    for _ in range(n):
        result.append(a)
        a, b = b, a + b
    return result

# リスト内包表記 — Pythonの特徴的な構文
squares = [x**2 for x in range(10)]
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

# 2026年現在: AI/ML、データサイエンス、Web、自動化の主力言語
# PyPI に50万以上のパッケージ
```

### 4.7 Web技術の進化とJavaScriptの台頭

```javascript
// JavaScript (1995) — Brendan Eich が10日間で設計
// 当初は「おもちゃの言語」と見られていたが、
// 現在はWebの事実上の標準言語

// 1995: 基本的なDOM操作
document.write("Hello, World!");

// 2006: jQuery の登場 — クロスブラウザ問題の解決
// $("button").click(function() { alert("clicked"); });

// 2009: Node.js — サーバーサイドJavaScript革命
// const http = require('http');
// http.createServer((req, res) => { ... }).listen(8080);

// 2015: ES6 — モダンJavaScriptの始まり
const fibonacci = (n) => {
    const result = [0, 1];
    for (let i = 2; i < n; i++) {
        result.push(result[i-1] + result[i-2]);
    }
    return result;
};

// 2020年代: TypeScript, React, Next.js, Bun
// JavaScriptエコシステムは世界最大のソフトウェアエコシステムに
// npm: 200万以上のパッケージ
```

---

## 5. 現代（2000年代〜現在）— 第5世代

### 5.1 クラウドコンピューティング

| 年 | サービス | 革新 |
|----|---------|------|
| 2006 | AWS EC2/S3 | オンデマンドのインフラ |
| 2008 | Google App Engine | PaaS (Platform as a Service) |
| 2010 | Azure | マイクロソフトのクラウド |
| 2011 | AWS Lambda (プレビュー) | サーバーレスの先駆け |
| 2014 | AWS Lambda (GA) | FaaS (Function as a Service) |
| 2015 | Kubernetes 1.0 | コンテナオーケストレーション |
| 2020 | AWS re:Invent | ARM (Graviton)、サーバーレス拡大 |

クラウドの本質: **「所有」から「利用」への転換**。物理サーバーを買う代わりに、必要なときに必要なだけ計算資源をAPIで調達する。

### 5.2 モバイル革命

2007年のiPhone発売は「ポケットにスーパーコンピュータ」を入れた。

- 2008: App Store → アプリエコノミーの誕生
- 2008: Android → オープンソースモバイルOS
- 2010: iPad → タブレット市場の創出
- 2014: Swift → Apple の新プログラミング言語
- 2017: PWA → WebアプリのモバイルネイティブUX

### 5.3 AI/機械学習の爆発

```
AI の進化 — 「冬の時代」を越えて:

  1950  チューリングテスト提案
  1956  「人工知能」という用語の誕生（ダートマス会議）
  1960s 第1次AIブーム（記号AI、パーセプトロン）
  1970s 第1次AI冬の時代（期待に成果が追いつかず）
  1980s 第2次AIブーム（エキスパートシステム）
  1990s 第2次AI冬の時代
  1997  Deep Blue がチェス世界王者に勝利
  2006  ディープラーニングの再発見（Hinton）
  2012  AlexNet が画像認識コンペで圧勝 → DLブーム開始
  2016  AlphaGo が囲碁世界王者に勝利
  2017  Transformer アーキテクチャ（"Attention Is All You Need"）
  2020  GPT-3 (175B パラメータ)
  2022  ChatGPT → 生成AIの大衆化
  2023  GPT-4, Claude 2, Llama 2
  2024  Claude 3.5, GPT-4o, マルチモーダルAI
  2025  Claude 4, エージェントAI、推論モデル
  2026  Claude 4.5/4.6, AIコーディングアシスタントの標準化
```

AIの3回のブームと2回の冬の時代は、**ハイプサイクル（Gartner Hype Cycle）** の典型例である。新技術を評価する際に、このパターンを知っていることは非常に重要:

```
ハイプサイクルのパターン:

  期待度
  │
  │        ★ ピーク（過度な期待）
  │       ╱╲
  │      ╱  ╲
  │     ╱    ╲
  │    ╱      ╲   ★ 安定期（真の実用化）
  │   ╱        ╲ ╱─────────────
  │  ╱          ★ 幻滅の谷
  │ ╱
  │╱
  │ ★ 黎明期
  └──────────────────────── 時間

  AI の例:
  - 黎明期: 1956年ダートマス会議
  - ピーク1: 1960年代「20年以内に人間レベルのAI」
  - 幻滅1: 1970年代（第1次AI冬）
  - ピーク2: 1980年代エキスパートシステム
  - 幻滅2: 1990年代（第2次AI冬）
  - 安定期: 2012年〜ディープラーニング → 2022年〜生成AI
```

### 5.4 Rust — 安全性とパフォーマンスの両立（2015年安定版）

```rust
// Rust (2015) — Mozillaが開発したシステムプログラミング言語
// 「メモリ安全性」を言語レベルで保証する革新

fn fibonacci(n: u32) -> Vec<u64> {
    // 所有権システム: メモリリークとデータ競合をコンパイル時に防止
    let mut result = Vec::with_capacity(n as usize);
    let (mut a, mut b): (u64, u64) = (0, 1);

    for _ in 0..n {
        result.push(a);
        let temp = a + b;
        a = b;
        b = temp;
    }

    result  // 所有権の移動（ムーブ）: コピーなしで返却
}

fn main() {
    let fibs = fibonacci(10);
    // fibs の所有権は main が持つ
    // スコープを抜けると自動的にメモリ解放（GC不要）

    println!("Fibonacci: {:?}", fibs);
    // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
}

// Rustの革新:
// - ガベージコレクタなしでメモリ安全
// - データ競合をコンパイル時に検出
// - C/C++と同等のパフォーマンス
// - Linux カーネル（6.1以降）にも採用
```

### 5.5 量子コンピュータ

量子ビット（qubit）の**重ね合わせ**と**もつれ**を利用し、特定の問題で古典コンピュータを圧倒的に超える計算能力を目指す。

| 側面 | 古典コンピュータ | 量子コンピュータ |
|------|----------------|-----------------|
| 基本単位 | ビット（0 or 1） | 量子ビット（0と1の重ね合わせ） |
| 計算方式 | 逐次/並列計算 | 量子ゲート操作 |
| 得意分野 | 汎用計算 | 素因数分解、最適化、量子シミュレーション |
| 苦手分野 | 指数的組み合わせ問題 | 汎用計算（現時点） |
| 実用性 | 完全に実用 | 研究段階（NISQ時代） |
| 主要プレーヤー | Intel, AMD, Apple, NVIDIA | IBM, Google, IonQ, Rigetti |

Google「Sycamore」は2019年に量子超越性を主張（古典コンピュータで1万年かかる計算を200秒で実行）。ただし実用的な量子アドバンテージはまだ限定的。

---

## 6. コンピューティング史年表

```
┌──────┬──────────────────────────────────────────────────────────────┐
│ 年   │ 出来事                                                      │
├──────┼──────────────────────────────────────────────────────────────┤
│ 紀元前│ そろばん（メソポタミア、中国）                                │
│ 1642 │ パスカリーヌ（機械式加算機）                                  │
│ 1694 │ ライプニッツの計算機（乗除算対応）                            │
│ 1804 │ ジャカードの織機（パンチカード式自動織機）                     │
│ 1837 │ バベッジの解析機関（プログラム可能な計算機の構想）             │
│ 1843 │ エイダ・ラブレスのアルゴリズム（世界初のプログラム）           │
│ 1854 │ ブールの論理代数（AND/OR/NOT の体系化）                       │
│ 1936 │ チューリングマシン、チャーチのラムダ計算                      │
│ 1937 │ クロード・シャノンの修士論文（ブール代数と電気回路の結合）     │
│ 1943 │ コロッサス（暗号解読用電子計算機）                            │
│ 1945 │ ENIAC、フォン・ノイマン・アーキテクチャの提案                 │
│ 1947 │ トランジスタの発明（ベル研究所）                              │
│ 1949 │ EDSAC（初のプログラム内蔵式コンピュータ）                     │
│ 1952 │ グレース・ホッパーのコンパイラ A-0                            │
│ 1957 │ FORTRAN（初の高水準プログラミング言語）                       │
│ 1958 │ 集積回路（IC）の発明、Lisp の誕生                            │
│ 1959 │ COBOL（ビジネス用プログラミング言語）                        │
│ 1964 │ IBM System/360（初の互換性あるコンピュータファミリ）          │
│ 1965 │ ムーアの法則の発表                                          │
│ 1969 │ UNIX誕生、ARPANET開始（4ノード）                            │
│ 1970 │ リレーショナルデータベースモデル（E.F.コッド）                │
│ 1971 │ Intel 4004（初のマイクロプロセッサ）、電子メール発明           │
│ 1972 │ C言語の誕生、Smalltalk の誕生                                │
│ 1973 │ TCP/IPプロトコル設計、Xerox Alto（初のGUI PC）               │
│ 1976 │ Apple I                                                    │
│ 1981 │ IBM PC、MS-DOS                                             │
│ 1983 │ TCP/IPへの切り替え（インターネットの誕生日）、GNU プロジェクト │
│ 1984 │ Macintosh（GUIの大衆化）                                    │
│ 1989 │ World Wide Web提案（ティム・バーナーズ＝リー）               │
│ 1991 │ Linux 0.01、Python 1.0、World Wide Web公開                  │
│ 1993 │ Mosaic ブラウザ                                             │
│ 1995 │ Java、JavaScript、PHP、MySQL、Amazon、eBay                  │
│ 1998 │ Google設立                                                  │
│ 2001 │ Wikipedia、Mac OS X                                        │
│ 2004 │ Facebook、Web 2.0、Ubuntu                                  │
│ 2005 │ Git（Linus Torvaldsが開発）、YouTube                        │
│ 2006 │ AWS EC2/S3（クラウドコンピューティング元年）                  │
│ 2007 │ iPhone（モバイル革命）                                      │
│ 2008 │ App Store、Android、GitHub、Bitcoin白書                     │
│ 2009 │ Node.js、Go言語                                            │
│ 2010 │ iPad、Instagram                                            │
│ 2012 │ AlexNet（ディープラーニング革命）、Docker開発開始、TypeScript │
│ 2013 │ Docker公開、React公開                                      │
│ 2014 │ Swift、Kubernetes、AWS Lambda                               │
│ 2015 │ Rust 1.0、TensorFlow、HTTP/2                               │
│ 2016 │ AlphaGo vs 李世ドル                                        │
│ 2017 │ Transformer論文 "Attention Is All You Need"                 │
│ 2018 │ BERT、Kubernetes成熟期                                     │
│ 2020 │ GPT-3、Apple M1チップ（ARM Mac）                            │
│ 2022 │ ChatGPT、Stable Diffusion（生成AI大衆化）                   │
│ 2023 │ GPT-4、Claude 2、LLaMA、Apple Vision Pro                   │
│ 2024 │ Claude 3.5、GPT-4o、Sora、マルチモーダルAI                  │
│ 2025 │ Claude 4、エージェントAI、AIコーディング支援の普及            │
│ 2026 │ Claude 4.5/4.6、AIネイティブ開発の標準化                     │
└──────┴──────────────────────────────────────────────────────────────┘
```

---

## 7. 5つの世代の比較

| 世代 | 時代 | 技術 | 速度 | プログラミング | 代表機 |
|------|------|------|------|-------------|--------|
| 第1世代 | 1940s-50s | 真空管 | kHz | 機械語 | ENIAC, EDSAC |
| 第2世代 | 1950s-60s | トランジスタ | MHz | アセンブリ, FORTRAN | IBM 7090 |
| 第3世代 | 1960s-70s | IC | MHz | C, COBOL | IBM 360, PDP-11 |
| 第4世代 | 1970s-2000s | VLSI/マイクロプロセッサ | GHz | C++, Java, Python | PC, Mac |
| 第5世代 | 2000s- | クラウド/AI/量子 | THz級 | Rust, Go + AI支援 | AWS, iPhone |

### 各世代の「抽象化レベル」の進化

```
抽象化レベルの歴史:

  高い  │  ┌─────────────────────────────────────────┐
  抽象  │  │ AI支援プログラミング (2020年代〜)        │
  レベル│  │ 「やりたいことを自然言語で伝える」       │
        │  ├─────────────────────────────────────────┤
        │  │ フレームワーク (2000年代〜)              │
        │  │ 「Rails g scaffold User name:string」   │
        │  ├─────────────────────────────────────────┤
        │  │ 高水準言語 (1990年代〜)                  │
        │  │ 「result = sorted(data, key=lambda x: x.score)」│
        │  ├─────────────────────────────────────────┤
        │  │ C言語 (1970年代〜)                       │
        │  │ 「int *ptr = malloc(sizeof(int) * 100);」│
        │  ├─────────────────────────────────────────┤
        │  │ アセンブリ (1950年代〜)                   │
        │  │ 「MOV EAX, [EBP-4]; ADD EAX, ECX」       │
        │  ├─────────────────────────────────────────┤
  低い  │  │ 機械語 (1940年代〜)                       │
        │  │ 「10110000 01100001」                    │
        │  └─────────────────────────────────────────┘

  各世代が前の世代の複雑さを「隠蔽」し、
  プログラマがより高い抽象レベルで問題解決に集中できるようにした。
  → これが「抽象化の積み重ね」としてのCS史の本質。
```

---

## 8. 実践演習

### 演習1: 歴史的背景の理解（基礎）

以下の技術について、「誰が」「いつ」「なぜ」開発したかを調べ、表にまとめよ:

1. TCP/IP
2. World Wide Web
3. Git
4. Docker
5. Transformer

### 演習2: 技術の系譜を追う（応用）

以下の各技術について、その「祖先」を3世代前まで遡り、系譜図を描け:

例: React (2013) ← jQuery (2006) ← Prototype.js (2005) ← JavaScript (1995) ← HyperCard (1987)

1. TypeScript (2012) の系譜
2. Kubernetes (2014) の系譜
3. ChatGPT (2022) の系譜

### 演習3: 未来予測（発展）

現在のトレンド（AI、量子コンピュータ、ブロックチェーン、VR/AR）から、10年後（2036年）のコンピューティングがどうなっているか予測を記述せよ。ムーアの法則の延長、AIの進化速度、社会的影響を考慮すること。

### 演習4: コード考古学（応用）

以下の問題をFORTRAN、C、Python、Rustのそれぞれで実装し、言語進化を実感せよ:

**問題**: 1からNまでの整数の中から素数を列挙する（エラトステネスのふるい）

<details>
<summary>Pythonでの実装例</summary>

```python
def sieve_of_eratosthenes(n):
    """エラトステネスのふるい — 紀元前240年のアルゴリズム
    2300年前のアルゴリズムが現代でも最適解の一つであることが、
    CS基礎の普遍性を示している。
    """
    is_prime = [True] * (n + 1)
    is_prime[0] = is_prime[1] = False

    for i in range(2, int(n**0.5) + 1):
        if is_prime[i]:
            for j in range(i*i, n + 1, i):
                is_prime[j] = False

    return [i for i in range(2, n + 1) if is_prime[i]]

primes = sieve_of_eratosthenes(100)
print(primes)  # [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, ...]
```

</details>

---

## FAQ

### Q1: なぜ歴史を学ぶ必要があるのですか？

**A**: 技術の歴史を知ることで、以下が得られる:
1. **「なぜ今の形になったか」の理解**: x86がCISCなのは歴史的経緯。UNIXの設計思想が今のクラウドに影響。
2. **パターン認識**: 技術の栄枯盛衰のパターン（ハイプサイクル）を理解し、新技術の評価に役立てる。
3. **巨人の肩に立つ**: 車輪の再発明を避け、過去の失敗から学ぶ。

### Q2: ムーアの法則はまだ有効ですか？

**A**: 厳密な意味では鈍化している。トランジスタの物理的限界（原子数個分のサイズ）に近づいているため、単純な微細化は限界に近い。しかし:
- **チップレット技術**: 複数のダイを組み合わせる（AMD EPYC、Apple M2 Ultra）
- **3D積層**: トランジスタを立体的に重ねる（3D NAND、GAA FET）
- **新素材**: シリコン以外の材料（カーボンナノチューブ、GaN）
- **アーキテクチャ革新**: 専用アクセラレータ（GPU、TPU、NPU）

→ 性能向上は続くが、その方法が変わりつつある。

### Q3: プログラミング言語はどこに向かっていますか？

**A**: いくつかのトレンドが見える:
1. **型安全性の強化**: TypeScript、Rust の人気が示すように、コンパイル時の安全性が重視される
2. **マルチパラダイム**: 一つの言語が関数型、OOP、命令型を全て取り込む（Kotlin、Swift、Rust）
3. **メモリ安全性**: Rustの所有権システムのような、GCなしでのメモリ安全保証
4. **AI支援**: AIがコードを生成・補完する時代。言語は「AIが書きやすく、人間が読みやすい」方向へ
5. **ドメイン特化**: 汎用言語に加え、特定分野向けのDSL（SQL、正規表現、ShaderLanguage）の重要性

### Q4: 第6世代コンピュータはありますか？

**A**: まだ確定していないが、候補として:
- **量子コンピュータ**: 古典コンピュータでは不可能な計算の実現
- **ニューロモーフィックチップ**: 脳の構造を模倣したチップ（IBM TrueNorth、Intel Loihi）
- **光コンピュータ**: 光子を使った超高速・低消費電力計算
- **バイオコンピュータ**: DNAや生体分子を使った計算

いずれも実用化には時間がかかるが、研究は活発に進んでいる。

### Q5: なぜUNIXの設計思想は50年以上生き残っているのですか？

**A**: UNIXの設計思想が長寿命である理由は、それが「良い抽象化」を提供しているからである:

1. **「Everything is a file」**: ファイル記述子という統一インターフェースで、ファイル、ネットワーク、デバイスを透過的に扱える。この抽象化は正しかった
2. **「小さなプログラムの組み合わせ」**: コンポーザビリティ（組み合わせ可能性）は、マイクロサービスやサーバーレスでも同じ原則
3. **「テキストは万能インターフェース」**: JSON、YAML、Protocol Buffersに形を変えても、「構造化テキストでプログラム間を接続する」思想は不変
4. **「シンプルさを追求」**: 複雑なシステムは壊れやすい。UNIXの各ツールはシンプルだからこそ信頼性が高い

---

## まとめ

| 時代 | キーイベント | 現代への影響 |
|------|-----------|-------------|
| 機械式 | バベッジの解析機関 | プログラム内蔵の概念 |
| 理論 | チューリングマシン | 計算可能性の限界の定義 |
| 真空管 | ENIAC、フォン・ノイマン | 現代CPUアーキテクチャの基盤 |
| IC | ムーアの法則、UNIX、C | 指数的成長、OSの設計思想 |
| PC | GUI、インターネット | コンピュータの大衆化 |
| 現代 | クラウド、AI、量子 | ソフトウェアがあらゆる産業を変革 |

**本質**: コンピューティングの歴史は「抽象化の積み重ね」の歴史である。機械語→アセンブリ→高水準言語→フレームワーク→AI支援 — 各世代が前の世代の複雑さを隠蔽し、より高い抽象レベルで問題解決を可能にしてきた。

---

## 次に読むべきガイド

→ [[02-why-learn-cs.md]] — なぜCSを学ぶのか、具体的な例で理解する

---

## 参考文献

1. Turing, A. M. "On Computable Numbers, with an Application to the Entscheidungsproblem." Proceedings of the London Mathematical Society, 1936.
2. von Neumann, J. "First Draft of a Report on the EDVAC." 1945.
3. Ritchie, D. M. & Thompson, K. "The UNIX Time-Sharing System." Communications of the ACM, 1974.
4. Moore, G. E. "Cramming More Components onto Integrated Circuits." Electronics, 1965.
5. Berners-Lee, T. "Information Management: A Proposal." CERN, 1989.
6. Vaswani, A. et al. "Attention Is All You Need." NeurIPS, 2017.
7. Ceruzzi, P. E. "A History of Modern Computing." MIT Press, 2003.
8. Campbell-Kelly, M. et al. "Computer: A History of the Information Machine." Westview Press, 2013.
9. Isaacson, W. "The Innovators." Simon & Schuster, 2014.
10. Swade, D. "The Difference Engine: Charles Babbage and the Quest to Build the First Computer." Viking, 2001.
11. Raymond, E. S. "The Cathedral and the Bazaar." O'Reilly Media, 1999.
12. Shannon, C. E. "A Symbolic Analysis of Relay and Switching Circuits." MIT Master's Thesis, 1937.
13. McCarthy, J. "Recursive Functions of Symbolic Expressions and Their Computation by Machine." Communications of the ACM, 1960.
14. Kay, A. "The Early History of Smalltalk." ACM SIGPLAN Notices, 1993.
