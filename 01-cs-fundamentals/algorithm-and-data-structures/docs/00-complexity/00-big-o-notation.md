# Big-O 記法と計算量の基礎

> アルゴリズムの効率を数学的に表現する O 記法・Omega 記法・Theta 記法、および空間計算量と償却計算量を体系的に学ぶ。

---

## この章で学ぶこと

1. **O / Omega / Theta 記法** の定義と使い分け
2. **空間計算量** の評価方法と再帰呼び出しのスタック消費
3. **償却計算量** の考え方と動的配列への応用

---

## 1. 漸近記法の定義

### 1.1 Big-O 記法（上界）

```
定義: f(n) = O(g(n))
⟺ ∃ c > 0, n₀ > 0 s.t. ∀ n ≥ n₀, f(n) ≤ c · g(n)
```

「最悪でもこの程度」という上限を示す。

```
  f(n)
  ▲
  │        ╱ c·g(n)
  │       ╱
  │     ╱  ← f(n) はこの下に収まる
  │   ╱╱
  │  ╱
  │╱
  ┼──────────────────► n
       n₀
```

### 1.2 Big-Omega 記法（下界）

```
定義: f(n) = Ω(g(n))
⟺ ∃ c > 0, n₀ > 0 s.t. ∀ n ≥ n₀, f(n) ≥ c · g(n)
```

「少なくともこの程度かかる」という下限を示す。

### 1.3 Big-Theta 記法（タイトな境界）

```
定義: f(n) = Θ(g(n))
⟺ f(n) = O(g(n)) かつ f(n) = Ω(g(n))
```

上界と下界が一致するとき、正確なオーダーを示す。

---

## 2. 主要な計算量クラス

```
計算量の成長速度（小→大）:

O(1) < O(log n) < O(√n) < O(n) < O(n log n) < O(n²) < O(n³) < O(2ⁿ) < O(n!)

  時間
  ▲
  │                                          ╱ O(n!)
  │                                       ╱
  │                                    ╱   O(2ⁿ)
  │                                ╱╱
  │                          ╱╱╱  O(n²)
  │                    ╱╱╱
  │              ╱╱╱         O(n log n)
  │        ╱╱╱
  │   ╱╱╱                   O(n)
  │╱╱  ─────────────────── O(log n)
  │━━━━━━━━━━━━━━━━━━━━━━━ O(1)
  ┼──────────────────────────────► n
```

---

## 3. コード例

### 例1: O(1) — 定数時間

```python
def get_first(arr):
    """配列の先頭要素を返す — O(1)"""
    return arr[0]
```

### 例2: O(log n) — 二分探索

```python
def binary_search(arr, target):
    """ソート済み配列の二分探索 — O(log n)"""
    lo, hi = 0, len(arr) - 1
    while lo <= hi:
        mid = (lo + hi) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            lo = mid + 1
        else:
            hi = mid - 1
    return -1
```

### 例3: O(n) — 線形走査

```python
def linear_search(arr, target):
    """全要素を走査 — O(n)"""
    for i, val in enumerate(arr):
        if val == target:
            return i
    return -1
```

### 例4: O(n²) — 二重ループ

```python
def bubble_sort(arr):
    """バブルソート — O(n²)"""
    n = len(arr)
    for i in range(n):
        for j in range(0, n - i - 1):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
    return arr
```

### 例5: O(2ⁿ) — 指数時間（フィボナッチ素朴実装）

```python
def fib_naive(n):
    """フィボナッチ数（素朴再帰）— O(2ⁿ)"""
    if n <= 1:
        return n
    return fib_naive(n - 1) + fib_naive(n - 2)
```

### 例6: 空間計算量 O(n) の例

```python
def create_copy(arr):
    """配列のコピーを生成 — 時間 O(n), 空間 O(n)"""
    return [x for x in arr]
```

---

## 4. 空間計算量

### 4.1 入力サイズを含むか？

| 方式 | 説明 |
|------|------|
| **全体空間計算量** | 入力データ + 補助メモリ |
| **補助空間計算量** | 補助メモリのみ（一般的にこちらを使う） |

### 4.2 再帰のスタック消費

```
再帰深度 d の関数 → スタック空間 O(d)

fib(5) の呼び出しスタック:
┌─────────┐
│ fib(1)  │ ← 最深部
├─────────┤
│ fib(2)  │
├─────────┤
│ fib(3)  │
├─────────┤
│ fib(4)  │
├─────────┤
│ fib(5)  │ ← 開始
└─────────┘
スタック深度 = O(n)
```

---

## 5. 償却計算量（Amortized Analysis）

### 5.1 動的配列の追加操作

```
容量 4 の動的配列に要素を追加:

操作 1: [x][ ][ ][ ]      → コスト 1
操作 2: [x][x][ ][ ]      → コスト 1
操作 3: [x][x][x][ ]      → コスト 1
操作 4: [x][x][x][x]      → コスト 1
操作 5: リサイズ発生!
  古い配列 [x][x][x][x] → 新しい配列 [x][x][x][x][x][ ][ ][ ]
  コスト = 4(コピー) + 1(追加) = 5

→ 5回の操作の合計コスト = 1+1+1+1+5 = 9
→ 償却コスト = 9/5 ≈ 1.8 = O(1)
```

### 5.2 Python での動的配列

```python
import sys

sizes = []
lst = []
for i in range(64):
    lst.append(i)
    sizes.append(sys.getsizeof(lst))

# サイズは段階的に増加する（倍々成長）
# append は償却 O(1)
```

---

## 6. 比較表

### 表1: 漸近記法の比較

| 記法 | 意味 | 直感的説明 | 用途 |
|------|------|-----------|------|
| O(g(n)) | 上界 | 最悪でも g(n) 程度 | 最悪ケース分析 |
| Ω(g(n)) | 下界 | 少なくとも g(n) 程度 | 下限の証明 |
| Θ(g(n)) | タイト | ちょうど g(n) 程度 | 正確な特性付け |
| o(g(n)) | 狭義上界 | g(n) より真に小さい | 漸近的に無視可能 |
| ω(g(n)) | 狭義下界 | g(n) より真に大きい | 漸近的に支配 |

### 表2: 代表的な計算量と具体例

| 計算量 | 名称 | n=10 | n=100 | n=1000 | 具体例 |
|--------|------|------|-------|--------|--------|
| O(1) | 定数 | 1 | 1 | 1 | 配列添字アクセス |
| O(log n) | 対数 | 3 | 7 | 10 | 二分探索 |
| O(n) | 線形 | 10 | 100 | 1,000 | 線形探索 |
| O(n log n) | 線形対数 | 33 | 664 | 9,966 | マージソート |
| O(n²) | 二乗 | 100 | 10,000 | 1,000,000 | バブルソート |
| O(2ⁿ) | 指数 | 1,024 | ≈10³⁰ | ≈10³⁰¹ | 部分集合列挙 |
| O(n!) | 階乗 | 3,628,800 | ≈10¹⁵⁷ | - | 全順列列挙 |

---

## 7. アンチパターン

### アンチパターン1: 定数を気にしすぎる

```python
# BAD: "ループが2回あるから O(2n) だ" → 誤り
def double_pass(arr):
    total = 0
    for x in arr:    # O(n)
        total += x
    for x in arr:    # O(n)
        total += x
    return total
# O(2n) ではなく O(n)。定数係数は漸近記法では無視する。
```

### アンチパターン2: 最良ケースを「計算量」と呼ぶ

```python
# BAD: "クイックソートは O(n log n)" → 不正確
# クイックソートの最悪ケースは O(n²)
# 正確には：
#   最良 O(n log n)
#   平均 O(n log n)
#   最悪 O(n²)
# ケースを明示せずに O 記法だけ述べると誤解を招く
```

### アンチパターン3: 空間計算量を無視する

```python
# BAD: 時間だけ見て空間を無視
def get_all_pairs(arr):
    """全ペアを生成 — 時間 O(n²), 空間 O(n²)"""
    return [(a, b) for a in arr for b in arr]
# n=100,000 だと 10^10 ペア → メモリ不足
```

---

## 8. FAQ

### Q1: O(n) と Θ(n) の違いは？

**A:** O(n) は「n 以下のオーダー」で上界のみ。Θ(n) は「ちょうど n のオーダー」で上界かつ下界。例えば、O(n²) のアルゴリズムが実は O(n) かもしれないが、Θ(n²) ならば確実に n² のオーダーである。

### Q2: ループが入れ子でなくても O(n²) になることはある？

**A:** ある。例えば文字列連結を繰り返すと、各連結で O(k) のコピーが発生し、合計 O(1+2+...+n) = O(n²) になる場合がある。

```python
# O(n²) の文字列連結
s = ""
for i in range(n):
    s += str(i)  # 毎回新しい文字列を生成
```

### Q3: 償却計算量と平均計算量の違いは？

**A:** 平均計算量は「入力の確率分布に基づく期待値」。償却計算量は「一連の操作列の合計コストを操作回数で割ったもの」で、確率は関係ない。動的配列の append は**確率に関係なく**償却 O(1) である。

### Q4: Big-O は最悪ケースを表すのか？

**A:** いいえ。Big-O は数学的な上界の記法であり、最良・平均・最悪どのケースにも使える。「クイックソートの平均計算量は O(n log n)」のように、ケースと記法は独立した概念である。

---

## 9. まとめ

| 項目 | ポイント |
|------|---------|
| O 記法 | 上界を示す。最悪ケース分析に頻用 |
| Ω 記法 | 下界を示す。下限の証明に使用 |
| Θ 記法 | タイトな境界。上界 = 下界のとき使用 |
| 空間計算量 | 補助メモリ + 再帰スタックを考慮 |
| 償却計算量 | 連続操作の平均コスト。動的配列は償却 O(1) |
| 定数係数 | 漸近記法では無視。実測では重要な場合もある |
| ケースの明示 | 最良/平均/最悪を区別して記述すべき |

---

## 次に読むべきガイド

- [計算量解析 — 再帰の計算量とマスター定理](./01-complexity-analysis.md)
- [時間空間トレードオフ — メモ化とブルームフィルタ](./02-space-time-tradeoff.md)

---

## 参考文献

1. Cormen, T.H., Leiserson, C.E., Rivest, R.L., & Stein, C. (2022). *Introduction to Algorithms* (4th ed.). MIT Press. — 第3章「Growth of Functions」
2. Knuth, D.E. (1997). *The Art of Computer Programming, Volume 1*. Addison-Wesley. — 漸近記法の原典
3. Skiena, S.S. (2020). *The Algorithm Design Manual* (3rd ed.). Springer. — 第2章「Algorithm Analysis」
4. Sedgewick, R. & Wayne, K. (2011). *Algorithms* (4th ed.). Addison-Wesley. — 計算量の実践的解説
