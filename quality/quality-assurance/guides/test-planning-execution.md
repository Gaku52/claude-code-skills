# ãƒ†ã‚¹ãƒˆè¨ˆç”»ãƒ»å®Ÿè¡Œã‚¬ã‚¤ãƒ‰ - å®Œå…¨ç‰ˆ

åŠ¹æœçš„ãªãƒ†ã‚¹ãƒˆè¨ˆç”»ã®ç­–å®šã‹ã‚‰å®Ÿè¡Œã€çµæœåˆ†æã¾ã§ã‚’å®Œå…¨è§£èª¬ã€‚ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å“è³ªã‚’ç¢ºä¿ã™ã‚‹ãŸã‚ã®å®Ÿè·µçš„ãªã‚¬ã‚¤ãƒ‰ã§ã™ã€‚

## ç›®æ¬¡

1. [ãƒ†ã‚¹ãƒˆè¨ˆç”»ã®åŸºç¤](#ãƒ†ã‚¹ãƒˆè¨ˆç”»ã®åŸºç¤)
2. [ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ç­–å®š](#ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ç­–å®š)
3. [ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹è¨­è¨ˆ](#ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹è¨­è¨ˆ)
4. [ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç®¡ç†](#ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç®¡ç†)
5. [ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ç®¡ç†](#ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ç®¡ç†)
6. [ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ](#ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ)
7. [ãƒ†ã‚¹ãƒˆç’°å¢ƒç®¡ç†](#ãƒ†ã‚¹ãƒˆç’°å¢ƒç®¡ç†)
8. [å®Ÿè·µä¾‹ã¨ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£](#å®Ÿè·µä¾‹ã¨ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£)
9. [ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°](#ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°)

---

## ãƒ†ã‚¹ãƒˆè¨ˆç”»ã®åŸºç¤

### ãƒ†ã‚¹ãƒˆè¨ˆç”»ã¨ã¯

**å®šç¾©:**
ãƒ†ã‚¹ãƒˆãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®ç¯„å›²ã€ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã€ãƒªã‚½ãƒ¼ã‚¹ã€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«ã‚’æ–‡æ›¸åŒ–ã—ãŸã‚‚ã®

**ç›®çš„:**
- ãƒ†ã‚¹ãƒˆã®ç¯„å›²ã‚’æ˜ç¢ºåŒ–
- ãƒªã‚¹ã‚¯ã®ç‰¹å®šã¨è»½æ¸›ç­–ã®å®šç¾©
- ãƒªã‚½ãƒ¼ã‚¹ã¨æ™‚é–“ã®æœ€é©é…åˆ†
- ã‚¹ãƒ†ãƒ¼ã‚¯ãƒ›ãƒ«ãƒ€ãƒ¼ã¨ã®æœŸå¾…å€¤ã®èª¿æ•´

### ãƒ†ã‚¹ãƒˆè¨ˆç”»ã®æ§‹æˆè¦ç´ 

```markdown
## ãƒ†ã‚¹ãƒˆè¨ˆç”»æ›¸ã®å¿…é ˆè¦ç´ 

### 1. ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæƒ…å ±
- ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆå
- ãƒãƒ¼ã‚¸ãƒ§ãƒ³/ãƒªãƒªãƒ¼ã‚¹ç•ªå·
- ä½œæˆæ—¥ãƒ»æ›´æ–°æ—¥
- ä½œæˆè€…ãƒ»æ‰¿èªè€…

### 2. ãƒ†ã‚¹ãƒˆå¯¾è±¡
- å¯¾è±¡æ©Ÿèƒ½ä¸€è¦§
- å¯¾è±¡å¤–æ©Ÿèƒ½ï¼ˆã‚¹ã‚³ãƒ¼ãƒ—å¤–ï¼‰
- å¯¾è±¡ãƒ—ãƒ©ãƒƒãƒˆãƒ•ã‚©ãƒ¼ãƒ /ãƒ‡ãƒã‚¤ã‚¹
- å¯¾è±¡OS/ãƒ–ãƒ©ã‚¦ã‚¶ãƒãƒ¼ã‚¸ãƒ§ãƒ³

### 3. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥
- ãƒ†ã‚¹ãƒˆãƒ¬ãƒ™ãƒ«ï¼ˆUnit/Integration/E2Eï¼‰
- ãƒ†ã‚¹ãƒˆã‚¿ã‚¤ãƒ—ï¼ˆæ©Ÿèƒ½/éæ©Ÿèƒ½ï¼‰
- ãƒ†ã‚¹ãƒˆã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆæ‰‹å‹•/è‡ªå‹•ï¼‰
- å„ªå…ˆé †ä½ä»˜ã‘åŸºæº–

### 4. ãƒªã‚½ãƒ¼ã‚¹è¨ˆç”»
- ãƒ†ã‚¹ãƒˆãƒãƒ¼ãƒ æ§‹æˆ
- å½¹å‰²ã¨è²¬ä»»
- ãƒ†ã‚¹ãƒˆç’°å¢ƒ
- ãƒ„ãƒ¼ãƒ«ãƒ»ãƒ©ã‚¤ã‚»ãƒ³ã‚¹

### 5. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
- ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³
- ãƒ†ã‚¹ãƒˆãƒ•ã‚§ãƒ¼ã‚º
- é–‹å§‹/çµ‚äº†æ¡ä»¶
- ä¾å­˜é–¢ä¿‚

### 6. å“è³ªåŸºæº–
- åˆæ ¼åŸºæº–ï¼ˆEntry/Exit Criteriaï¼‰
- ã‚«ãƒãƒ¬ãƒƒã‚¸ç›®æ¨™
- å“è³ªãƒ¡ãƒˆãƒªã‚¯ã‚¹
- ãƒªãƒªãƒ¼ã‚¹åˆ¤å®šåŸºæº–

### 7. ãƒªã‚¹ã‚¯ç®¡ç†
- ç‰¹å®šã•ã‚ŒãŸãƒªã‚¹ã‚¯
- å½±éŸ¿åº¦è©•ä¾¡
- è»½æ¸›ç­–
- ã‚³ãƒ³ãƒ†ã‚£ãƒ³ã‚¸ã‚§ãƒ³ã‚·ãƒ¼ãƒ—ãƒ©ãƒ³

### 8. æˆæœç‰©
- ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
- ãƒ†ã‚¹ãƒˆçµæœãƒ¬ãƒãƒ¼ãƒˆ
- ãƒã‚°ãƒ¬ãƒãƒ¼ãƒˆ
- ãƒ¡ãƒˆãƒªã‚¯ã‚¹ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰
```

---

## ãƒ†ã‚¹ãƒˆæˆ¦ç•¥ç­–å®š

### ãƒªã‚¹ã‚¯ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ

**ãƒªã‚¹ã‚¯è©•ä¾¡ãƒãƒˆãƒªã‚¯ã‚¹:**

```swift
struct RiskAssessment {
    enum Probability: Int {
        case veryLow = 1    // ç™ºç”Ÿå¯èƒ½æ€§ < 10%
        case low = 2        // 10-30%
        case medium = 3     // 30-50%
        case high = 4       // 50-70%
        case veryHigh = 5   // > 70%
    }

    enum Impact: Int {
        case negligible = 1  // å½±éŸ¿ãªã—
        case minor = 2       // è»½å¾®
        case moderate = 3    // ä¸­ç¨‹åº¦
        case major = 4       // å¤§ãã„
        case critical = 5    // è‡´å‘½çš„
    }

    struct Risk {
        let id: String
        let description: String
        let probability: Probability
        let impact: Impact
        let mitigation: String

        var riskScore: Int {
            probability.rawValue * impact.rawValue
        }

        var priority: Priority {
            switch riskScore {
            case 1...4:   return .low
            case 5...9:   return .medium
            case 10...16: return .high
            case 17...25: return .critical
            default:      return .low
            }
        }

        enum Priority: String {
            case low = "Low (1-4)"
            case medium = "Medium (5-9)"
            case high = "High (10-16)"
            case critical = "Critical (17-25)"
        }
    }

    // ãƒªã‚¹ã‚¯åˆ†æ
    func analyzeRisks(_ risks: [Risk]) -> String {
        let critical = risks.filter { $0.priority == .critical }
        let high = risks.filter { $0.priority == .high }
        let medium = risks.filter { $0.priority == .medium }
        let low = risks.filter { $0.priority == .low }

        return """
        ãƒªã‚¹ã‚¯åˆ†æçµæœ:
        ===============
        Critical: \(critical.count)ä»¶ âš ï¸
        High:     \(high.count)ä»¶
        Medium:   \(medium.count)ä»¶
        Low:      \(low.count)ä»¶

        å³åº§ã«å¯¾å¿œãŒå¿…è¦ãªãƒªã‚¹ã‚¯:
        \(critical.map { "â€¢ [\($0.id)] \($0.description)" }.joined(separator: "\n"))

        å„ªå…ˆå¯¾å¿œãƒªã‚¹ã‚¯:
        \(high.map { "â€¢ [\($0.id)] \($0.description)" }.joined(separator: "\n"))
        """
    }
}

// ä½¿ç”¨ä¾‹
let risks = [
    RiskAssessment.Risk(
        id: "RISK-001",
        description: "æ±ºæ¸ˆAPIã®çµ±åˆãŒæœªå®Œäº†",
        probability: .high,
        impact: .critical,
        mitigation: "ãƒ¢ãƒƒã‚¯APIã§ã®ãƒ†ã‚¹ãƒˆ + çµ±åˆãƒ†ã‚¹ãƒˆã®å„ªå…ˆå®Ÿæ–½"
    ),
    RiskAssessment.Risk(
        id: "RISK-002",
        description: "iOS 18ã§ã®å‹•ä½œæœªç¢ºèª",
        probability: .medium,
        impact: .major,
        mitigation: "Betaç‰ˆãƒ‡ãƒã‚¤ã‚¹ã§ã®äº‹å‰ãƒ†ã‚¹ãƒˆ"
    ),
    RiskAssessment.Risk(
        id: "RISK-003",
        description: "å¤§é‡ãƒ‡ãƒ¼ã‚¿å‡¦ç†æ™‚ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹",
        probability: .medium,
        impact: .moderate,
        mitigation: "è² è·ãƒ†ã‚¹ãƒˆã®å®Ÿæ–½"
    ),
]

let assessment = RiskAssessment()
print(assessment.analyzeRisks(risks))
```

### ãƒ†ã‚¹ãƒˆãƒ¬ãƒ™ãƒ«åˆ¥æˆ¦ç•¥

**1. ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆæˆ¦ç•¥:**

```typescript
interface UnitTestStrategy {
  coverage: {
    target: number;           // ç›®æ¨™ã‚«ãƒãƒ¬ãƒƒã‚¸
    threshold: number;        // æœ€ä½ãƒ©ã‚¤ãƒ³
    excludePatterns: string[]; // é™¤å¤–ãƒ‘ã‚¿ãƒ¼ãƒ³
  };
  frameworks: string[];       // Jest, Vitest, etc.
  mockingStrategy: 'minimal' | 'moderate' | 'extensive';
  executionFrequency: 'every-commit' | 'every-push' | 'daily';
}

const unitTestStrategy: UnitTestStrategy = {
  coverage: {
    target: 85,
    threshold: 80,
    excludePatterns: [
      '**/*.test.ts',
      '**/*.spec.ts',
      '**/mocks/**',
      '**/fixtures/**',
    ],
  },
  frameworks: ['Vitest', 'Testing Library'],
  mockingStrategy: 'minimal', // å®Ÿè£…ä¾å­˜ã‚’æœ€å°åŒ–
  executionFrequency: 'every-commit',
};

// ãƒ†ã‚¹ãƒˆå‘½åè¦å‰‡
const testNamingConvention = {
  pattern: 'describe-it',
  example: `
    describe('UserService', () => {
      describe('createUser', () => {
        it('should create a new user with valid data', () => {
          // ...
        });

        it('should throw error when email is invalid', () => {
          // ...
        });
      });
    });
  `,
};
```

**2. çµ±åˆãƒ†ã‚¹ãƒˆæˆ¦ç•¥:**

```swift
struct IntegrationTestStrategy {
    // ãƒ†ã‚¹ãƒˆç¯„å›²
    enum Scope {
        case apiIntegration      // APIçµ±åˆ
        case databaseIntegration // DBçµ±åˆ
        case serviceIntegration  // ã‚µãƒ¼ãƒ“ã‚¹é–“é€£æº
        case thirdPartyIntegration // å¤–éƒ¨ã‚µãƒ¼ãƒ“ã‚¹çµ±åˆ
    }

    // ãƒ†ã‚¹ãƒˆç’°å¢ƒ
    struct Environment {
        let useRealDatabase: Bool
        let useTestContainers: Bool
        let mockExternalAPIs: Bool
        let isolationLevel: IsolationLevel

        enum IsolationLevel {
            case shared      // å…±æœ‰ç’°å¢ƒ
            case isolated    // åˆ†é›¢ç’°å¢ƒ
            case perTest     // ãƒ†ã‚¹ãƒˆæ¯ã«ç‹¬ç«‹
        }
    }

    // å®Ÿè¡Œæˆ¦ç•¥
    struct ExecutionStrategy {
        let parallelization: Bool
        let transactionRollback: Bool
        let dataCleanup: DataCleanupStrategy

        enum DataCleanupStrategy {
            case beforeEach  // å„ãƒ†ã‚¹ãƒˆå‰
            case afterEach   // å„ãƒ†ã‚¹ãƒˆå¾Œ
            case beforeSuite // ã‚¹ã‚¤ãƒ¼ãƒˆå‰
            case afterSuite  // ã‚¹ã‚¤ãƒ¼ãƒˆå¾Œ
        }
    }

    let scopes: [Scope]
    let environment: Environment
    let execution: ExecutionStrategy
}

// ä½¿ç”¨ä¾‹
let strategy = IntegrationTestStrategy(
    scopes: [.apiIntegration, .databaseIntegration],
    environment: IntegrationTestStrategy.Environment(
        useRealDatabase: false,
        useTestContainers: true,
        mockExternalAPIs: true,
        isolationLevel: .perTest
    ),
    execution: IntegrationTestStrategy.ExecutionStrategy(
        parallelization: true,
        transactionRollback: true,
        dataCleanup: .afterEach
    )
)
```

**3. E2Eãƒ†ã‚¹ãƒˆæˆ¦ç•¥:**

```typescript
interface E2ETestStrategy {
  // å¯¾è±¡ãƒ•ãƒ­ãƒ¼
  criticalUserFlows: string[];
  secondaryFlows: string[];

  // ãƒ–ãƒ©ã‚¦ã‚¶ãƒãƒˆãƒªã‚¯ã‚¹
  browsers: {
    name: string;
    versions: string[];
    priority: 'high' | 'medium' | 'low';
  }[];

  // ãƒ‡ãƒã‚¤ã‚¹ãƒãƒˆãƒªã‚¯ã‚¹
  devices: {
    type: 'desktop' | 'tablet' | 'mobile';
    viewportSizes: { width: number; height: number }[];
  }[];

  // å®Ÿè¡Œæˆ¦ç•¥
  execution: {
    frequency: 'every-pr' | 'nightly' | 'pre-release';
    parallelization: number;
    retryOnFailure: number;
    headless: boolean;
  };

  // ãƒ‡ãƒ¼ã‚¿æˆ¦ç•¥
  dataStrategy: {
    useProductionCopy: boolean;
    seedData: boolean;
    cleanup: boolean;
  };
}

const e2eStrategy: E2ETestStrategy = {
  criticalUserFlows: [
    'User Registration',
    'Login Flow',
    'Checkout Process',
    'Payment Flow',
  ],
  secondaryFlows: [
    'Profile Update',
    'Search Functionality',
    'Product Filtering',
  ],
  browsers: [
    { name: 'Chrome', versions: ['latest', 'latest-1'], priority: 'high' },
    { name: 'Safari', versions: ['latest'], priority: 'high' },
    { name: 'Firefox', versions: ['latest'], priority: 'medium' },
  ],
  devices: [
    {
      type: 'desktop',
      viewportSizes: [{ width: 1920, height: 1080 }],
    },
    {
      type: 'mobile',
      viewportSizes: [
        { width: 375, height: 667 }, // iPhone SE
        { width: 390, height: 844 }, // iPhone 14
      ],
    },
  ],
  execution: {
    frequency: 'every-pr',
    parallelization: 4,
    retryOnFailure: 2,
    headless: true,
  },
  dataStrategy: {
    useProductionCopy: false,
    seedData: true,
    cleanup: true,
  },
};
```

---

## ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹è¨­è¨ˆ

### å¢ƒç•Œå€¤åˆ†æï¼ˆBoundary Value Analysisï¼‰

```swift
struct BoundaryValueTester {
    // å¢ƒç•Œå€¤ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ç”Ÿæˆ
    func generateBoundaryTests(
        min: Int,
        max: Int,
        fieldName: String
    ) -> [TestCase] {
        var tests: [TestCase] = []

        // å¢ƒç•Œå€¤
        let values = [
            min - 1,        // æœ€å°å€¤æœªæº€ï¼ˆç„¡åŠ¹ï¼‰
            min,            // æœ€å°å€¤ï¼ˆæœ‰åŠ¹ï¼‰
            min + 1,        // æœ€å°å€¤è¶…ï¼ˆæœ‰åŠ¹ï¼‰
            (min + max) / 2, // ä¸­é–“å€¤ï¼ˆæœ‰åŠ¹ï¼‰
            max - 1,        // æœ€å¤§å€¤æœªæº€ï¼ˆæœ‰åŠ¹ï¼‰
            max,            // æœ€å¤§å€¤ï¼ˆæœ‰åŠ¹ï¼‰
            max + 1         // æœ€å¤§å€¤è¶…ï¼ˆç„¡åŠ¹ï¼‰
        ]

        for value in values {
            let isValid = value >= min && value <= max
            tests.append(TestCase(
                id: "TC-\(fieldName)-\(value)",
                input: value,
                expected: isValid ? .valid : .invalid,
                description: boundaryDescription(value, min, max)
            ))
        }

        return tests
    }

    private func boundaryDescription(_ value: Int, _ min: Int, _ max: Int) -> String {
        if value < min {
            return "æœ€å°å€¤æœªæº€: \(value) < \(min) â†’ ã‚¨ãƒ©ãƒ¼æœŸå¾…"
        } else if value == min {
            return "æœ€å°å€¤: \(value) = \(min) â†’ æ­£å¸¸"
        } else if value == min + 1 {
            return "æœ€å°å€¤è¶…: \(value) = \(min) + 1 â†’ æ­£å¸¸"
        } else if value == max - 1 {
            return "æœ€å¤§å€¤æœªæº€: \(value) = \(max) - 1 â†’ æ­£å¸¸"
        } else if value == max {
            return "æœ€å¤§å€¤: \(value) = \(max) â†’ æ­£å¸¸"
        } else if value > max {
            return "æœ€å¤§å€¤è¶…: \(value) > \(max) â†’ ã‚¨ãƒ©ãƒ¼æœŸå¾…"
        } else {
            return "ä¸­é–“å€¤: \(value) â†’ æ­£å¸¸"
        }
    }

    struct TestCase {
        let id: String
        let input: Int
        let expected: ExpectedResult
        let description: String

        enum ExpectedResult {
            case valid
            case invalid
        }
    }
}

// ä½¿ç”¨ä¾‹
let tester = BoundaryValueTester()
let ageTests = tester.generateBoundaryTests(
    min: 18,
    max: 120,
    fieldName: "Age"
)

for test in ageTests {
    print("\(test.id): \(test.description)")
}
```

### åŒå€¤åˆ†å‰²ï¼ˆEquivalence Partitioningï¼‰

```typescript
interface EquivalenceClass {
  id: string;
  description: string;
  validValues: any[];
  invalidValues: any[];
}

class EquivalencePartitionTester {
  // ãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹ã®åŒå€¤åˆ†å‰²
  generateEmailTests(): EquivalenceClass[] {
    return [
      {
        id: 'EMAIL-VALID',
        description: 'æœ‰åŠ¹ãªãƒ¡ãƒ¼ãƒ«ã‚¢ãƒ‰ãƒ¬ã‚¹',
        validValues: [
          'user@example.com',
          'test.user@example.co.jp',
          'user+tag@example.com',
          'user123@sub.example.com',
        ],
        invalidValues: [],
      },
      {
        id: 'EMAIL-INVALID-FORMAT',
        description: 'ç„¡åŠ¹ãªå½¢å¼',
        invalidValues: [
          'invalid',
          'user@',
          '@example.com',
          'user @example.com',
          'user@example',
        ],
        validValues: [],
      },
      {
        id: 'EMAIL-EMPTY',
        description: 'ç©ºæ–‡å­—',
        invalidValues: ['', null, undefined],
        validValues: [],
      },
    ];
  }

  // ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰å¼·åº¦ã®åŒå€¤åˆ†å‰²
  generatePasswordTests(): EquivalenceClass[] {
    return [
      {
        id: 'PWD-STRONG',
        description: 'å¼·ã„ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ï¼ˆ8æ–‡å­—ä»¥ä¸Šã€å¤§å°è‹±æ•°å­—è¨˜å·å«ã‚€ï¼‰',
        validValues: [
          'Abcd123!',
          'P@ssw0rd',
          'MyP@ss123',
        ],
        invalidValues: [],
      },
      {
        id: 'PWD-WEAK-LENGTH',
        description: 'çŸ­ã™ãã‚‹ï¼ˆ8æ–‡å­—æœªæº€ï¼‰',
        invalidValues: [
          'Abc123!',
          'Pass1!',
        ],
        validValues: [],
      },
      {
        id: 'PWD-WEAK-NO-UPPERCASE',
        description: 'å¤§æ–‡å­—ãªã—',
        invalidValues: [
          'abcd123!',
          'password123!',
        ],
        validValues: [],
      },
      {
        id: 'PWD-WEAK-NO-LOWERCASE',
        description: 'å°æ–‡å­—ãªã—',
        invalidValues: [
          'ABCD123!',
          'PASSWORD123!',
        ],
        validValues: [],
      },
      {
        id: 'PWD-WEAK-NO-NUMBER',
        description: 'æ•°å­—ãªã—',
        invalidValues: [
          'Abcdefgh!',
          'Password!',
        ],
        validValues: [],
      },
      {
        id: 'PWD-WEAK-NO-SPECIAL',
        description: 'è¨˜å·ãªã—',
        invalidValues: [
          'Abcd1234',
          'Password123',
        ],
        validValues: [],
      },
    ];
  }

  // ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ç”Ÿæˆ
  generateTestCases(classes: EquivalenceClass[]): TestCase[] {
    const testCases: TestCase[] = [];
    let id = 1;

    for (const eqClass of classes) {
      // æœ‰åŠ¹å€¤ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
      for (const value of eqClass.validValues) {
        testCases.push({
          id: `TC-${String(id++).padStart(3, '0')}`,
          equivalenceClass: eqClass.id,
          input: value,
          expected: 'valid',
          description: `${eqClass.description} - æœ‰åŠ¹: ${value}`,
        });
      }

      // ç„¡åŠ¹å€¤ã®ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
      for (const value of eqClass.invalidValues) {
        testCases.push({
          id: `TC-${String(id++).padStart(3, '0')}`,
          equivalenceClass: eqClass.id,
          input: value,
          expected: 'invalid',
          description: `${eqClass.description} - ç„¡åŠ¹: ${value}`,
        });
      }
    }

    return testCases;
  }
}

interface TestCase {
  id: string;
  equivalenceClass: string;
  input: any;
  expected: 'valid' | 'invalid';
  description: string;
}
```

### ãƒ‡ã‚·ã‚¸ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«

```markdown
## ãƒ‡ã‚·ã‚¸ãƒ§ãƒ³ãƒ†ãƒ¼ãƒ–ãƒ«ä¾‹: ãƒ­ã‚°ã‚¤ãƒ³æ©Ÿèƒ½

| Rule # | R1 | R2 | R3 | R4 | R5 | R6 | R7 | R8 |
|--------|----|----|----|----|----|----|----|----|
| **Conditions** |
| ç™»éŒ²ãƒ¦ãƒ¼ã‚¶ãƒ¼ | Y | Y | Y | Y | N | N | N | N |
| ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰æ­£ã—ã„ | Y | Y | N | N | - | - | - | - |
| ã‚¢ã‚«ã‚¦ãƒ³ãƒˆæœ‰åŠ¹ | Y | N | Y | N | - | - | - | - |
| **Actions** |
| ãƒ­ã‚°ã‚¤ãƒ³æˆåŠŸ | X | - | - | - | - | - | - | - |
| ã‚¢ã‚«ã‚¦ãƒ³ãƒˆç„¡åŠ¹ã‚¨ãƒ©ãƒ¼ | - | X | - | - | - | - | - | - |
| ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚¨ãƒ©ãƒ¼ | - | - | X | X | - | - | - | - |
| ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸å­˜åœ¨ã‚¨ãƒ©ãƒ¼ | - | - | - | - | X | X | X | X |
```

**å®Ÿè£…ä¾‹:**

```swift
struct LoginDecisionTable {
    struct Condition {
        let isRegisteredUser: Bool
        let isPasswordCorrect: Bool?
        let isAccountActive: Bool?
    }

    enum LoginResult {
        case success
        case accountInactive
        case wrongPassword
        case userNotFound
    }

    func evaluate(condition: Condition) -> LoginResult {
        // Rule R5-R8: ãƒ¦ãƒ¼ã‚¶ãƒ¼ãŒç™»éŒ²ã•ã‚Œã¦ã„ãªã„
        guard condition.isRegisteredUser else {
            return .userNotFound
        }

        // Rule R3-R4: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé–“é•ã£ã¦ã„ã‚‹
        guard condition.isPasswordCorrect == true else {
            return .wrongPassword
        }

        // Rule R2: ã‚¢ã‚«ã‚¦ãƒ³ãƒˆãŒç„¡åŠ¹
        guard condition.isAccountActive == true else {
            return .accountInactive
        }

        // Rule R1: ã™ã¹ã¦æº€ãŸã™
        return .success
    }

    // ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ç”Ÿæˆ
    func generateTestCases() -> [(Condition, LoginResult)] {
        return [
            // R1: æˆåŠŸ
            (Condition(isRegisteredUser: true, isPasswordCorrect: true, isAccountActive: true),
             .success),

            // R2: ã‚¢ã‚«ã‚¦ãƒ³ãƒˆç„¡åŠ¹
            (Condition(isRegisteredUser: true, isPasswordCorrect: true, isAccountActive: false),
             .accountInactive),

            // R3: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰é–“é•ã„ï¼ˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆæœ‰åŠ¹ï¼‰
            (Condition(isRegisteredUser: true, isPasswordCorrect: false, isAccountActive: true),
             .wrongPassword),

            // R4: ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰é–“é•ã„ï¼ˆã‚¢ã‚«ã‚¦ãƒ³ãƒˆç„¡åŠ¹ï¼‰
            (Condition(isRegisteredUser: true, isPasswordCorrect: false, isAccountActive: false),
             .wrongPassword),

            // R5-R8: ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸å­˜åœ¨
            (Condition(isRegisteredUser: false, isPasswordCorrect: nil, isAccountActive: nil),
             .userNotFound),
        ]
    }
}
```

---

## ãƒ†ã‚¹ãƒˆå®Ÿè¡Œç®¡ç†

### ãƒ†ã‚¹ãƒˆå®Ÿè¡Œãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°

```typescript
interface TestExecution {
  id: string;
  testCaseId: string;
  executedBy: string;
  executedAt: Date;
  status: 'passed' | 'failed' | 'blocked' | 'skipped';
  duration: number; // ãƒŸãƒªç§’
  environment: string;
  buildVersion: string;
  comments?: string;
  attachments?: string[];
  defects?: string[]; // é–¢é€£ãƒã‚°ID
}

class TestExecutionManager {
  private executions: TestExecution[] = [];

  // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œè¨˜éŒ²
  recordExecution(execution: TestExecution): void {
    this.executions.push(execution);
    this.updateMetrics();
    this.checkForAlerts(execution);
  }

  // å®Ÿè¡Œçµ±è¨ˆ
  getExecutionStats(timeRange?: { start: Date; end: Date }): ExecutionStats {
    let filtered = this.executions;

    if (timeRange) {
      filtered = filtered.filter(
        e => e.executedAt >= timeRange.start && e.executedAt <= timeRange.end
      );
    }

    const total = filtered.length;
    const passed = filtered.filter(e => e.status === 'passed').length;
    const failed = filtered.filter(e => e.status === 'failed').length;
    const blocked = filtered.filter(e => e.status === 'blocked').length;
    const skipped = filtered.filter(e => e.status === 'skipped').length;

    const totalDuration = filtered.reduce((sum, e) => sum + e.duration, 0);
    const avgDuration = total > 0 ? totalDuration / total : 0;

    return {
      total,
      passed,
      failed,
      blocked,
      skipped,
      passRate: total > 0 ? (passed / total) * 100 : 0,
      failRate: total > 0 ? (failed / total) * 100 : 0,
      avgDuration,
      totalDuration,
    };
  }

  // å¤±æ•—ãƒ†ã‚¹ãƒˆã®åˆ†æ
  analyzeFailures(): FailureAnalysis {
    const failures = this.executions.filter(e => e.status === 'failed');

    // ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹æ¯ã®å¤±æ•—å›æ•°
    const failuresByTestCase = new Map<string, number>();
    for (const failure of failures) {
      const count = failuresByTestCase.get(failure.testCaseId) || 0;
      failuresByTestCase.set(failure.testCaseId, count + 1);
    }

    // æœ€ã‚‚å¤±æ•—ã—ã¦ã„ã‚‹ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹
    const topFailingTests = Array.from(failuresByTestCase.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10)
      .map(([testCaseId, count]) => ({ testCaseId, count }));

    // ç’°å¢ƒåˆ¥å¤±æ•—ç‡
    const failuresByEnv = new Map<string, number>();
    for (const failure of failures) {
      const count = failuresByEnv.get(failure.environment) || 0;
      failuresByEnv.set(failure.environment, count + 1);
    }

    return {
      totalFailures: failures.length,
      topFailingTests,
      failuresByEnvironment: Array.from(failuresByEnv.entries()).map(
        ([env, count]) => ({ environment: env, count })
      ),
    };
  }

  // ã‚¢ãƒ©ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
  private checkForAlerts(execution: TestExecution): void {
    // é€£ç¶šå¤±æ•—ã®æ¤œå‡º
    const recentExecutions = this.executions
      .filter(e => e.testCaseId === execution.testCaseId)
      .slice(-3);

    if (recentExecutions.every(e => e.status === 'failed')) {
      this.sendAlert(`Test ${execution.testCaseId} has failed 3 times in a row`);
    }

    // å®Ÿè¡Œæ™‚é–“ã®ç•°å¸¸
    const historicalDurations = this.executions
      .filter(e => e.testCaseId === execution.testCaseId)
      .map(e => e.duration);

    if (historicalDurations.length > 0) {
      const avgDuration = historicalDurations.reduce((a, b) => a + b, 0) / historicalDurations.length;

      if (execution.duration > avgDuration * 2) {
        this.sendAlert(`Test ${execution.testCaseId} took ${execution.duration}ms (avg: ${avgDuration}ms)`);
      }
    }
  }

  private updateMetrics(): void {
    // ãƒ¡ãƒˆãƒªã‚¯ã‚¹æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯
  }

  private sendAlert(message: string): void {
    console.log(`ğŸš¨ ALERT: ${message}`);
    // Slack/Emailé€šçŸ¥
  }
}

interface ExecutionStats {
  total: number;
  passed: number;
  failed: number;
  blocked: number;
  skipped: number;
  passRate: number;
  failRate: number;
  avgDuration: number;
  totalDuration: number;
}

interface FailureAnalysis {
  totalFailures: number;
  topFailingTests: { testCaseId: string; count: number }[];
  failuresByEnvironment: { environment: string; count: number }[];
}
```

### ãƒ†ã‚¹ãƒˆçµæœãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ

```swift
struct TestResultReport {
    let summary: Summary
    let details: [TestCaseResult]
    let metrics: Metrics
    let generatedAt: Date

    struct Summary {
        let totalTests: Int
        let passed: Int
        let failed: Int
        let skipped: Int
        let duration: TimeInterval

        var passRate: Double {
            guard totalTests > 0 else { return 0 }
            return (Double(passed) / Double(totalTests)) * 100
        }
    }

    struct TestCaseResult {
        let id: String
        let name: String
        let status: Status
        let duration: TimeInterval
        let errorMessage: String?
        let stackTrace: String?

        enum Status: String {
            case passed = "âœ… Passed"
            case failed = "âŒ Failed"
            case skipped = "â­ï¸ Skipped"
        }
    }

    struct Metrics {
        let coveragePercentage: Double
        let newBugsFound: Int
        let environmentDetails: String
    }

    // HTML ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ
    func generateHTML() -> String {
        """
        <!DOCTYPE html>
        <html>
        <head>
            <title>Test Report - \(formatDate(generatedAt))</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                .summary { background: #f0f0f0; padding: 20px; border-radius: 8px; }
                .passed { color: green; }
                .failed { color: red; }
                .skipped { color: gray; }
                table { width: 100%; border-collapse: collapse; margin-top: 20px; }
                th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
                th { background-color: #4CAF50; color: white; }
            </style>
        </head>
        <body>
            <h1>Test Execution Report</h1>
            <p>Generated: \(formatDate(generatedAt))</p>

            <div class="summary">
                <h2>Summary</h2>
                <p>Total Tests: <strong>\(summary.totalTests)</strong></p>
                <p class="passed">Passed: <strong>\(summary.passed)</strong></p>
                <p class="failed">Failed: <strong>\(summary.failed)</strong></p>
                <p class="skipped">Skipped: <strong>\(summary.skipped)</strong></p>
                <p>Pass Rate: <strong>\(String(format: "%.1f", summary.passRate))%</strong></p>
                <p>Duration: <strong>\(formatDuration(summary.duration))</strong></p>
            </div>

            <h2>Metrics</h2>
            <ul>
                <li>Code Coverage: \(String(format: "%.1f", metrics.coveragePercentage))%</li>
                <li>New Bugs Found: \(metrics.newBugsFound)</li>
                <li>Environment: \(metrics.environmentDetails)</li>
            </ul>

            <h2>Test Results</h2>
            <table>
                <thead>
                    <tr>
                        <th>Test Case</th>
                        <th>Status</th>
                        <th>Duration</th>
                        <th>Error</th>
                    </tr>
                </thead>
                <tbody>
                    \(generateTableRows())
                </tbody>
            </table>
        </body>
        </html>
        """
    }

    private func generateTableRows() -> String {
        details.map { result in
            """
            <tr>
                <td>\(result.name)</td>
                <td class="\(result.status.rawValue.lowercased())">\(result.status.rawValue)</td>
                <td>\(formatDuration(result.duration))</td>
                <td>\(result.errorMessage ?? "-")</td>
            </tr>
            """
        }.joined(separator: "\n")
    }

    private func formatDate(_ date: Date) -> String {
        let formatter = DateFormatter()
        formatter.dateStyle = .medium
        formatter.timeStyle = .short
        return formatter.string(from: date)
    }

    private func formatDuration(_ duration: TimeInterval) -> String {
        String(format: "%.2fs", duration)
    }
}
```

---

## ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ç®¡ç†

### ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿æˆ¦ç•¥

```typescript
interface TestDataStrategy {
  // ãƒ‡ãƒ¼ã‚¿ã‚½ãƒ¼ã‚¹
  sources: {
    production: boolean;      // æœ¬ç•ªãƒ‡ãƒ¼ã‚¿ã®ã‚³ãƒ”ãƒ¼
    synthetic: boolean;       // åˆæˆãƒ‡ãƒ¼ã‚¿
    fixtures: boolean;        // å›ºå®šãƒ‡ãƒ¼ã‚¿
    userGenerated: boolean;   // ãƒ¦ãƒ¼ã‚¶ãƒ¼ç”Ÿæˆãƒ‡ãƒ¼ã‚¿
  };

  // ãƒ‡ãƒ¼ã‚¿ç®¡ç†
  management: {
    versionControl: boolean;  // ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†
    encryption: boolean;      // æš—å·åŒ–
    anonymization: boolean;   // åŒ¿ååŒ–
    cleanup: 'manual' | 'auto' | 'scheduled';
  };

  // ãƒ‡ãƒ¼ã‚¿ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥
  refresh: {
    frequency: 'daily' | 'weekly' | 'monthly';
    automated: boolean;
    validationRequired: boolean;
  };
}

// ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ãƒ•ã‚¡ã‚¯ãƒˆãƒªãƒ¼
class TestDataFactory {
  // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
  createUser(overrides?: Partial<User>): User {
    const faker = require('@faker-js/faker').faker;

    return {
      id: faker.string.uuid(),
      email: faker.internet.email(),
      firstName: faker.person.firstName(),
      lastName: faker.person.lastName(),
      age: faker.number.int({ min: 18, max: 80 }),
      address: {
        street: faker.location.streetAddress(),
        city: faker.location.city(),
        country: faker.location.country(),
        zipCode: faker.location.zipCode(),
      },
      createdAt: faker.date.past(),
      ...overrides,
    };
  }

  // ãƒ—ãƒ­ãƒ€ã‚¯ãƒˆãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
  createProduct(overrides?: Partial<Product>): Product {
    const faker = require('@faker-js/faker').faker;

    return {
      id: faker.string.uuid(),
      name: faker.commerce.productName(),
      description: faker.commerce.productDescription(),
      price: parseFloat(faker.commerce.price()),
      category: faker.commerce.department(),
      inStock: faker.datatype.boolean(),
      sku: faker.string.alphanumeric(10).toUpperCase(),
      ...overrides,
    };
  }

  // æ³¨æ–‡ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
  createOrder(userId: string, productIds: string[]): Order {
    const faker = require('@faker-js/faker').faker;

    return {
      id: faker.string.uuid(),
      userId,
      productIds,
      status: faker.helpers.arrayElement(['pending', 'processing', 'shipped', 'delivered']),
      total: parseFloat(faker.commerce.price({ min: 10, max: 1000 })),
      createdAt: faker.date.recent(),
      shippingAddress: {
        street: faker.location.streetAddress(),
        city: faker.location.city(),
        country: faker.location.country(),
        zipCode: faker.location.zipCode(),
      },
    };
  }

  // ä¸€æ‹¬ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
  createBulkUsers(count: number): User[] {
    return Array.from({ length: count }, () => this.createUser());
  }

  createBulkProducts(count: number): Product[] {
    return Array.from({ length: count }, () => this.createProduct());
  }
}

// ä½¿ç”¨ä¾‹
const factory = new TestDataFactory();

// å˜ä¸€ãƒ¦ãƒ¼ã‚¶ãƒ¼ç”Ÿæˆ
const user = factory.createUser({
  email: 'test@example.com', // ç‰¹å®šã®å€¤ã‚’ä¸Šæ›¸ã
});

// 100äººã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ç”Ÿæˆ
const users = factory.createBulkUsers(100);

// æ³¨æ–‡ç”Ÿæˆ
const order = factory.createOrder(user.id, [
  'product-id-1',
  'product-id-2',
]);
```

### ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚·ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°

```typescript
import { PrismaClient } from '@prisma/client';
import { TestDataFactory } from './test-data-factory';

class DatabaseSeeder {
  private prisma = new PrismaClient();
  private factory = new TestDataFactory();

  async seedAll(): Promise<void> {
    await this.cleanDatabase();
    await this.seedUsers();
    await this.seedProducts();
    await this.seedOrders();
  }

  async cleanDatabase(): Promise<void> {
    // ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã§å…¨ãƒ‡ãƒ¼ã‚¿å‰Šé™¤
    await this.prisma.$transaction([
      this.prisma.order.deleteMany(),
      this.prisma.product.deleteMany(),
      this.prisma.user.deleteMany(),
    ]);
  }

  async seedUsers(): Promise<void> {
    const users = this.factory.createBulkUsers(50);

    for (const user of users) {
      await this.prisma.user.create({
        data: user,
      });
    }

    console.log('âœ… Seeded 50 users');
  }

  async seedProducts(): Promise<void> {
    const products = this.factory.createBulkProducts(100);

    await this.prisma.product.createMany({
      data: products,
    });

    console.log('âœ… Seeded 100 products');
  }

  async seedOrders(): Promise<void> {
    const users = await this.prisma.user.findMany();
    const products = await this.prisma.product.findMany();

    for (let i = 0; i < 200; i++) {
      const randomUser = users[Math.floor(Math.random() * users.length)];
      const randomProducts = products
        .sort(() => 0.5 - Math.random())
        .slice(0, Math.floor(Math.random() * 5) + 1);

      const order = this.factory.createOrder(
        randomUser.id,
        randomProducts.map(p => p.id)
      );

      await this.prisma.order.create({
        data: order,
      });
    }

    console.log('âœ… Seeded 200 orders');
  }

  async disconnect(): Promise<void> {
    await this.prisma.$disconnect();
  }
}

// å®Ÿè¡Œã‚¹ã‚¯ãƒªãƒ—ãƒˆ
async function main() {
  const seeder = new DatabaseSeeder();

  try {
    console.log('ğŸŒ± Starting database seeding...');
    await seeder.seedAll();
    console.log('âœ… Database seeding completed');
  } catch (error) {
    console.error('âŒ Seeding failed:', error);
    process.exit(1);
  } finally {
    await seeder.disconnect();
  }
}

main();
```

---

## ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ

### ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

```swift
struct RegressionTestStrategy {
    // ãƒ†ã‚¹ãƒˆé¸æŠæˆ¦ç•¥
    enum SelectionStrategy {
        case fullRegression      // å…¨ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
        case impactBased        // å½±éŸ¿ç¯„å›²ãƒ™ãƒ¼ã‚¹
        case riskBased          // ãƒªã‚¹ã‚¯ãƒ™ãƒ¼ã‚¹
        case timeBased          // æ™‚é–“åˆ¶ç´„ãƒ™ãƒ¼ã‚¹
    }

    // å®Ÿè¡Œé »åº¦
    enum ExecutionFrequency {
        case everyCommit        // ã‚³ãƒŸãƒƒãƒˆæ¯
        case everyPR            // PRæ¯
        case nightly            // å¤œé–“ãƒãƒƒãƒ
        case weekly             // é€±æ¬¡
        case preRelease         // ãƒªãƒªãƒ¼ã‚¹å‰
    }

    // å„ªå…ˆåº¦
    enum Priority {
        case critical           // æœ€é‡è¦ï¼ˆå¸¸ã«å®Ÿè¡Œï¼‰
        case high              // é‡è¦ï¼ˆé€±1å›ä»¥ä¸Šï¼‰
        case medium            // ä¸­ç¨‹åº¦ï¼ˆæœˆ1å›ä»¥ä¸Šï¼‰
        case low               // ä½ï¼ˆãƒªãƒªãƒ¼ã‚¹å‰ã®ã¿ï¼‰
    }

    struct TestCase {
        let id: String
        let name: String
        let priority: Priority
        let executionTime: TimeInterval
        let lastExecuted: Date?
        let failureHistory: [Date]

        var failureRate: Double {
            // éå»30æ—¥ã®å¤±æ•—ç‡
            let thirtyDaysAgo = Date().addingTimeInterval(-30 * 86400)
            let recentFailures = failureHistory.filter { $0 > thirtyDaysAgo }
            // ç°¡æ˜“è¨ˆç®—ï¼ˆå®Ÿéš›ã¯å®Ÿè¡Œå›æ•°ã‚‚è€ƒæ…®ï¼‰
            return Double(recentFailures.count) / 30.0
        }

        var shouldRunInQuickRegression: Bool {
            // ã‚¯ã‚¤ãƒƒã‚¯ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ã«å«ã‚ã‚‹ã¹ãã‹
            return priority == .critical ||
                   failureRate > 0.1 ||
                   executionTime < 30
        }
    }

    // å½±éŸ¿ç¯„å›²åˆ†æ
    func analyzeImpact(changedFiles: [String], allTests: [TestCase]) -> [TestCase] {
        // å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã«é–¢é€£ã™ã‚‹ãƒ†ã‚¹ãƒˆã‚’æŠ½å‡º
        // å®Ÿéš›ã¯ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ‡ãƒ¼ã‚¿ã‚„ASTè§£æã‚’ä½¿ç”¨
        var impactedTests: [TestCase] = []

        for file in changedFiles {
            if file.contains("User") {
                impactedTests.append(contentsOf: allTests.filter { $0.name.contains("User") })
            }
            if file.contains("Payment") {
                impactedTests.append(contentsOf: allTests.filter { $0.name.contains("Payment") })
            }
        }

        return Array(Set(impactedTests))
    }

    // ãƒ†ã‚¹ãƒˆé¸æŠ
    func selectTests(
        strategy: SelectionStrategy,
        allTests: [TestCase],
        timeLimit: TimeInterval? = nil,
        changedFiles: [String] = []
    ) -> [TestCase] {
        switch strategy {
        case .fullRegression:
            return allTests

        case .impactBased:
            return analyzeImpact(changedFiles: changedFiles, allTests: allTests)

        case .riskBased:
            return allTests
                .sorted { $0.failureRate > $1.failureRate }
                .prefix(100)
                .map { $0 }

        case .timeBased:
            guard let limit = timeLimit else { return allTests }

            var selected: [TestCase] = []
            var totalTime: TimeInterval = 0

            // å„ªå…ˆåº¦é †ã€å®Ÿè¡Œæ™‚é–“ã®çŸ­ã„é †ã«é¸æŠ
            let sorted = allTests.sorted {
                if $0.priority != $1.priority {
                    return $0.priority.rawValue < $1.priority.rawValue
                }
                return $0.executionTime < $1.executionTime
            }

            for test in sorted {
                if totalTime + test.executionTime <= limit {
                    selected.append(test)
                    totalTime += test.executionTime
                }
            }

            return selected
        }
    }
}
```

### ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ã‚¹ã‚¤ãƒ¼ãƒˆç®¡ç†

```typescript
class RegressionSuiteManager {
  private suites: Map<string, TestSuite> = new Map();

  // ã‚¹ã‚¤ãƒ¼ãƒˆå®šç¾©
  defineSuites(): void {
    // ã‚¯ã‚¤ãƒƒã‚¯ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ï¼ˆ5åˆ†ä»¥å†…ï¼‰
    this.suites.set('quick', {
      name: 'Quick Regression',
      maxDuration: 300, // 5åˆ†
      tests: [
        // Critical smoke tests
        'auth.login',
        'auth.logout',
        'payment.checkout',
        'product.search',
      ],
    });

    // æ¨™æº–ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ï¼ˆ30åˆ†ä»¥å†…ï¼‰
    this.suites.set('standard', {
      name: 'Standard Regression',
      maxDuration: 1800, // 30åˆ†
      tests: [
        ...this.suites.get('quick')!.tests,
        'user.registration',
        'user.profile',
        'product.filter',
        'product.sort',
        'cart.add',
        'cart.remove',
        'order.history',
      ],
    });

    // å®Œå…¨ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ï¼ˆ2æ™‚é–“ä»¥å†…ï¼‰
    this.suites.set('full', {
      name: 'Full Regression',
      maxDuration: 7200, // 2æ™‚é–“
      tests: ['**/*'], // ã™ã¹ã¦
    });
  }

  // ã‚¹ã‚¤ãƒ¼ãƒˆå®Ÿè¡Œ
  async runSuite(suiteName: string): Promise<SuiteResult> {
    const suite = this.suites.get(suiteName);
    if (!suite) {
      throw new Error(`Suite '${suiteName}' not found`);
    }

    console.log(`Running ${suite.name}...`);
    const startTime = Date.now();

    const results: TestResult[] = [];

    for (const testPattern of suite.tests) {
      // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œï¼ˆå®Ÿéš›ã®å®Ÿè£…ï¼‰
      const result = await this.executeTest(testPattern);
      results.push(result);

      // æ™‚é–“åˆ¶é™ãƒã‚§ãƒƒã‚¯
      const elapsed = (Date.now() - startTime) / 1000;
      if (elapsed > suite.maxDuration) {
        console.warn(`âš ï¸ Suite exceeded time limit: ${elapsed}s > ${suite.maxDuration}s`);
        break;
      }
    }

    const duration = (Date.now() - startTime) / 1000;
    const passed = results.filter(r => r.status === 'passed').length;
    const failed = results.filter(r => r.status === 'failed').length;

    return {
      suiteName: suite.name,
      duration,
      totalTests: results.length,
      passed,
      failed,
      passRate: (passed / results.length) * 100,
    };
  }

  private async executeTest(pattern: string): Promise<TestResult> {
    // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œãƒ­ã‚¸ãƒƒã‚¯
    return {
      testId: pattern,
      status: 'passed',
      duration: 1.5,
    };
  }
}

interface TestSuite {
  name: string;
  maxDuration: number; // ç§’
  tests: string[];
}

interface TestResult {
  testId: string;
  status: 'passed' | 'failed' | 'skipped';
  duration: number;
}

interface SuiteResult {
  suiteName: string;
  duration: number;
  totalTests: number;
  passed: number;
  failed: number;
  passRate: number;
}
```

---

## ãƒ†ã‚¹ãƒˆç’°å¢ƒç®¡ç†

### ç’°å¢ƒæ§‹æˆç®¡ç†

```yaml
# environments.yml
environments:
  development:
    api_url: "http://localhost:3000"
    database:
      host: "localhost"
      port: 5432
      name: "app_dev"
    features:
      - feature_flags: true
      - analytics: false
    credentials:
      use_test_accounts: true

  staging:
    api_url: "https://staging-api.example.com"
    database:
      host: "staging-db.example.com"
      port: 5432
      name: "app_staging"
    features:
      - feature_flags: true
      - analytics: true
    credentials:
      use_test_accounts: true

  production:
    api_url: "https://api.example.com"
    database:
      host: "prod-db.example.com"
      port: 5432
      name: "app_prod"
    features:
      - feature_flags: false
      - analytics: true
    credentials:
      use_test_accounts: false
```

**ç’°å¢ƒåˆ‡ã‚Šæ›¿ãˆ:**

```typescript
import { config } from 'dotenv';
import { readFileSync } from 'fs';
import * as yaml from 'js-yaml';

class EnvironmentManager {
  private environments: Map<string, EnvironmentConfig>;
  private currentEnv: string;

  constructor() {
    this.environments = this.loadEnvironments();
    this.currentEnv = process.env.TEST_ENV || 'development';
  }

  private loadEnvironments(): Map<string, EnvironmentConfig> {
    const file = readFileSync('environments.yml', 'utf8');
    const data = yaml.load(file) as { environments: Record<string, EnvironmentConfig> };

    return new Map(Object.entries(data.environments));
  }

  getConfig(): EnvironmentConfig {
    const config = this.environments.get(this.currentEnv);
    if (!config) {
      throw new Error(`Environment '${this.currentEnv}' not found`);
    }
    return config;
  }

  switchEnvironment(env: string): void {
    if (!this.environments.has(env)) {
      throw new Error(`Environment '${env}' not found`);
    }
    this.currentEnv = env;
    console.log(`Switched to ${env} environment`);
  }

  isProduction(): boolean {
    return this.currentEnv === 'production';
  }
}

interface EnvironmentConfig {
  api_url: string;
  database: {
    host: string;
    port: number;
    name: string;
  };
  features: Record<string, boolean>[];
  credentials: {
    use_test_accounts: boolean;
  };
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
export const envManager = new EnvironmentManager();

// ä½¿ç”¨ä¾‹
const config = envManager.getConfig();
console.log(`API URL: ${config.api_url}`);
```

---

## å®Ÿè·µä¾‹ã¨ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£

### ã‚±ãƒ¼ã‚¹ã‚¹ã‚¿ãƒ‡ã‚£: ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒªã®ãƒ†ã‚¹ãƒˆè¨ˆç”»

**ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ¦‚è¦:**
- iOS/Androidã‚¢ãƒ—ãƒª
- ä¸»è¦æ©Ÿèƒ½: SNSã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ã€æ±ºæ¸ˆ
- ãƒªãƒªãƒ¼ã‚¹ã‚µã‚¤ã‚¯ãƒ«: 2é€±é–“

**ãƒ†ã‚¹ãƒˆè¨ˆç”»:**

```markdown
# ãƒ¢ãƒã‚¤ãƒ«ã‚¢ãƒ—ãƒª ãƒ†ã‚¹ãƒˆè¨ˆç”»æ›¸ v2.0

## 1. ãƒ†ã‚¹ãƒˆå¯¾è±¡

### å¯¾è±¡æ©Ÿèƒ½
âœ… ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ï¼ˆç™»éŒ²ã€ãƒ­ã‚°ã‚¤ãƒ³ã€ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãƒªã‚»ãƒƒãƒˆï¼‰
âœ… ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«ç®¡ç†
âœ… æŠ•ç¨¿æ©Ÿèƒ½ï¼ˆä½œæˆã€ç·¨é›†ã€å‰Šé™¤ï¼‰
âœ… ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ³ã‚°ï¼ˆ1å¯¾1ã€ã‚°ãƒ«ãƒ¼ãƒ—ï¼‰
âœ… æ±ºæ¸ˆæ©Ÿèƒ½ï¼ˆèª²é‡‘ã€è³¼å…¥å±¥æ­´ï¼‰
âœ… ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥

### å¯¾è±¡å¤–
âŒ ç®¡ç†ç”»é¢ï¼ˆåˆ¥ãƒ†ã‚¹ãƒˆè¨ˆç”»ï¼‰
âŒ åˆ†æãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ï¼ˆå†…éƒ¨ãƒ„ãƒ¼ãƒ«ï¼‰

## 2. ãƒ†ã‚¹ãƒˆç’°å¢ƒ

### ãƒ‡ãƒã‚¤ã‚¹ãƒãƒˆãƒªã‚¯ã‚¹

| OS | ãƒ‡ãƒã‚¤ã‚¹ | ãƒãƒ¼ã‚¸ãƒ§ãƒ³ | å„ªå…ˆåº¦ |
|----|---------|-----------|--------|
| iOS | iPhone 14 Pro | 17.0 | High |
| iOS | iPhone SE | 16.0 | Medium |
| iOS | iPad Pro 12.9" | 17.0 | Medium |
| Android | Pixel 7 | Android 14 | High |
| Android | Galaxy S23 | Android 14 | Medium |
| Android | Galaxy Tab | Android 13 | Low |

### ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¡ä»¶
- WiFiï¼ˆé«˜é€Ÿï¼‰
- 4Gï¼ˆæ¨™æº–ï¼‰
- 3Gï¼ˆä½é€Ÿï¼‰
- ã‚ªãƒ•ãƒ©ã‚¤ãƒ³

## 3. ãƒ†ã‚¹ãƒˆæˆ¦ç•¥

### ãƒ¦ãƒ‹ãƒƒãƒˆãƒ†ã‚¹ãƒˆï¼ˆ70%ï¼‰
- ç›®æ¨™ã‚«ãƒãƒ¬ãƒƒã‚¸: 85%
- ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: XCTest (iOS), JUnit (Android)
- å®Ÿè¡Œ: ã‚³ãƒŸãƒƒãƒˆæ¯

### çµ±åˆãƒ†ã‚¹ãƒˆï¼ˆ20%ï¼‰
- APIçµ±åˆãƒ†ã‚¹ãƒˆ
- ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ãƒ†ã‚¹ãƒˆ
- å®Ÿè¡Œ: PRæ¯

### E2Eãƒ†ã‚¹ãƒˆï¼ˆ10%ï¼‰
- ã‚¯ãƒªãƒ†ã‚£ã‚«ãƒ«ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ•ãƒ­ãƒ¼
- ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¯ãƒ¼ã‚¯: Detox (React Native)
- å®Ÿè¡Œ: Nightly

## 4. ãƒªã‚¹ã‚¯ç®¡ç†

| ãƒªã‚¹ã‚¯ | ç¢ºç‡ | å½±éŸ¿ | å¯¾ç­– |
|--------|------|------|------|
| æ±ºæ¸ˆAPIéšœå®³ | Medium | Critical | ãƒ¢ãƒƒã‚¯APIã§ã®ãƒ†ã‚¹ãƒˆ + Sandboxç’°å¢ƒãƒ†ã‚¹ãƒˆ |
| ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥é…å»¶ | High | Medium | é…å»¶ãƒ†ã‚¹ãƒˆã‚·ãƒŠãƒªã‚ªè¿½åŠ  |
| ãƒ‡ãƒ¼ã‚¿åŒæœŸå¤±æ•— | Medium | High | ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰ãƒ†ã‚¹ãƒˆå¼·åŒ– |

## 5. ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«

| Phase | æœŸé–“ | æ‹…å½“ |
|-------|------|------|
| ãƒ†ã‚¹ãƒˆã‚±ãƒ¼ã‚¹ä½œæˆ | 3æ—¥ | QAãƒãƒ¼ãƒ  |
| æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ | 5æ—¥ | QA + Dev |
| ãƒªã‚°ãƒ¬ãƒƒã‚·ãƒ§ãƒ³ãƒ†ã‚¹ãƒˆ | 2æ—¥ | QAãƒãƒ¼ãƒ  |
| æœ€çµ‚ç¢ºèª | 1æ—¥ | å…¨å“¡ |

## 6. å“è³ªåŸºæº–

### ãƒªãƒªãƒ¼ã‚¹å¯èƒ½åŸºæº–
- [ ] Criticalãƒã‚°: 0ä»¶
- [ ] Majorãƒã‚°: 3ä»¶ä»¥ä¸‹
- [ ] ãƒ†ã‚¹ãƒˆPassç‡: 95%ä»¥ä¸Š
- [ ] ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ç‡: 0.1%ä»¥ä¸‹
- [ ] ã‚³ãƒ¼ãƒ‰ã‚«ãƒãƒ¬ãƒƒã‚¸: 80%ä»¥ä¸Š

## 7. æˆæœç‰©
- ãƒ†ã‚¹ãƒˆçµæœãƒ¬ãƒãƒ¼ãƒˆ (HTML)
- ãƒã‚°ãƒ¬ãƒãƒ¼ãƒˆ (Jira)
- ã‚«ãƒãƒ¬ãƒƒã‚¸ãƒ¬ãƒãƒ¼ãƒˆ (Codecov)
- ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ¬ãƒãƒ¼ãƒˆ (Firebase)
```

---

## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºç­–

**1. ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚é–“ãŒé•·ã™ãã‚‹**

```markdown
## å•é¡Œ: ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ™‚é–“ãŒé•·ã„

### ç—‡çŠ¶
- ãƒ•ãƒ«ãƒ†ã‚¹ãƒˆã‚¹ã‚¤ãƒ¼ãƒˆãŒ2æ™‚é–“ä»¥ä¸Šã‹ã‹ã‚‹
- é–‹ç™ºè€…ãŒãƒ†ã‚¹ãƒˆã‚’å¾…ã¦ãªã„
- CI/CDãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ãŒãƒœãƒˆãƒ«ãƒãƒƒã‚¯

### åŸå› 
âŒ ã™ã¹ã¦ã®ãƒ†ã‚¹ãƒˆã‚’é€æ¬¡å®Ÿè¡Œ
âŒ é‡è¤‡ã—ãŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—/ãƒ†ã‚£ã‚¢ãƒ€ã‚¦ãƒ³
âŒ ä¸è¦ãªE2Eãƒ†ã‚¹ãƒˆãŒå¤šã„
âŒ ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ç”ŸæˆãŒé…ã„

### è§£æ±ºç­–
âœ… ä¸¦åˆ—å®Ÿè¡Œã‚’æœ‰åŠ¹åŒ–ï¼ˆJest --maxWorkers=4ï¼‰
âœ… ãƒ†ã‚¹ãƒˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰ã®è¦‹ç›´ã—ï¼ˆE2Eå‰Šæ¸›ï¼‰
âœ… ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã®å…±æœ‰åŒ–
âœ… ãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿ã®ã‚­ãƒ£ãƒƒã‚·ãƒ³ã‚°
âœ… ã‚¯ã‚¤ãƒƒã‚¯ã‚¹ã‚¤ãƒ¼ãƒˆã®ä½œæˆï¼ˆ5åˆ†ä»¥å†…ï¼‰
```

**2. ãƒ†ã‚¹ãƒˆãŒä¸å®‰å®šï¼ˆFlaky Testsï¼‰**

```markdown
## å•é¡Œ: ãƒ†ã‚¹ãƒˆãŒä¸å®‰å®š

### ç—‡çŠ¶
- åŒã˜ãƒ†ã‚¹ãƒˆãŒæ™‚ã€…å¤±æ•—ã™ã‚‹
- ãƒ­ãƒ¼ã‚«ãƒ«ã§ã¯æˆåŠŸã€CIã§å¤±æ•—
- ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã«ä¾å­˜ã—ãŸå¤±æ•—

### åŸå› 
âŒ éåŒæœŸå‡¦ç†ã®å¾…æ©Ÿä¸è¶³
âŒ ãƒ†ã‚¹ãƒˆé–“ã®ä¾å­˜é–¢ä¿‚
âŒ å…±æœ‰çŠ¶æ…‹ã®æ±šæŸ“
âŒ ãƒ©ãƒ³ãƒ€ãƒ ãƒ‡ãƒ¼ã‚¿ã®ä½¿ç”¨
âŒ å¤–éƒ¨ä¾å­˜ã®ãƒ¢ãƒƒã‚¯ä¸è¶³

### è§£æ±ºç­–
âœ… é©åˆ‡ãªå¾…æ©Ÿå‡¦ç†ï¼ˆwaitFor, untilï¼‰
âœ… ãƒ†ã‚¹ãƒˆåˆ†é›¢ã®å¾¹åº•
âœ… beforeEach/afterEachã§ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
âœ… æ±ºå®šè«–çš„ãªãƒ†ã‚¹ãƒˆãƒ‡ãƒ¼ã‚¿
âœ… å¤–éƒ¨APIã®ãƒ¢ãƒƒã‚¯åŒ–
âœ… ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯ã®å‰Šé™¤
```

---

## ã¾ã¨ã‚

### ãƒ†ã‚¹ãƒˆè¨ˆç”»æˆåŠŸã®éµ

```markdown
## æˆåŠŸã®5åŸå‰‡

1. **æ˜ç¢ºãªã‚¹ã‚³ãƒ¼ãƒ—å®šç¾©**
   - ãƒ†ã‚¹ãƒˆå¯¾è±¡ã‚’æ˜ç¢ºã«
   - å¯¾è±¡å¤–ã‚‚æ˜ç¤º
   - ãƒªã‚¹ã‚¯ãƒ™ãƒ¼ã‚¹ã§å„ªå…ˆé †ä½ä»˜ã‘

2. **ç¾å®Ÿçš„ãªã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«**
   - ãƒãƒƒãƒ•ã‚¡ã‚’ç¢ºä¿
   - ä¾å­˜é–¢ä¿‚ã‚’è€ƒæ…®
   - ãƒã‚¤ãƒ«ã‚¹ãƒˆãƒ¼ãƒ³ã‚’è¨­å®š

3. **é©åˆ‡ãªãƒªã‚½ãƒ¼ã‚¹é…åˆ†**
   - ã‚¹ã‚­ãƒ«ã‚»ãƒƒãƒˆã‚’è€ƒæ…®
   - ãƒ„ãƒ¼ãƒ«ã¸ã®æŠ•è³‡
   - è‡ªå‹•åŒ–ã®æ¨é€²

4. **ç¶™ç¶šçš„ãªæ”¹å–„**
   - ãƒ¡ãƒˆãƒªã‚¯ã‚¹ã®æ¸¬å®š
   - æŒ¯ã‚Šè¿”ã‚Šã®å®Ÿæ–½
   - ãƒ—ãƒ­ã‚»ã‚¹ã®æœ€é©åŒ–

5. **ã‚¹ãƒ†ãƒ¼ã‚¯ãƒ›ãƒ«ãƒ€ãƒ¼ã¨ã®é€£æº**
   - æœŸå¾…å€¤ã®èª¿æ•´
   - é€²æ—ã®å¯è¦–åŒ–
   - ãƒªã‚¹ã‚¯ã®å…±æœ‰
```

---

**é–¢é€£ã‚¬ã‚¤ãƒ‰:**
- [QA Metrics & KPI Dashboard](./qa-metrics-kpi-dashboard.md)
- [Bug Management Complete](./bug-management-complete.md)
- [Release Management & Criteria](./release-management-criteria.md)
