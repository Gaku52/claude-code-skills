# 正規表現概要

> 正規表現(Regular Expression)の歴史的背景、主要な用途、そしてNFA/DFAエンジンの内部動作原理を体系的に解説する。

## この章で学ぶこと

1. **正規表現の数学的起源と歴史的発展** -- Kleeneの正則集合からPCREまでの系譜
2. **正規表現エンジンの二大方式(NFA/DFA)** -- それぞれの動作原理・性能特性・選択基準
3. **正規表現の適用領域と限界** -- テキスト検索からコンパイラまで、使うべき場面と避けるべき場面

---

## 1. 正規表現とは何か

正規表現は **パターンマッチング** のための形式言語である。文字列の集合を有限の記法で表現し、検索・置換・抽出・検証に利用する。

```
パターン: \d{3}-\d{4}
対象文字列: "郵便番号は 100-0001 です"
マッチ結果: "100-0001"
```

### 1.1 基本的な動作モデル

```
入力文字列 ──→ [正規表現エンジン] ──→ マッチ結果
                    ↑
               パターン(正規表現)
```

正規表現エンジンは、与えられたパターンを内部的にオートマトン(有限状態機械)に変換し、入力文字列を1文字ずつ処理してマッチングを行う。

---

## 2. 歴史的発展

### 2.1 年表

```
1943  McCulloch & Pitts  ─ 神経回路網の数学モデル
  │
1956  Stephen Kleene     ─ 正則集合(Regular Sets)の理論化
  │
1968  Ken Thompson       ─ QED/edエディタに正規表現を実装
  │
1973  Thompson & Ritchie ─ grep の誕生(Unix V4)
  │
1986  Henry Spencer      ─ 最初の自由な正規表現ライブラリ
  │
1987  Larry Wall         ─ Perl 1.0 に高機能正規表現を搭載
  │
1997  Philip Hazel       ─ PCRE (Perl Compatible Regular Expressions)
  │
2006  Russ Cox           ─ RE2 (線形時間保証エンジン)
  │
2017  ECMAScript 2018    ─ 名前付きキャプチャ、後読みを標準化
```

### 2.2 主要なマイルストーン

| 年代 | 人物/プロジェクト | 貢献 |
|------|-------------------|------|
| 1956 | Stephen Kleene | 「正則表現(regular expression)」の概念を数学的に定式化 |
| 1968 | Ken Thompson | エディタ QED に初の実用的正規表現エンジンを実装 |
| 1973 | grep (Unix) | `g/re/p` -- Global Regular Expression Print |
| 1986 | POSIX | BRE/ERE(基本/拡張正規表現)を標準化 |
| 1987 | Perl | 後方参照・先読み等を追加、事実上の標準に |
| 1997 | PCRE | Perl互換エンジンを独立ライブラリとして提供 |
| 2006 | RE2 (Google) | DFAベースで ReDoS を原理的に排除 |

---

## 3. 正規表現エンジンの種類

### 3.1 NFA vs DFA -- 二大方式

```
┌──────────────────────────────────────────────────────┐
│                正規表現エンジン                        │
├─────────────────────┬────────────────────────────────┤
│   NFA (非決定性)     │    DFA (決定性)                │
│                     │                                │
│ ・バックトラック方式  │ ・状態遷移テーブル方式          │
│ ・パターン駆動       │ ・テキスト駆動                  │
│ ・後方参照をサポート  │ ・後方参照は非サポート           │
│ ・最悪 O(2^n)        │ ・常に O(n)                    │
│                     │                                │
│ 例: Perl, Python,   │ 例: awk, grep(一部),           │
│     Java, .NET,     │     RE2, Rust regex            │
│     JavaScript      │                                │
└─────────────────────┴────────────────────────────────┘
```

### 3.2 NFA の動作例

パターン `a(b|c)d` に対して文字列 `"acd"` をマッチングする場合:

```python
# NFA (Nondeterministic Finite Automaton) の動作シミュレーション
import re

pattern = r'a(b|c)d'
text = "acd"

# 内部的な動作:
# 1. 状態 S0: 'a' を読む → マッチ → S1 へ遷移
# 2. 状態 S1: 'c' を読む → 'b' を試行 → 失敗
#                        → バックトラックして 'c' を試行 → マッチ → S2 へ
# 3. 状態 S2: 'd' を読む → マッチ → 受理状態

result = re.match(pattern, text)
print(result.group())   # => "acd"
print(result.group(1))  # => "c"
```

### 3.3 DFA の動作例

```python
# DFA (Deterministic Finite Automaton) は事前に全状態を展開する
# パターン: a(b|c)d

# 状態遷移テーブル:
# 現在状態 | 入力 'a' | 入力 'b' | 入力 'c' | 入力 'd'
# ---------|----------|----------|----------|--------
# S0       | S1       | -        | -        | -
# S1       | -        | S2       | S2       | -
# S2       | -        | -        | -        | S3(受理)

# DFA ではバックトラックが発生しない
# 各文字につき状態遷移は1回のみ → O(n)

# Rust の regex クレートは DFA ベース
# RE2 も DFA ベース
```

### 3.4 比較表: NFA vs DFA

| 特性 | NFA | DFA |
|------|-----|-----|
| 時間計算量(最悪) | O(2^n) -- 指数的 | O(n) -- 線形 |
| 時間計算量(平均) | O(n) -- 実用的には高速 | O(n) -- 常に線形 |
| 空間計算量 | O(m) パターンサイズ | O(2^m) 最悪(状態爆発) |
| 後方参照 | サポート | 非サポート |
| 先読み/後読み | サポート | 限定的/非サポート |
| 怠惰量指定子 | サポート | N/A (最左最長マッチ) |
| ReDoS脆弱性 | あり | なし |
| 実装の複雑さ | 比較的単純 | 状態テーブル構築が複雑 |
| 代表的な実装 | Perl, Python, Java, JS | RE2, Rust regex, awk |

### 3.5 ハイブリッドアプローチ

```
┌─────────────────────────────────────────┐
│         ハイブリッドエンジン              │
│                                         │
│  パターン解析                             │
│      │                                   │
│      ├── 後方参照なし → DFA で実行        │
│      │                                   │
│      └── 後方参照あり → NFA にフォールバック│
│                                         │
│  例: .NET, Rust の fancy-regex           │
└─────────────────────────────────────────┘
```

---

## 4. 正規表現の主要な用途

### 4.1 用途別コード例

```bash
# 1. テキスト検索 (grep)
grep -E 'ERROR|WARN' /var/log/syslog

# 2. テキスト置換 (sed)
sed 's/2025/2026/g' document.txt

# 3. データ抽出 (Python)
python3 -c "
import re
log = '2026-02-11 10:30:45 [ERROR] Connection timeout (192.168.1.1)'
m = re.search(r'(\d{4}-\d{2}-\d{2}) .* \[(\w+)\] (.+)', log)
print(f'日付: {m.group(1)}, レベル: {m.group(2)}, メッセージ: {m.group(3)}')
"

# 4. 入力検証 (JavaScript)
node -e "
const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
console.log(emailPattern.test('user@example.com'));  // true
console.log(emailPattern.test('invalid@'));           // false
"

# 5. 構文ハイライト -- エディタがキーワードを着色する仕組み
# パターン例: \b(if|else|for|while|return)\b → キーワードとして着色
```

### 4.2 適用領域マップ

| 領域 | 代表的な使い方 | 推奨度 |
|------|---------------|--------|
| ログ解析 | エラーパターン抽出、集計 | 最適 |
| 入力バリデーション | メール、電話番号、郵便番号 | 適切(ただし過信は禁物) |
| テキストエディタ | 検索・置換 | 最適 |
| Web スクレイピング | HTML からの情報抽出 | 注意(HTMLパーサー推奨) |
| コンパイラ/字句解析 | トークン分割 | 適切(lexer生成器と併用) |
| 自然言語処理 | 形態素解析の前処理 | 限定的 |
| バイナリ解析 | パターン検出 | 不適切 |

---

## 5. 正規表現の限界

### 5.1 正規表現で表現できないもの

```
チョムスキー階層:
┌─────────────────────────────────────┐
│ タイプ0: 帰納的可算言語              │
│  ┌──────────────────────────────┐   │
│  │ タイプ1: 文脈依存言語         │   │
│  │  ┌───────────────────────┐   │   │
│  │  │ タイプ2: 文脈自由言語  │   │   │
│  │  │  ┌────────────────┐   │   │   │
│  │  │  │ タイプ3: 正則言語│   │   │   │
│  │  │  │ (正規表現)      │   │   │   │
│  │  │  └────────────────┘   │   │   │
│  │  │  例: HTML, JSON,      │   │   │
│  │  │      プログラミング言語│   │   │
│  │  └───────────────────────┘   │   │
│  └──────────────────────────────┘   │
└─────────────────────────────────────┘

正規表現（タイプ3）では、ネストした括弧の
対応関係を数えることができない。
例: ((())), {{{}}}, <div><div></div></div>
```

---

## 6. アンチパターン

### 6.1 アンチパターン: HTML を正規表現でパースする

```python
# NG: HTML を正規表現で処理しようとする
import re

html = '<div class="outer"><div class="inner">text</div></div>'

# このパターンはネストした div を正しく処理できない
pattern = r'<div[^>]*>(.*?)</div>'
result = re.findall(pattern, html)
print(result)  # => ['<div class="inner">text']  -- 不正確

# OK: HTML パーサーを使う
from html.parser import HTMLParser
# または Beautiful Soup, lxml 等を使用する
```

**理由**: HTML は文脈自由言語であり、正規表現(正則言語)の表現力を超える。ネストした要素の対応を正しく追跡できない。

### 6.2 アンチパターン: 万能バリデーションパターン

```python
# NG: RFC 5322 完全準拠のメールアドレスパターン（実際に存在する）
# 数千文字に及ぶ正規表現 → 保守不能、デバッグ不能

email_pattern_bad = r"""(?:[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*|"(?:[\x01-\x08\x0b\x0c\x0e-\x1f\x21\x23-\x5b\x5d-\x7f]|\\[\x01-\x09\x0b\x0c\x0e-\x7f])*")@..."""
# (省略 -- 実際は数百文字以上)

# OK: 実用的なバリデーション + 確認メール送信
import re

def validate_email(email: str) -> bool:
    """実用的なメール検証 -- 形式チェック + 確認メール"""
    # 基本形式のみチェック
    if not re.match(r'^[^@\s]+@[^@\s]+\.[^@\s]+$', email):
        return False
    # 本当の検証は確認メールを送信して行う
    return True
```

**理由**: 完璧な正規表現を書くより、シンプルなパターン + 別の検証手段を組み合わせるほうが保守性・信頼性ともに高い。

---

## 7. FAQ

### Q1: 正規表現を学ぶのに最適な順序は？

**A**: 以下の順序を推奨する:

1. リテラルマッチ → メタ文字 → 文字クラス → 量指定子
2. アンカー → グループ → 後方参照
3. 先読み・後読み → Unicode → パフォーマンス

基本構文を習得してから、実際のユースケース(ログ解析、入力検証など)で練習するのが効果的である。

### Q2: NFA と DFA のどちらを選ぶべきか？

**A**: 以下の判断基準で選択する:

- **後方参照や先読みが必要** → NFA(Perl, Python, JavaScript など)
- **信頼されない入力に対するマッチング** → DFA(RE2, Rust regex)で ReDoS を防止
- **パフォーマンスが最優先** → DFA ベースのエンジンを選択
- **機能の豊富さが優先** → NFA ベースのエンジンを選択

多くの場合、言語のデフォルトエンジンを使えばよい。ReDoS が懸念される場合のみ DFA を検討する。

### Q3: 正規表現のデバッグにはどんなツールがあるか？

**A**: 主要なツール:

- **regex101.com** -- パターンのリアルタイムテスト、解説付き
- **Debuggex** -- 正規表現の鉄道図(Railroad Diagram)を表示
- **RegExr** -- インタラクティブな正規表現テスター
- **各言語のverboseモード** -- Python の `re.VERBOSE`、JavaScript の `//x` (未サポートだが将来追加予定)

---

## まとめ

| 項目 | 内容 |
|------|------|
| 正規表現の本質 | パターンマッチングのための形式言語 |
| 理論的基盤 | Kleene の正則集合(1956年) |
| 実用化の起点 | Thompson による QED/ed への実装(1968年) |
| 現代の標準 | PCRE (Perl Compatible Regular Expressions) |
| NFA | バックトラック方式、機能豊富、最悪 O(2^n) |
| DFA | 状態遷移方式、高速安定、O(n) 保証 |
| 主な用途 | テキスト検索・置換・抽出・検証 |
| 主な限界 | ネスト構造(HTML等)は原理的に扱えない |
| 学習の鍵 | 基本構文→応用構文→実践パターンの順で段階的に |

## 次に読むべきガイド

- [01-basic-syntax.md](./01-basic-syntax.md) -- 基本構文: リテラル、メタ文字、エスケープ
- [02-character-classes.md](./02-character-classes.md) -- 文字クラスの詳細
- [03-quantifiers-anchors.md](./03-quantifiers-anchors.md) -- 量指定子とアンカー

## 参考文献

1. **Jeffrey E.F. Friedl** "Mastering Regular Expressions, 3rd Edition" O'Reilly Media, 2006 -- 正規表現の決定版バイブル
2. **Russ Cox** "Regular Expression Matching Can Be Simple And Fast" https://swtch.com/~rsc/regexp/regexp1.html, 2007 -- NFA/DFA の理論と実装を明快に解説
3. **Ken Thompson** "Regular Expression Search Algorithm" Communications of the ACM, 11(6):419-422, 1968 -- 正規表現エンジンの原論文
4. **PCRE2 Documentation** https://www.pcre.org/current/doc/html/ -- 現行の PCRE2 リファレンス
