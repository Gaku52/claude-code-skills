# ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

> ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ï¼ˆå¤šæ…‹æ€§ï¼‰ã¯ã€ŒåŒã˜ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã§ç•°ãªã‚‹å®Ÿè£…ã‚’å‘¼ã³å‡ºã›ã‚‹ã€ä»•çµ„ã¿ã€‚OOPã®æœ€ã‚‚å¼·åŠ›ãªæ¦‚å¿µã§ã‚ã‚Šã€æŸ”è»Ÿã§æ‹¡å¼µæ€§ã®é«˜ã„è¨­è¨ˆã®åŸºç›¤ã€‚

## ã“ã®ç« ã§å­¦ã¶ã“ã¨

- [ ] 3ç¨®é¡ã®ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã‚’ç†è§£ã™ã‚‹
- [ ] å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã®ä»•çµ„ã¿ï¼ˆvtableï¼‰ã‚’æŠŠæ¡ã™ã‚‹
- [ ] ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã®å®Ÿè·µçš„ãªæ´»ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å­¦ã¶
- [ ] é™çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã¨å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã®ä½¿ã„åˆ†ã‘ã‚’ç†è§£ã™ã‚‹
- [ ] ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ï¼ˆã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼‰ã‚’æ´»ç”¨ã™ã‚‹
- [ ] å®Ÿå‹™ã§ã®è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã®é–¢é€£ã‚’æŠŠæ¡ã™ã‚‹

---

## 1. 3ç¨®é¡ã®ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

```
1. ã‚µãƒ–ã‚¿ã‚¤ãƒ—ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ï¼ˆSubtype / Inclusionï¼‰
   â†’ è¦ªå‹ã®å¤‰æ•°ã«ã‚µãƒ–ã‚¯ãƒ©ã‚¹ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä»£å…¥
   â†’ OOPã®ã€Œãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã€ã¯ã“ã‚Œã‚’æŒ‡ã™ã“ã¨ãŒå¤šã„
   â†’ å®Ÿè¡Œæ™‚ã«å®Ÿéš›ã®å‹ã®ãƒ¡ã‚½ãƒƒãƒ‰ãŒå‘¼ã°ã‚Œã‚‹

2. ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ï¼ˆParametricï¼‰
   â†’ ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã€‚å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã§æ±ç”¨çš„ãªã‚³ãƒ¼ãƒ‰ã‚’æ›¸ã
   â†’ List<T>, Map<K,V> ãªã©

3. ã‚¢ãƒ‰ãƒ›ãƒƒã‚¯ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ï¼ˆAd-hocï¼‰
   â†’ ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã€‚åŒåã§å¼•æ•°ã®å‹ãŒç•°ãªã‚‹ãƒ¡ã‚½ãƒƒãƒ‰
   â†’ æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã‚‚å«ã‚€

æ¯”è¼ƒ:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                â”‚ ã‚µãƒ–ã‚¿ã‚¤ãƒ—    â”‚ ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ â”‚ ã‚¢ãƒ‰ãƒ›ãƒƒã‚¯    â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ æ±ºå®šã‚¿ã‚¤ãƒŸãƒ³ã‚° â”‚ å®Ÿè¡Œæ™‚       â”‚ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚   â”‚ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚  â”‚
  â”‚ å®Ÿç¾æ‰‹æ®µ       â”‚ ç¶™æ‰¿/IFå®Ÿè£…  â”‚ ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹   â”‚ ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰â”‚
  â”‚ å‹ã®çµ±ä¸€æ€§     â”‚ å…±é€šã®è¦ªå‹   â”‚ å‹ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿   â”‚ åŒåç•°å¼•æ•°    â”‚
  â”‚ ä»£è¡¨ä¾‹         â”‚ Shape.area() â”‚ List<T>       â”‚ add(int,int)  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. ã‚µãƒ–ã‚¿ã‚¤ãƒ—ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

```
  Shapeï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹/æŠ½è±¡ã‚¯ãƒ©ã‚¹ï¼‰
    area(): number
    draw(): void
       â†‘
  â”Œâ”€â”€â”€â”€â”¼â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â–¼    â–¼    â–¼           â–¼
Circle  Rect  Triangle  Polygon
 area() area()  area()   area()
 å„ã€…ãŒç‹¬è‡ªã®å®Ÿè£…ã‚’æŒã¤

  shapes: Shape[] = [Circle, Rect, Triangle, ...]
  for (shape of shapes) {
    shape.area()  â† å®Ÿè¡Œæ™‚ã«æ­£ã—ã„å®Ÿè£…ãŒå‘¼ã°ã‚Œã‚‹
  }
```

### 2.1 åŸºæœ¬çš„ãªã‚µãƒ–ã‚¿ã‚¤ãƒ—ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

```typescript
// TypeScript: ã‚µãƒ–ã‚¿ã‚¤ãƒ—ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 
interface Shape {
  area(): number;
  perimeter(): number;
  describe(): string;
}

class Circle implements Shape {
  constructor(private radius: number) {}

  area(): number {
    return Math.PI * this.radius ** 2;
  }

  perimeter(): number {
    return 2 * Math.PI * this.radius;
  }

  describe(): string {
    return `å††ï¼ˆåŠå¾„: ${this.radius}ï¼‰`;
  }
}

class Rectangle implements Shape {
  constructor(private width: number, private height: number) {}

  area(): number {
    return this.width * this.height;
  }

  perimeter(): number {
    return 2 * (this.width + this.height);
  }

  describe(): string {
    return `é•·æ–¹å½¢ï¼ˆ${this.width} x ${this.height}ï¼‰`;
  }
}

class Triangle implements Shape {
  constructor(
    private a: number,
    private b: number,
    private c: number,
    private height: number,
  ) {}

  area(): number {
    // ãƒ˜ãƒ­ãƒ³ã®å…¬å¼
    const s = (this.a + this.b + this.c) / 2;
    return Math.sqrt(s * (s - this.a) * (s - this.b) * (s - this.c));
  }

  perimeter(): number {
    return this.a + this.b + this.c;
  }

  describe(): string {
    return `ä¸‰è§’å½¢ï¼ˆè¾º: ${this.a}, ${this.b}, ${this.c}ï¼‰`;
  }
}

// ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ : Shapeå‹ã§çµ±ä¸€çš„ã«æ‰±ã†
function printShapeInfo(shape: Shape): void {
  console.log(`${shape.describe()}: é¢ç©=${shape.area().toFixed(2)}`);
}

// å½¢çŠ¶ã®é¢ç©åˆè¨ˆã‚’è¨ˆç®—ï¼ˆShapeå‹ã®ã¿ã«ä¾å­˜ï¼‰
function totalArea(shapes: Shape[]): number {
  return shapes.reduce((sum, shape) => sum + shape.area(), 0);
}

// é¢ç©ã§ã‚½ãƒ¼ãƒˆï¼ˆShapeå‹ã®ã¿ã«ä¾å­˜ï¼‰
function sortByArea(shapes: Shape[]): Shape[] {
  return [...shapes].sort((a, b) => a.area() - b.area());
}

const shapes: Shape[] = [
  new Circle(5),
  new Rectangle(3, 4),
  new Circle(10),
  new Triangle(3, 4, 5, 3.5),
];

shapes.forEach(printShapeInfo);
// å††ï¼ˆåŠå¾„: 5ï¼‰: é¢ç©=78.54
// é•·æ–¹å½¢ï¼ˆ3 x 4ï¼‰: é¢ç©=12.00
// å††ï¼ˆåŠå¾„: 10ï¼‰: é¢ç©=314.16
// ä¸‰è§’å½¢ï¼ˆè¾º: 3, 4, 5ï¼‰: é¢ç©=6.00

console.log(`åˆè¨ˆé¢ç©: ${totalArea(shapes).toFixed(2)}`);
// åˆè¨ˆé¢ç©: 410.70
```

### 2.2 ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ãƒ™ãƒ¼ã‚¹ã®ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

```python
# Python: ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒ™ãƒ¼ã‚¹ã®ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ï¼ˆãƒ€ãƒƒã‚¯ã‚¿ã‚¤ãƒ”ãƒ³ã‚° + å‹ãƒ’ãƒ³ãƒˆï¼‰
from typing import Protocol, runtime_checkable


@runtime_checkable
class Renderable(Protocol):
    """æç”»å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«"""
    def render(self) -> str: ...
    def width(self) -> int: ...
    def height(self) -> int: ...


@runtime_checkable
class Clickable(Protocol):
    """ã‚¯ãƒªãƒƒã‚¯å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«"""
    def on_click(self, x: int, y: int) -> None: ...
    def is_point_inside(self, x: int, y: int) -> bool: ...


class TextLabel:
    """ãƒ†ã‚­ã‚¹ãƒˆãƒ©ãƒ™ãƒ«ï¼ˆRenderable ã®ã¿å®Ÿè£…ï¼‰"""
    def __init__(self, text: str, x: int = 0, y: int = 0):
        self.text = text
        self.x = x
        self.y = y

    def render(self) -> str:
        return f'<label x="{self.x}" y="{self.y}">{self.text}</label>'

    def width(self) -> int:
        return len(self.text) * 8  # 1æ–‡å­—8pxæƒ³å®š

    def height(self) -> int:
        return 16


class Button:
    """ãƒœã‚¿ãƒ³ï¼ˆRenderable + Clickable ä¸¡æ–¹ã‚’å®Ÿè£…ï¼‰"""
    def __init__(self, label: str, x: int = 0, y: int = 0,
                 w: int = 100, h: int = 30):
        self.label = label
        self.x = x
        self.y = y
        self._width = w
        self._height = h
        self._click_handler: list[callable] = []

    def render(self) -> str:
        return f'<button x="{self.x}" y="{self.y}" w="{self._width}" h="{self._height}">{self.label}</button>'

    def width(self) -> int:
        return self._width

    def height(self) -> int:
        return self._height

    def on_click(self, x: int, y: int) -> None:
        print(f"Button '{self.label}' clicked at ({x}, {y})")
        for handler in self._click_handler:
            handler(x, y)

    def is_point_inside(self, x: int, y: int) -> bool:
        return (self.x <= x <= self.x + self._width and
                self.y <= y <= self.y + self._height)

    def add_click_handler(self, handler: callable) -> None:
        self._click_handler.append(handler)


class Image:
    """ç”»åƒï¼ˆRenderable + Clickable ä¸¡æ–¹ã‚’å®Ÿè£…ï¼‰"""
    def __init__(self, src: str, x: int = 0, y: int = 0,
                 w: int = 200, h: int = 150):
        self.src = src
        self.x = x
        self.y = y
        self._width = w
        self._height = h

    def render(self) -> str:
        return f'<img src="{self.src}" x="{self.x}" y="{self.y}" w="{self._width}" h="{self._height}" />'

    def width(self) -> int:
        return self._width

    def height(self) -> int:
        return self._height

    def on_click(self, x: int, y: int) -> None:
        print(f"Image '{self.src}' clicked at ({x}, {y})")

    def is_point_inside(self, x: int, y: int) -> bool:
        return (self.x <= x <= self.x + self._width and
                self.y <= y <= self.y + self._height)


# ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã®æ´»ç”¨: å‹ã«ä¾å­˜ã—ãªã„æ±ç”¨é–¢æ•°
def render_all(elements: list[Renderable]) -> str:
    """Renderable ã‚’å®Ÿè£…ã™ã‚‹å…¨ã¦ã®è¦ç´ ã‚’æç”»"""
    return "\n".join(el.render() for el in elements)

def calculate_total_area(elements: list[Renderable]) -> int:
    """å…¨è¦ç´ ã®é¢ç©åˆè¨ˆã‚’è¨ˆç®—"""
    return sum(el.width() * el.height() for el in elements)

def handle_click(clickables: list[Clickable], x: int, y: int) -> None:
    """ã‚¯ãƒªãƒƒã‚¯ä½ç½®ã«è©²å½“ã™ã‚‹è¦ç´ ã®ã‚¯ãƒªãƒƒã‚¯ãƒãƒ³ãƒ‰ãƒ©ã‚’å‘¼ã¶"""
    for element in clickables:
        if element.is_point_inside(x, y):
            element.on_click(x, y)


# ä½¿ç”¨ä¾‹
elements: list[Renderable] = [
    TextLabel("ã“ã‚“ã«ã¡ã¯", x=10, y=10),
    Button("é€ä¿¡", x=10, y=40),
    Image("logo.png", x=10, y=80),
]

print(render_all(elements))
print(f"åˆè¨ˆé¢ç©: {calculate_total_area(elements)} px^2")

# ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã®å‹ãƒã‚§ãƒƒã‚¯
print(isinstance(Button("test"), Renderable))  # True
print(isinstance(Button("test"), Clickable))   # True
print(isinstance(TextLabel("test"), Clickable)) # False
```

### 2.3 Java ã§ã®ã‚µãƒ–ã‚¿ã‚¤ãƒ—ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

```java
// Java: ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã«ã‚ˆã‚‹ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

// æ”¯æ‰•ã„å‡¦ç†ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
public interface PaymentProcessor {
    PaymentResult process(PaymentRequest request);
    boolean supports(String paymentMethod);
    String getProviderName();
}

// å„ãƒ—ãƒ­ãƒã‚¤ãƒ€ã®å®Ÿè£…
public class StripeProcessor implements PaymentProcessor {
    private final StripeClient client;

    public StripeProcessor(String apiKey) {
        this.client = new StripeClient(apiKey);
    }

    @Override
    public PaymentResult process(PaymentRequest request) {
        // Stripe API ã‚’ä½¿ã£ãŸæ±ºæ¸ˆå‡¦ç†
        try {
            var charge = client.charges().create(
                request.getAmount(),
                request.getCurrency(),
                request.getToken()
            );
            return PaymentResult.success(charge.getId(), "stripe");
        } catch (StripeException e) {
            return PaymentResult.failure(e.getMessage(), "stripe");
        }
    }

    @Override
    public boolean supports(String paymentMethod) {
        return List.of("credit_card", "debit_card", "apple_pay").contains(paymentMethod);
    }

    @Override
    public String getProviderName() {
        return "Stripe";
    }
}

public class PayPayProcessor implements PaymentProcessor {
    private final PayPayClient client;

    public PayPayProcessor(String merchantId, String apiSecret) {
        this.client = new PayPayClient(merchantId, apiSecret);
    }

    @Override
    public PaymentResult process(PaymentRequest request) {
        // PayPay API ã‚’ä½¿ã£ãŸæ±ºæ¸ˆå‡¦ç†
        try {
            var result = client.createPayment(
                request.getAmount(),
                request.getOrderId()
            );
            return PaymentResult.success(result.getPaymentId(), "paypay");
        } catch (PayPayException e) {
            return PaymentResult.failure(e.getMessage(), "paypay");
        }
    }

    @Override
    public boolean supports(String paymentMethod) {
        return "paypay".equals(paymentMethod);
    }

    @Override
    public String getProviderName() {
        return "PayPay";
    }
}

public class BankTransferProcessor implements PaymentProcessor {
    @Override
    public PaymentResult process(PaymentRequest request) {
        // éŠ€è¡ŒæŒ¯è¾¼å‡¦ç†
        String transferId = generateTransferId();
        return PaymentResult.pending(transferId, "bank_transfer");
    }

    @Override
    public boolean supports(String paymentMethod) {
        return "bank_transfer".equals(paymentMethod);
    }

    @Override
    public String getProviderName() {
        return "Bank Transfer";
    }

    private String generateTransferId() {
        return "BT-" + System.currentTimeMillis();
    }
}

// åˆ©ç”¨å´: PaymentProcessor ã®ã¿ã«ä¾å­˜ï¼ˆå…·è±¡ã‚¯ãƒ©ã‚¹ã‚’çŸ¥ã‚‰ãªã„ï¼‰
public class CheckoutService {
    private final List<PaymentProcessor> processors;

    public CheckoutService(List<PaymentProcessor> processors) {
        this.processors = processors;
    }

    public PaymentResult checkout(Order order, String paymentMethod) {
        // ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ : é©åˆ‡ãªãƒ—ãƒ­ã‚»ãƒƒã‚µã‚’å‹•çš„ã«é¸æŠ
        PaymentProcessor processor = processors.stream()
            .filter(p -> p.supports(paymentMethod))
            .findFirst()
            .orElseThrow(() -> new UnsupportedPaymentException(
                "ã‚µãƒãƒ¼ãƒˆã•ã‚Œã¦ã„ãªã„æ±ºæ¸ˆæ–¹æ³•: " + paymentMethod));

        PaymentRequest request = PaymentRequest.from(order);
        System.out.println("æ±ºæ¸ˆãƒ—ãƒ­ãƒã‚¤ãƒ€: " + processor.getProviderName());
        return processor.process(request);
    }
}

// çµ„ã¿ç«‹ã¦ï¼ˆDIï¼‰
CheckoutService service = new CheckoutService(List.of(
    new StripeProcessor("sk_test_xxx"),
    new PayPayProcessor("merchant_123", "secret_xxx"),
    new BankTransferProcessor()
));

// æ–°ã—ã„æ±ºæ¸ˆæ–¹æ³•ã‚’è¿½åŠ  â†’ æ–°ã—ã„ã‚¯ãƒ©ã‚¹ã‚’è¿½åŠ ã™ã‚‹ã ã‘
// CheckoutService ã¯ä¸€åˆ‡å¤‰æ›´ä¸è¦ï¼ˆOCPéµå®ˆï¼‰
```

---

## 3. å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã®ä»•çµ„ã¿ï¼ˆvtableï¼‰

```
ä»®æƒ³é–¢æ•°ãƒ†ãƒ¼ãƒ–ãƒ«ï¼ˆvtable / Virtual Method Tableï¼‰:
  â†’ C++, Java, C# ç­‰ã§ä½¿ã‚ã‚Œã‚‹å®Ÿè£…ãƒ¡ã‚«ãƒ‹ã‚ºãƒ 
  â†’ å„ã‚¯ãƒ©ã‚¹ãŒæŒã¤ãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚¤ãƒ³ã‚¿ã®é…åˆ—
  â†’ å®Ÿè¡Œæ™‚ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®Ÿéš›ã®å‹ã«åŸºã¥ã„ã¦ãƒ¡ã‚½ãƒƒãƒ‰ã‚’é¸æŠ

  ãƒ¡ãƒ¢ãƒªãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ:

  Circle ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ            Circle ã® vtable
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ vptr â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ area() â†’ Circleå®Ÿè£…â”‚
  â”‚ radius: 5.0  â”‚            â”‚ perimeter() â†’ ...  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚ describe() â†’ ...   â”‚
                              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Rectangle ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ         Rectangle ã® vtable
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ vptr â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ area() â†’ Rectå®Ÿè£…  â”‚
  â”‚ width: 3.0   â”‚            â”‚ perimeter() â†’ ...  â”‚
  â”‚ height: 4.0  â”‚            â”‚ describe() â†’ ...   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  shape.area() ã®å‘¼ã³å‡ºã—:
    1. shape ã® vptr ã‚’å–å¾—
    2. vtable ã‹ã‚‰ area() ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—
    3. ãã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶

  ã‚³ã‚¹ãƒˆ: ãƒã‚¤ãƒ³ã‚¿é–“æ¥å‚ç…§1å›åˆ†ï¼ˆã»ã¼ã‚¼ãƒ­ã‚³ã‚¹ãƒˆï¼‰
```

### 3.1 vtable ã®è©³ç´°ãªå‹•ä½œ

```
ç¶™æ‰¿æ™‚ã® vtable ã®æ§‹ç¯‰:

  Shape vtable:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ [0] area() â†’ ???     â”‚ â† ç´”ç²‹ä»®æƒ³ï¼ˆæŠ½è±¡ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
  â”‚ [1] perimeter() â†’ ???â”‚
  â”‚ [2] describe() â†’ ??? â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Circle vtableï¼ˆShape ã‚’ç¶™æ‰¿ï¼‰:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ [0] area() â†’ Circle::area    â”‚ â† ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
  â”‚ [1] perimeter() â†’ Circle::perâ”‚ â† ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
  â”‚ [2] describe() â†’ Circle::descâ”‚ â† ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  FilledCircle vtableï¼ˆCircle ã‚’ç¶™æ‰¿ï¼‰:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ [0] area() â†’ Circle::area        â”‚ â† ç¶™æ‰¿ï¼ˆå¤‰æ›´ãªã—ï¼‰
  â”‚ [1] perimeter() â†’ Circle::per    â”‚ â† ç¶™æ‰¿ï¼ˆå¤‰æ›´ãªã—ï¼‰
  â”‚ [2] describe() â†’ Filled::describeâ”‚ â† ã‚ªãƒ¼ãƒãƒ¼ãƒ©ã‚¤ãƒ‰
  â”‚ [3] fill() â†’ FilledCircle::fill  â”‚ â† æ–°è¦è¿½åŠ 
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  ãƒã‚¤ãƒ³ãƒˆ:
  - vtable ã¯ã‚¯ãƒ©ã‚¹ã”ã¨ã«1ã¤ï¼ˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã”ã¨ã§ã¯ãªã„ï¼‰
  - ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«ã¯ vptrï¼ˆvtable ã¸ã®ãƒã‚¤ãƒ³ã‚¿ï¼‰ã®ã¿ä¿æŒ
  - ãƒ¡ãƒ¢ãƒªã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ = 1ãƒã‚¤ãƒ³ã‚¿/ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆé€šå¸¸8ãƒã‚¤ãƒˆï¼‰
  - å‘¼ã³å‡ºã—ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ = 1é–“æ¥å‚ç…§ï¼ˆæ•°ãƒŠãƒç§’ï¼‰
```

```cpp
// C++: vtable ã®å‹•ä½œã‚’ç†è§£ã™ã‚‹ãŸã‚ã®ä¾‹
#include <iostream>
#include <vector>
#include <memory>

class Shape {
public:
    virtual ~Shape() = default;

    // ç´”ç²‹ä»®æƒ³é–¢æ•°ï¼ˆ= 0ï¼‰: vtable ã®ã‚¹ãƒ­ãƒƒãƒˆã¯å­˜åœ¨ã™ã‚‹ãŒã€
    // ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ nullptrï¼ˆã‚µãƒ–ã‚¯ãƒ©ã‚¹ã§å®Ÿè£…å¿…é ˆï¼‰
    virtual double area() const = 0;
    virtual double perimeter() const = 0;
    virtual std::string describe() const = 0;

    // éä»®æƒ³é–¢æ•°: vtable ã«å«ã¾ã‚Œãªã„ã€‚é™çš„ã«è§£æ±ºã•ã‚Œã‚‹
    void printInfo() const {
        std::cout << describe() << ": area=" << area() << std::endl;
    }
};

class Circle : public Shape {
    double radius;
public:
    Circle(double r) : radius(r) {}

    double area() const override {
        return 3.14159 * radius * radius;
    }

    double perimeter() const override {
        return 2 * 3.14159 * radius;
    }

    std::string describe() const override {
        return "Circle(r=" + std::to_string(radius) + ")";
    }
};

class Rectangle : public Shape {
    double width, height;
public:
    Rectangle(double w, double h) : width(w), height(h) {}

    double area() const override {
        return width * height;
    }

    double perimeter() const override {
        return 2 * (width + height);
    }

    std::string describe() const override {
        return "Rect(" + std::to_string(width) + "x" + std::to_string(height) + ")";
    }
};

int main() {
    // ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ : Shape ãƒã‚¤ãƒ³ã‚¿ã®é…åˆ—
    std::vector<std::unique_ptr<Shape>> shapes;
    shapes.push_back(std::make_unique<Circle>(5.0));
    shapes.push_back(std::make_unique<Rectangle>(3.0, 4.0));
    shapes.push_back(std::make_unique<Circle>(10.0));

    // å„ shape ã® vptr ã‚’é€šã˜ã¦æ­£ã—ã„å®Ÿè£…ãŒå‘¼ã°ã‚Œã‚‹
    for (const auto& shape : shapes) {
        shape->printInfo();
    }
    // Circle(r=5.000000): area=78.5398
    // Rect(3.000000x4.000000): area=12
    // Circle(r=10.000000): area=314.159

    return 0;
}
```

### 3.2 vtable ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è€ƒæ…®

```
vtable å‘¼ã³å‡ºã—ã®ã‚³ã‚¹ãƒˆåˆ†æ:

  ç›´æ¥å‘¼ã³å‡ºã—ï¼ˆéä»®æƒ³ï¼‰:
    call 0x400520          ; 1å‘½ä»¤ã€ã‚¢ãƒ‰ãƒ¬ã‚¹ã¯ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«ç¢ºå®š
    â†’ CPU ã®åˆ†å²äºˆæ¸¬ãŒ100%çš„ä¸­
    â†’ ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å±•é–‹ã‚‚å¯èƒ½

  ä»®æƒ³é–¢æ•°å‘¼ã³å‡ºã—ï¼ˆvtableçµŒç”±ï¼‰:
    mov rax, [rdi]         ; 1. vptr ã‚’ãƒ­ãƒ¼ãƒ‰
    call [rax + offset]    ; 2. vtable ã‹ã‚‰ãƒ¡ã‚½ãƒƒãƒ‰ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’å–å¾—ã—ã¦å‘¼ã¶
    â†’ é–“æ¥å‚ç…§1å› + åˆ†å²äºˆæ¸¬ãƒŸã‚¹ã®å¯èƒ½æ€§
    â†’ ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å±•é–‹ãŒå›°é›£

  ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¸ã®å½±éŸ¿:
    - é€šå¸¸ã®ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³: å½±éŸ¿ã¯ã»ã¼ã‚¼ãƒ­ï¼ˆç„¡è¦–ã§ãã‚‹ï¼‰
    - ã‚²ãƒ¼ãƒ ã®å†…éƒ¨ãƒ«ãƒ¼ãƒ—: æ•°ç™¾ä¸‡å›/ãƒ•ãƒ¬ãƒ¼ãƒ  â†’ 1-2%ã®å½±éŸ¿ã‚ã‚Šå¾—ã‚‹
    - æ•°å€¤è¨ˆç®—ã®å†…éƒ¨ãƒ«ãƒ¼ãƒ—: å½±éŸ¿ãŒé¡•è‘—ã«ãªã‚‹å ´åˆãŒã‚ã‚‹

  æœ€é©åŒ–ãƒ†ã‚¯ãƒ‹ãƒƒã‚¯:
    1. ãƒ›ãƒƒãƒˆãƒ‘ã‚¹ã§ã¯ä»®æƒ³é–¢æ•°ã‚’é¿ã‘ã‚‹
    2. final ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã§ä»®æƒ³å‘¼ã³å‡ºã—ã‚’æ’é™¤ï¼ˆC++/Javaï¼‰
    3. ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã® devirtualization æœ€é©åŒ–ã‚’æ´»ç”¨
    4. å‹ã”ã¨ã«ãƒãƒƒãƒå‡¦ç†ï¼ˆdata-oriented designï¼‰
```

---

## 4. å®Ÿè·µçš„ãªæ´»ç”¨ãƒ‘ã‚¿ãƒ¼ãƒ³

### 4.1 Strategy ãƒ‘ã‚¿ãƒ¼ãƒ³

```typescript
// æ”¯æ‰•ã„æ–¹æ³•ã®ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 
interface PaymentStrategy {
  pay(amount: number): Promise<PaymentResult>;
  validate(): boolean;
  getDisplayName(): string;
  getFee(amount: number): number;
}

interface PaymentResult {
  success: boolean;
  transactionId: string;
  message?: string;
}

class CreditCardPayment implements PaymentStrategy {
  constructor(
    private cardNumber: string,
    private cvv: string,
    private expiry: string,
  ) {}

  async pay(amount: number): Promise<PaymentResult> {
    const fee = this.getFee(amount);
    const totalAmount = amount + fee;
    // ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚«ãƒ¼ãƒ‰æ±ºæ¸ˆå‡¦ç†
    return {
      success: true,
      transactionId: `cc-${Date.now()}`,
      message: `Â¥${totalAmount}ã‚’æ±ºæ¸ˆã—ã¾ã—ãŸï¼ˆæ‰‹æ•°æ–™: Â¥${fee}ï¼‰`,
    };
  }

  validate(): boolean {
    return (
      this.cardNumber.replace(/\s/g, "").length === 16 &&
      this.cvv.length === 3 &&
      /^\d{2}\/\d{2}$/.test(this.expiry)
    );
  }

  getDisplayName(): string {
    const masked = this.cardNumber.slice(-4).padStart(16, "*");
    return `ã‚¯ãƒ¬ã‚¸ãƒƒãƒˆã‚«ãƒ¼ãƒ‰ (****${masked.slice(-4)})`;
  }

  getFee(amount: number): number {
    return Math.round(amount * 0.036); // 3.6%
  }
}

class PayPayPayment implements PaymentStrategy {
  constructor(private userId: string) {}

  async pay(amount: number): Promise<PaymentResult> {
    return {
      success: true,
      transactionId: `pp-${Date.now()}`,
      message: `PayPayã§Â¥${amount}ã‚’æ±ºæ¸ˆã—ã¾ã—ãŸ`,
    };
  }

  validate(): boolean {
    return this.userId.length > 0;
  }

  getDisplayName(): string {
    return "PayPay";
  }

  getFee(amount: number): number {
    return 0; // PayPayã¯æ‰‹æ•°æ–™ç„¡æ–™
  }
}

class BankTransferPayment implements PaymentStrategy {
  constructor(
    private bankCode: string,
    private accountNumber: string,
  ) {}

  async pay(amount: number): Promise<PaymentResult> {
    return {
      success: true,
      transactionId: `bt-${Date.now()}`,
      message: `éŠ€è¡ŒæŒ¯è¾¼ã®ä¾é ¼ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸï¼ˆÂ¥${amount}ï¼‰`,
    };
  }

  validate(): boolean {
    return this.bankCode.length === 4 && this.accountNumber.length >= 7;
  }

  getDisplayName(): string {
    return `éŠ€è¡ŒæŒ¯è¾¼ (${this.bankCode})`;
  }

  getFee(amount: number): number {
    return amount >= 30000 ? 440 : 220; // 3ä¸‡å††ä»¥ä¸Šã¯440å††
  }
}

class ConvenienceStorePayment implements PaymentStrategy {
  constructor(private storeType: "seven" | "lawson" | "family") {}

  async pay(amount: number): Promise<PaymentResult> {
    const paymentCode = this.generatePaymentCode();
    return {
      success: true,
      transactionId: `cs-${Date.now()}`,
      message: `ã‚³ãƒ³ãƒ“ãƒ‹æ”¯æ‰•ã„ç•ªå·: ${paymentCode}ï¼ˆæœŸé™: 3æ—¥ä»¥å†…ï¼‰`,
    };
  }

  validate(): boolean {
    return ["seven", "lawson", "family"].includes(this.storeType);
  }

  getDisplayName(): string {
    const names = { seven: "ã‚»ãƒ–ãƒ³ã‚¤ãƒ¬ãƒ–ãƒ³", lawson: "ãƒ­ãƒ¼ã‚½ãƒ³", family: "ãƒ•ã‚¡ãƒŸãƒªãƒ¼ãƒãƒ¼ãƒˆ" };
    return `ã‚³ãƒ³ãƒ“ãƒ‹æ‰•ã„ï¼ˆ${names[this.storeType]}ï¼‰`;
  }

  getFee(amount: number): number {
    return 110; // ä¸€å¾‹110å††
  }

  private generatePaymentCode(): string {
    return Math.random().toString(36).substring(2, 14).toUpperCase();
  }
}

// åˆ©ç”¨å´: PaymentStrategy ã®ã¿ã«ä¾å­˜
class Checkout {
  async process(strategy: PaymentStrategy, amount: number): Promise<void> {
    console.log(`æ±ºæ¸ˆæ–¹æ³•: ${strategy.getDisplayName()}`);

    if (!strategy.validate()) {
      throw new Error("æ±ºæ¸ˆæƒ…å ±ãŒç„¡åŠ¹ã§ã™");
    }

    const fee = strategy.getFee(amount);
    console.log(`æ‰‹æ•°æ–™: Â¥${fee}`);

    const result = await strategy.pay(amount);
    if (result.success) {
      console.log(`æ±ºæ¸ˆæˆåŠŸ: ${result.message}`);
      console.log(`å–å¼•ID: ${result.transactionId}`);
    } else {
      console.log(`æ±ºæ¸ˆå¤±æ•—: ${result.message}`);
    }
    // æ–°ã—ã„æ±ºæ¸ˆæ–¹æ³•ãŒè¿½åŠ ã•ã‚Œã¦ã‚‚ã€ã“ã®ã‚³ãƒ¼ãƒ‰ã¯å¤‰æ›´ä¸è¦
  }
}

// ä½¿ç”¨ä¾‹
const checkout = new Checkout();
await checkout.process(new CreditCardPayment("4111111111111111", "123", "12/25"), 10000);
await checkout.process(new PayPayPayment("user-123"), 5000);
await checkout.process(new ConvenienceStorePayment("seven"), 3000);
```

### 4.2 ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ 

```python
# Python: ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ 
from abc import ABC, abstractmethod
from typing import Any
import json


class FileExporter(ABC):
    """ãƒ•ã‚¡ã‚¤ãƒ«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ã‚¿ãƒ¼ã®æŠ½è±¡åŸºåº•ã‚¯ãƒ©ã‚¹"""

    @abstractmethod
    def export(self, data: list[dict]) -> bytes:
        """ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚¤ãƒˆåˆ—ã«ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""
        ...

    @abstractmethod
    def file_extension(self) -> str:
        """ãƒ•ã‚¡ã‚¤ãƒ«æ‹¡å¼µå­ã‚’è¿”ã™"""
        ...

    @abstractmethod
    def mime_type(self) -> str:
        """MIMEã‚¿ã‚¤ãƒ—ã‚’è¿”ã™"""
        ...

    def get_filename(self, base_name: str) -> str:
        """ãƒ•ã‚¡ã‚¤ãƒ«åã‚’ç”Ÿæˆ"""
        return f"{base_name}{self.file_extension()}"


class CsvExporter(FileExporter):
    def __init__(self, delimiter: str = ",", encoding: str = "utf-8"):
        self.delimiter = delimiter
        self.encoding = encoding

    def export(self, data: list[dict]) -> bytes:
        if not data:
            return b""
        headers = self.delimiter.join(data[0].keys())
        rows = [
            self.delimiter.join(self._escape(str(v)) for v in row.values())
            for row in data
        ]
        content = headers + "\n" + "\n".join(rows)
        return content.encode(self.encoding)

    def file_extension(self) -> str:
        return ".csv"

    def mime_type(self) -> str:
        return "text/csv"

    def _escape(self, value: str) -> str:
        if self.delimiter in value or '"' in value or '\n' in value:
            return f'"{value.replace(chr(34), chr(34)+chr(34))}"'
        return value


class JsonExporter(FileExporter):
    def __init__(self, indent: int = 2, ensure_ascii: bool = False):
        self.indent = indent
        self.ensure_ascii = ensure_ascii

    def export(self, data: list[dict]) -> bytes:
        return json.dumps(
            data,
            ensure_ascii=self.ensure_ascii,
            indent=self.indent,
        ).encode("utf-8")

    def file_extension(self) -> str:
        return ".json"

    def mime_type(self) -> str:
        return "application/json"


class ExcelExporter(FileExporter):
    """Excelå½¢å¼ã§ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""

    def export(self, data: list[dict]) -> bytes:
        # ç°¡æ˜“çš„ãªXML SpreadsheetMLå½¢å¼
        xml_parts = ['<?xml version="1.0"?>\n']
        xml_parts.append('<Workbook>\n<Worksheet ss:Name="Sheet1">\n<Table>\n')

        if data:
            # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ
            xml_parts.append('<Row>\n')
            for key in data[0].keys():
                xml_parts.append(f'  <Cell><Data ss:Type="String">{key}</Data></Cell>\n')
            xml_parts.append('</Row>\n')

            # ãƒ‡ãƒ¼ã‚¿è¡Œ
            for row in data:
                xml_parts.append('<Row>\n')
                for value in row.values():
                    data_type = "Number" if isinstance(value, (int, float)) else "String"
                    xml_parts.append(f'  <Cell><Data ss:Type="{data_type}">{value}</Data></Cell>\n')
                xml_parts.append('</Row>\n')

        xml_parts.append('</Table>\n</Worksheet>\n</Workbook>')
        return "".join(xml_parts).encode("utf-8")

    def file_extension(self) -> str:
        return ".xml"

    def mime_type(self) -> str:
        return "application/vnd.ms-excel"


class MarkdownExporter(FileExporter):
    """Markdown ãƒ†ãƒ¼ãƒ–ãƒ«å½¢å¼ã§ã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ"""

    def export(self, data: list[dict]) -> bytes:
        if not data:
            return b""

        headers = list(data[0].keys())
        lines = []

        # ãƒ˜ãƒƒãƒ€ãƒ¼è¡Œ
        lines.append("| " + " | ".join(headers) + " |")
        # åŒºåˆ‡ã‚Šç·š
        lines.append("| " + " | ".join("---" for _ in headers) + " |")
        # ãƒ‡ãƒ¼ã‚¿è¡Œ
        for row in data:
            values = [str(row.get(h, "")) for h in headers]
            lines.append("| " + " | ".join(values) + " |")

        return "\n".join(lines).encode("utf-8")

    def file_extension(self) -> str:
        return ".md"

    def mime_type(self) -> str:
        return "text/markdown"


# ãƒ¬ã‚¸ã‚¹ãƒˆãƒªãƒ‘ã‚¿ãƒ¼ãƒ³: ã‚¨ã‚¯ã‚¹ãƒãƒ¼ã‚¿ãƒ¼ã‚’å‹•çš„ã«ç®¡ç†
class ExporterRegistry:
    """ã‚¨ã‚¯ã‚¹ãƒãƒ¼ã‚¿ãƒ¼ã®ãƒ¬ã‚¸ã‚¹ãƒˆãƒª"""

    def __init__(self):
        self._exporters: dict[str, FileExporter] = {}

    def register(self, format_name: str, exporter: FileExporter) -> None:
        self._exporters[format_name] = exporter

    def get(self, format_name: str) -> FileExporter:
        if format_name not in self._exporters:
            available = ", ".join(self._exporters.keys())
            raise ValueError(
                f"æœªå¯¾å¿œã®ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ: {format_name}ï¼ˆåˆ©ç”¨å¯èƒ½: {available}ï¼‰"
            )
        return self._exporters[format_name]

    def available_formats(self) -> list[str]:
        return list(self._exporters.keys())


# ãƒ¬ã‚¸ã‚¹ãƒˆãƒªã®åˆæœŸåŒ–
registry = ExporterRegistry()
registry.register("csv", CsvExporter())
registry.register("json", JsonExporter())
registry.register("excel", ExcelExporter())
registry.register("markdown", MarkdownExporter())
registry.register("tsv", CsvExporter(delimiter="\t"))  # TSVã‚‚CSVã®æ´¾ç”Ÿ

# åˆ©ç”¨å´: FileExporter ã®ã¿ã«ä¾å­˜
def save_report(format_name: str, data: list[dict], filename: str) -> str:
    exporter = registry.get(format_name)
    content = exporter.export(data)
    full_path = exporter.get_filename(filename)

    with open(full_path, "wb") as f:
        f.write(content)

    print(f"ä¿å­˜å®Œäº†: {full_path} ({len(content)} bytes, {exporter.mime_type()})")
    return full_path


# ä½¿ç”¨ä¾‹
sample_data = [
    {"åå‰": "ç”°ä¸­å¤ªéƒ", "å¹´é½¢": 30, "éƒ¨ç½²": "é–‹ç™ºéƒ¨"},
    {"åå‰": "éˆ´æœ¨èŠ±å­", "å¹´é½¢": 25, "éƒ¨ç½²": "ä¼ç”»éƒ¨"},
    {"åå‰": "ä½è—¤æ¬¡éƒ", "å¹´é½¢": 35, "éƒ¨ç½²": "å–¶æ¥­éƒ¨"},
]

save_report("csv", sample_data, "report")       # report.csv
save_report("json", sample_data, "report")      # report.json
save_report("markdown", sample_data, "report")  # report.md
```

### 4.3 Observer ãƒ‘ã‚¿ãƒ¼ãƒ³ã§ã®ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

```typescript
// TypeScript: Observer ãƒ‘ã‚¿ãƒ¼ãƒ³
interface EventListener<T> {
  onEvent(event: T): void;
  getId(): string;
}

interface OrderEvent {
  type: "created" | "paid" | "shipped" | "delivered" | "cancelled";
  orderId: string;
  timestamp: Date;
  data?: Record<string, any>;
}

class EmailNotifier implements EventListener<OrderEvent> {
  constructor(private recipientEmail: string) {}

  onEvent(event: OrderEvent): void {
    const subjects: Record<string, string> = {
      created: "ã”æ³¨æ–‡ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸ",
      paid: "ãŠæ”¯æ‰•ã„ã‚’ç¢ºèªã—ã¾ã—ãŸ",
      shipped: "å•†å“ã‚’ç™ºé€ã—ã¾ã—ãŸ",
      delivered: "å•†å“ã‚’ãŠå±Šã‘ã—ã¾ã—ãŸ",
      cancelled: "ã”æ³¨æ–‡ãŒã‚­ãƒ£ãƒ³ã‚»ãƒ«ã•ã‚Œã¾ã—ãŸ",
    };
    console.log(
      `ğŸ“§ ${this.recipientEmail} ã¸ãƒ¡ãƒ¼ãƒ«é€ä¿¡: [${subjects[event.type]}] æ³¨æ–‡#${event.orderId}`
    );
  }

  getId(): string {
    return `email:${this.recipientEmail}`;
  }
}

class SlackNotifier implements EventListener<OrderEvent> {
  constructor(private channel: string, private webhookUrl: string) {}

  onEvent(event: OrderEvent): void {
    console.log(
      `ğŸ’¬ Slack #${this.channel}: æ³¨æ–‡ ${event.orderId} ãŒ ${event.type} ã«ãªã‚Šã¾ã—ãŸ`
    );
    // webhookUrl ã«POSTãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡
  }

  getId(): string {
    return `slack:${this.channel}`;
  }
}

class InventoryUpdater implements EventListener<OrderEvent> {
  onEvent(event: OrderEvent): void {
    if (event.type === "paid") {
      console.log(`ğŸ“¦ åœ¨åº«ã‚’ç¢ºä¿: æ³¨æ–‡ ${event.orderId}`);
    } else if (event.type === "cancelled") {
      console.log(`ğŸ“¦ åœ¨åº«ã‚’æˆ»ã™: æ³¨æ–‡ ${event.orderId}`);
    }
  }

  getId(): string {
    return "inventory-updater";
  }
}

class AnalyticsTracker implements EventListener<OrderEvent> {
  private eventCounts: Map<string, number> = new Map();

  onEvent(event: OrderEvent): void {
    const count = this.eventCounts.get(event.type) || 0;
    this.eventCounts.set(event.type, count + 1);
    console.log(
      `ğŸ“Š Analytics: ${event.type} ã‚¤ãƒ™ãƒ³ãƒˆè¨˜éŒ²ï¼ˆç´¯è¨ˆ: ${count + 1}ï¼‰`
    );
  }

  getId(): string {
    return "analytics-tracker";
  }

  getStats(): Map<string, number> {
    return new Map(this.eventCounts);
  }
}

// ã‚¤ãƒ™ãƒ³ãƒˆãƒã‚¹: ãƒªã‚¹ãƒŠãƒ¼ã®ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã‚’æ´»ç”¨
class EventBus<T> {
  private listeners: EventListener<T>[] = [];

  subscribe(listener: EventListener<T>): void {
    this.listeners.push(listener);
    console.log(`âœ… ãƒªã‚¹ãƒŠãƒ¼ç™»éŒ²: ${listener.getId()}`);
  }

  unsubscribe(listenerId: string): void {
    this.listeners = this.listeners.filter(l => l.getId() !== listenerId);
  }

  publish(event: T): void {
    // ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ : å…¨ãƒªã‚¹ãƒŠãƒ¼ã® onEvent ã‚’å‘¼ã¶
    // å„ãƒªã‚¹ãƒŠãƒ¼ãŒç•°ãªã‚‹å‡¦ç†ã‚’å®Ÿè¡Œ
    for (const listener of this.listeners) {
      try {
        listener.onEvent(event);
      } catch (error) {
        console.error(`ãƒªã‚¹ãƒŠãƒ¼ ${listener.getId()} ã§ã‚¨ãƒ©ãƒ¼:`, error);
      }
    }
  }
}

// ä½¿ç”¨ä¾‹
const orderEvents = new EventBus<OrderEvent>();
orderEvents.subscribe(new EmailNotifier("customer@example.com"));
orderEvents.subscribe(new SlackNotifier("orders", "https://hooks.slack.com/xxx"));
orderEvents.subscribe(new InventoryUpdater());
orderEvents.subscribe(new AnalyticsTracker());

// æ³¨æ–‡ã‚¤ãƒ™ãƒ³ãƒˆã‚’ç™ºè¡Œ â†’ å…¨ãƒªã‚¹ãƒŠãƒ¼ãŒå„è‡ªã®å‡¦ç†ã‚’å®Ÿè¡Œ
orderEvents.publish({
  type: "paid",
  orderId: "ORD-2024-001",
  timestamp: new Date(),
});
// ğŸ“§ customer@example.com ã¸ãƒ¡ãƒ¼ãƒ«é€ä¿¡: [ãŠæ”¯æ‰•ã„ã‚’ç¢ºèªã—ã¾ã—ãŸ] æ³¨æ–‡#ORD-2024-001
// ğŸ’¬ Slack #orders: æ³¨æ–‡ ORD-2024-001 ãŒ paid ã«ãªã‚Šã¾ã—ãŸ
// ğŸ“¦ åœ¨åº«ã‚’ç¢ºä¿: æ³¨æ–‡ ORD-2024-001
// ğŸ“Š Analytics: paid ã‚¤ãƒ™ãƒ³ãƒˆè¨˜éŒ²ï¼ˆç´¯è¨ˆ: 1ï¼‰
```

---

## 5. ã‚¢ãƒ‰ãƒ›ãƒƒã‚¯ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

### 5.1 ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰

```java
// Java: ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
public class Calculator {
    // åŒåãƒ¡ã‚½ãƒƒãƒ‰ã§å¼•æ•°ã®å‹ãŒç•°ãªã‚‹
    public int add(int a, int b) { return a + b; }
    public double add(double a, double b) { return a + b; }
    public String add(String a, String b) { return a + b; }

    // å¼•æ•°ã®æ•°ãŒç•°ãªã‚‹ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
    public int add(int a, int b, int c) { return a + b + c; }

    // å‹ã®çµ„ã¿åˆã‚ã›
    public double add(int a, double b) { return a + b; }
    public double add(double a, int b) { return a + b; }
}

// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å‘¼ã¶ãƒ¡ã‚½ãƒƒãƒ‰ãŒæ±ºå®šï¼ˆé™çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒï¼‰

// å®Ÿç”¨ä¾‹: ãƒ­ã‚°ãƒ¡ã‚½ãƒƒãƒ‰ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
public class Logger {
    public void log(String message) {
        log("INFO", message, null);
    }

    public void log(String level, String message) {
        log(level, message, null);
    }

    public void log(String level, String message, Throwable error) {
        System.out.printf("[%s] %s%n", level, message);
        if (error != null) {
            error.printStackTrace();
        }
    }

    public void log(String message, Object... args) {
        log("INFO", String.format(message, args), null);
    }
}
```

### 5.2 æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰

```python
# Python: æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
from __future__ import annotations
import math


class Vector:
    """2Dãƒ™ã‚¯ãƒˆãƒ«ã‚¯ãƒ©ã‚¹ï¼ˆæ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ã®æ´»ç”¨ï¼‰"""

    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    # åŠ ç®—: v1 + v2
    def __add__(self, other: Vector) -> Vector:
        return Vector(self.x + other.x, self.y + other.y)

    # æ¸›ç®—: v1 - v2
    def __sub__(self, other: Vector) -> Vector:
        return Vector(self.x - other.x, self.y - other.y)

    # ã‚¹ã‚«ãƒ©ãƒ¼ä¹—ç®—: v * 3
    def __mul__(self, scalar: float) -> Vector:
        return Vector(self.x * scalar, self.y * scalar)

    # å³å´ã‹ã‚‰ã®ã‚¹ã‚«ãƒ©ãƒ¼ä¹—ç®—: 3 * v
    def __rmul__(self, scalar: float) -> Vector:
        return self.__mul__(scalar)

    # ã‚¹ã‚«ãƒ©ãƒ¼é™¤ç®—: v / 2
    def __truediv__(self, scalar: float) -> Vector:
        if scalar == 0:
            raise ZeroDivisionError("ãƒ™ã‚¯ãƒˆãƒ«ã‚’0ã§å‰²ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“")
        return Vector(self.x / scalar, self.y / scalar)

    # è² ã®ãƒ™ã‚¯ãƒˆãƒ«: -v
    def __neg__(self) -> Vector:
        return Vector(-self.x, -self.y)

    # ç­‰ä¾¡æ¯”è¼ƒ: v1 == v2
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Vector):
            return NotImplemented
        return math.isclose(self.x, other.x) and math.isclose(self.y, other.y)

    # çµ¶å¯¾å€¤ï¼ˆå¤§ãã•ï¼‰: abs(v)
    def __abs__(self) -> float:
        return math.sqrt(self.x ** 2 + self.y ** 2)

    # çœŸå½å€¤: bool(v) â†’ ã‚¼ãƒ­ãƒ™ã‚¯ãƒˆãƒ«ã§ãªã‘ã‚Œã° True
    def __bool__(self) -> bool:
        return not (self.x == 0 and self.y == 0)

    # å†…ç©: v1 @ v2ï¼ˆè¡Œåˆ—ä¹—ç®—æ¼”ç®—å­ã‚’è»¢ç”¨ï¼‰
    def __matmul__(self, other: Vector) -> float:
        return self.x * other.x + self.y * other.y

    # æ–‡å­—åˆ—è¡¨ç¾
    def __repr__(self) -> str:
        return f"Vector({self.x}, {self.y})"

    def __str__(self) -> str:
        return f"({self.x}, {self.y})"

    # ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰
    def magnitude(self) -> float:
        return abs(self)

    def normalized(self) -> Vector:
        mag = self.magnitude()
        if mag == 0:
            raise ValueError("ã‚¼ãƒ­ãƒ™ã‚¯ãƒˆãƒ«ã¯æ­£è¦åŒ–ã§ãã¾ã›ã‚“")
        return self / mag

    def angle_to(self, other: Vector) -> float:
        """ä»–ã®ãƒ™ã‚¯ãƒˆãƒ«ã¨ã®è§’åº¦ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰"""
        dot = self @ other
        return math.acos(dot / (abs(self) * abs(other)))

    def rotate(self, angle: float) -> Vector:
        """ãƒ™ã‚¯ãƒˆãƒ«ã‚’å›è»¢ï¼ˆãƒ©ã‚¸ã‚¢ãƒ³ï¼‰"""
        cos_a = math.cos(angle)
        sin_a = math.sin(angle)
        return Vector(
            self.x * cos_a - self.y * sin_a,
            self.x * sin_a + self.y * cos_a,
        )


# ä½¿ç”¨ä¾‹
v1 = Vector(1, 2)
v2 = Vector(3, 4)

print(v1 + v2)          # (4, 6)
print(v1 - v2)          # (-2, -2)
print(v1 * 3)           # (3, 6)
print(3 * v1)           # (3, 6) â† __rmul__
print(v1 / 2)           # (0.5, 1.0)
print(-v1)              # (-1, -2)
print(abs(v1))           # 2.236...
print(v1 @ v2)          # 11ï¼ˆå†…ç©ï¼‰
print(v1 == Vector(1, 2))  # True
print(v1.normalized())  # (0.447..., 0.894...)

# ç‰©ç†ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³çš„ãªä½¿ã„æ–¹
position = Vector(0, 0)
velocity = Vector(1, 0.5)
acceleration = Vector(0, -0.1)  # é‡åŠ›

for step in range(10):
    velocity = velocity + acceleration
    position = position + velocity
    print(f"Step {step}: pos={position}, vel={velocity}")
```

```kotlin
// Kotlin: æ¼”ç®—å­ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
data class Money(val amount: Long, val currency: String) {
    // + æ¼”ç®—å­
    operator fun plus(other: Money): Money {
        require(currency == other.currency) { "é€šè²¨ãŒç•°ãªã‚Šã¾ã™: $currency vs ${other.currency}" }
        return Money(amount + other.amount, currency)
    }

    // - æ¼”ç®—å­
    operator fun minus(other: Money): Money {
        require(currency == other.currency) { "é€šè²¨ãŒç•°ãªã‚Šã¾ã™" }
        return Money(amount - other.amount, currency)
    }

    // * æ¼”ç®—å­ï¼ˆã‚¹ã‚«ãƒ©ãƒ¼å€ï¼‰
    operator fun times(multiplier: Int): Money {
        return Money(amount * multiplier, currency)
    }

    // æ¯”è¼ƒæ¼”ç®—å­
    operator fun compareTo(other: Money): Int {
        require(currency == other.currency) { "é€šè²¨ãŒç•°ãªã‚Šã¾ã™" }
        return amount.compareTo(other.amount)
    }

    // å˜é …ãƒã‚¤ãƒŠã‚¹
    operator fun unaryMinus(): Money = Money(-amount, currency)

    override fun toString(): String {
        val formatted = String.format("%,d", amount)
        val symbol = when (currency) {
            "JPY" -> "Â¥"
            "USD" -> "$"
            "EUR" -> "â‚¬"
            else -> currency
        }
        return "$symbol$formatted"
    }
}

// ä½¿ç”¨ä¾‹
val price = Money(1000, "JPY")
val tax = Money(100, "JPY")
val total = price + tax           // Â¥1,100
val double = price * 2            // Â¥2,000
val refund = -total               // Â¥-1,100

println(total)                    // Â¥1,100
println(price > tax)              // true
println(price + Money(500, "JPY")) // Â¥1,500
```

---

## 6. ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ï¼ˆã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼‰

```typescript
// TypeScript: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã«ã‚ˆã‚‹ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 

// æ±ç”¨çš„ãªãƒªãƒã‚¸ãƒˆãƒªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
interface Repository<T, ID> {
  findById(id: ID): Promise<T | null>;
  findAll(): Promise<T[]>;
  save(entity: T): Promise<T>;
  delete(id: ID): Promise<void>;
  count(): Promise<number>;
}

// æ±ç”¨çš„ãªæ¤œç´¢æ¡ä»¶
interface SearchCriteria<T> {
  field: keyof T;
  operator: "eq" | "gt" | "lt" | "contains" | "in";
  value: any;
}

// æ±ç”¨çš„ãªãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³çµæœ
interface PaginatedResult<T> {
  items: T[];
  total: number;
  page: number;
  pageSize: number;
  hasNext: boolean;
  hasPrev: boolean;
}

// ã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£å‹ã®å®šç¾©
interface User {
  id: string;
  name: string;
  email: string;
  createdAt: Date;
}

interface Product {
  id: string;
  name: string;
  price: number;
  stock: number;
}

// ã‚¤ãƒ³ãƒ¡ãƒ¢ãƒªå®Ÿè£…ï¼ˆãƒ†ã‚¹ãƒˆç”¨ï¼‰
class InMemoryRepository<T extends { id: string }> implements Repository<T, string> {
  private items: Map<string, T> = new Map();

  async findById(id: string): Promise<T | null> {
    return this.items.get(id) || null;
  }

  async findAll(): Promise<T[]> {
    return Array.from(this.items.values());
  }

  async save(entity: T): Promise<T> {
    this.items.set(entity.id, { ...entity });
    return entity;
  }

  async delete(id: string): Promise<void> {
    this.items.delete(id);
  }

  async count(): Promise<number> {
    return this.items.size;
  }

  // è¿½åŠ : æ¤œç´¢æ©Ÿèƒ½
  async search(criteria: SearchCriteria<T>[]): Promise<T[]> {
    const all = await this.findAll();
    return all.filter(item =>
      criteria.every(c => this.matchCriteria(item, c))
    );
  }

  private matchCriteria(item: T, criteria: SearchCriteria<T>): boolean {
    const value = item[criteria.field];
    switch (criteria.operator) {
      case "eq": return value === criteria.value;
      case "gt": return value > criteria.value;
      case "lt": return value < criteria.value;
      case "contains": return String(value).includes(criteria.value);
      case "in": return Array.isArray(criteria.value) && criteria.value.includes(value);
      default: return false;
    }
  }
}

// ä½¿ç”¨ä¾‹: åŒã˜ Repository å®Ÿè£…ã§ç•°ãªã‚‹å‹ã‚’æ‰±ã†
const userRepo = new InMemoryRepository<User>();
const productRepo = new InMemoryRepository<Product>();

// å‹å®‰å…¨: User ã¨ Product ã‚’é–“é•ãˆã‚‹ã¨ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã‚¨ãƒ©ãƒ¼
await userRepo.save({ id: "1", name: "ç”°ä¸­", email: "tanaka@test.com", createdAt: new Date() });
await productRepo.save({ id: "1", name: "ãƒãƒ¼ãƒˆPC", price: 150000, stock: 10 });

// ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã«ã‚ˆã‚‹æ±ç”¨ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£é–¢æ•°
function paginate<T>(items: T[], page: number, pageSize: number): PaginatedResult<T> {
  const start = (page - 1) * pageSize;
  const paginatedItems = items.slice(start, start + pageSize);
  const total = items.length;

  return {
    items: paginatedItems,
    total,
    page,
    pageSize,
    hasNext: start + pageSize < total,
    hasPrev: page > 1,
  };
}

// å‹å®‰å…¨ã«ã©ã®å‹ã§ã‚‚ä½¿ãˆã‚‹
const userPage: PaginatedResult<User> = paginate(await userRepo.findAll(), 1, 10);
const productPage: PaginatedResult<Product> = paginate(await productRepo.findAll(), 1, 20);
```

```python
# Python: ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼ˆtyping.Genericï¼‰
from typing import TypeVar, Generic, Optional, Callable
from dataclasses import dataclass


T = TypeVar("T")
E = TypeVar("E")


@dataclass
class Result(Generic[T, E]):
    """Rust ã® Result å‹ã‚’æ¨¡å€£ã—ãŸã‚¸ã‚§ãƒãƒªãƒƒã‚¯å‹"""
    _value: Optional[T] = None
    _error: Optional[E] = None
    _is_ok: bool = True

    @staticmethod
    def ok(value: T) -> "Result[T, E]":
        return Result(_value=value, _is_ok=True)

    @staticmethod
    def err(error: E) -> "Result[T, E]":
        return Result(_error=error, _is_ok=False)

    def is_ok(self) -> bool:
        return self._is_ok

    def is_err(self) -> bool:
        return not self._is_ok

    def unwrap(self) -> T:
        if not self._is_ok:
            raise ValueError(f"Result is Err: {self._error}")
        return self._value  # type: ignore

    def unwrap_or(self, default: T) -> T:
        return self._value if self._is_ok else default  # type: ignore

    def map(self, fn: Callable[[T], "U"]) -> "Result[U, E]":
        """æˆåŠŸå€¤ã‚’å¤‰æ›"""
        if self._is_ok:
            return Result.ok(fn(self._value))  # type: ignore
        return Result.err(self._error)  # type: ignore

    def flat_map(self, fn: Callable[[T], "Result[U, E]"]) -> "Result[U, E]":
        """æˆåŠŸå€¤ã‚’åˆ¥ã® Result ã«å¤‰æ›"""
        if self._is_ok:
            return fn(self._value)  # type: ignore
        return Result.err(self._error)  # type: ignore

    def __repr__(self) -> str:
        if self._is_ok:
            return f"Ok({self._value})"
        return f"Err({self._error})"


# ä½¿ç”¨ä¾‹
def parse_int(s: str) -> Result[int, str]:
    try:
        return Result.ok(int(s))
    except ValueError:
        return Result.err(f"'{s}' ã¯æ•´æ•°ã«å¤‰æ›ã§ãã¾ã›ã‚“")

def divide(a: int, b: int) -> Result[float, str]:
    if b == 0:
        return Result.err("ã‚¼ãƒ­é™¤ç®—ã‚¨ãƒ©ãƒ¼")
    return Result.ok(a / b)


# ãƒ¡ã‚½ãƒƒãƒ‰ãƒã‚§ãƒ¼ãƒ³
result = (
    parse_int("42")
    .map(lambda x: x * 2)
    .flat_map(lambda x: divide(x, 7))
)
print(result)  # Ok(12.0)

error_result = (
    parse_int("abc")
    .map(lambda x: x * 2)
)
print(error_result)  # Err('abc' ã¯æ•´æ•°ã«å¤‰æ›ã§ãã¾ã›ã‚“)
```

---

## 7. é™çš„ vs å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ

```
é™çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒï¼ˆã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«æ±ºå®šï¼‰:
  â†’ ãƒ¡ã‚½ãƒƒãƒ‰ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰
  â†’ Rust ã®ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼ˆå˜ç›¸åŒ–ï¼‰
  â†’ C++ ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
  â†’ é«˜é€Ÿï¼ˆã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åŒ–å¯èƒ½ï¼‰

å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒï¼ˆå®Ÿè¡Œæ™‚ã«æ±ºå®šï¼‰:
  â†’ ã‚µãƒ–ã‚¿ã‚¤ãƒ—ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 
  â†’ Java/C# ã®ä»®æƒ³ãƒ¡ã‚½ãƒƒãƒ‰
  â†’ Rust ã® dyn Trait
  â†’ æŸ”è»Ÿï¼ˆå®Ÿè¡Œæ™‚ã«ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã§åˆ†å²ï¼‰
  â†’ vtable ã®ã‚ªãƒ¼ãƒãƒ¼ãƒ˜ãƒƒãƒ‰ã‚ã‚Šï¼ˆã»ã¼ã‚¼ãƒ­ã ãŒï¼‰
```

```rust
// Rust: é™çš„ vs å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã®é¸æŠ
trait Drawable {
    fn draw(&self);
    fn bounding_box(&self) -> (f64, f64, f64, f64);
}

struct Circle { x: f64, y: f64, radius: f64 }
struct Rect { x: f64, y: f64, width: f64, height: f64 }

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing circle at ({}, {}) r={}", self.x, self.y, self.radius);
    }
    fn bounding_box(&self) -> (f64, f64, f64, f64) {
        (self.x - self.radius, self.y - self.radius,
         self.x + self.radius, self.y + self.radius)
    }
}

impl Drawable for Rect {
    fn draw(&self) {
        println!("Drawing rect at ({}, {}) {}x{}", self.x, self.y, self.width, self.height);
    }
    fn bounding_box(&self) -> (f64, f64, f64, f64) {
        (self.x, self.y, self.x + self.width, self.y + self.height)
    }
}

// é™çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒï¼ˆã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ï¼‰: ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å‹ãŒç¢ºå®š
// â†’ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒå‹ã”ã¨ã«å°‚ç”¨ã®ã‚³ãƒ¼ãƒ‰ã‚’ç”Ÿæˆï¼ˆå˜ç›¸åŒ–: monomorphizationï¼‰
fn draw_static<T: Drawable>(item: &T) {
    item.draw(); // ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åŒ–å¯èƒ½ã€é«˜é€Ÿ
}
// ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«å¾Œ:
// fn draw_static_Circle(item: &Circle) { item.draw(); }
// fn draw_static_Rect(item: &Rect) { item.draw(); }

// å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒï¼ˆãƒˆãƒ¬ã‚¤ãƒˆã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼‰: å®Ÿè¡Œæ™‚ã«å‹ãŒç¢ºå®š
fn draw_dynamic(item: &dyn Drawable) {
    item.draw(); // vtable çµŒç”±ã€æŸ”è»Ÿ
}

// å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒãŒå¿…è¦ãªå ´é¢: ç•°ãªã‚‹å‹ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
fn main() {
    // é™çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ: åŒã˜å‹ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
    let circles = vec![
        Circle { x: 0.0, y: 0.0, radius: 5.0 },
        Circle { x: 10.0, y: 10.0, radius: 3.0 },
    ];
    for c in &circles {
        draw_static(c); // Circle å°‚ç”¨ã®ã‚³ãƒ¼ãƒ‰ãŒå‘¼ã°ã‚Œã‚‹
    }

    // å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ: ç•°ãªã‚‹å‹ã®æ··åœ¨ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³
    let shapes: Vec<Box<dyn Drawable>> = vec![
        Box::new(Circle { x: 0.0, y: 0.0, radius: 5.0 }),
        Box::new(Rect { x: 1.0, y: 1.0, width: 3.0, height: 4.0 }),
    ];
    for shape in &shapes {
        draw_dynamic(shape.as_ref()); // vtable çµŒç”±ã§å‘¼ã°ã‚Œã‚‹
    }
}
```

### 7.1 é¸æŠåŸºæº–

```
é™çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã‚’é¸ã¶ã¹ãå ´é¢:
  âœ“ ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒæœ€é‡è¦ï¼ˆã‚²ãƒ¼ãƒ ã®å†…éƒ¨ãƒ«ãƒ¼ãƒ—ã€æ•°å€¤è¨ˆç®—ï¼‰
  âœ“ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ã«å‹ãŒç¢ºå®šã—ã¦ã„ã‚‹
  âœ“ åŒã˜å‹ã®ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã‚’æ‰±ã†
  âœ“ ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å±•é–‹ã®ãƒ¡ãƒªãƒƒãƒˆãŒå¤§ãã„

å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã‚’é¸ã¶ã¹ãå ´é¢:
  âœ“ ç•°ãªã‚‹å‹ã‚’åŒã˜ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã§æ‰±ã„ãŸã„
  âœ“ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚·ã‚¹ãƒ†ãƒ ã®ã‚ˆã†ã«å®Ÿè¡Œæ™‚ã«å‹ãŒæ±ºã¾ã‚‹
  âœ“ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚é–“ã‚’çŸ­ç¸®ã—ãŸã„ï¼ˆã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ã®è†¨å¼µã‚’é¿ã‘ã‚‹ï¼‰
  âœ“ ãƒã‚¤ãƒŠãƒªã‚µã‚¤ã‚ºã‚’å°ã•ãã—ãŸã„

  åˆ¤æ–­ãƒ•ãƒ­ãƒ¼:
  1. ç•°ãªã‚‹å‹ã‚’æ··åœ¨ã•ã›ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼Ÿ
     â†’ Yes â†’ å‹•çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ
  2. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãŒæ¥µã‚ã¦é‡è¦ï¼Ÿ
     â†’ Yes â†’ é™çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒ
  3. ã©ã¡ã‚‰ã§ã‚‚ã‚ˆã„å ´åˆ
     â†’ é™çš„ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒã‚’å„ªå…ˆï¼ˆå‹å®‰å…¨æ€§ãŒé«˜ã„ï¼‰
```

---

## 8. ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã¨ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³

```
ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã‚’æ´»ç”¨ã™ã‚‹ä¸»è¦ãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³:

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ ãƒ‘ã‚¿ãƒ¼ãƒ³          â”‚ ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã®æ´»ç”¨                  â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚ Strategy         â”‚ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®åˆ‡ã‚Šæ›¿ãˆ                   â”‚
  â”‚ Observer         â”‚ é€šçŸ¥å…ˆã®å‹•çš„ãªè¿½åŠ /å‰Šé™¤                  â”‚
  â”‚ Command          â”‚ ã‚³ãƒãƒ³ãƒ‰ã®çµ±ä¸€çš„ãªå®Ÿè¡Œ/Undo               â”‚
  â”‚ Template Method  â”‚ å‡¦ç†ãƒ•ãƒ­ãƒ¼ã®å…±é€šåŒ– + ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºãƒã‚¤ãƒ³ãƒˆ  â”‚
  â”‚ Factory Method   â”‚ ç”Ÿæˆã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹•çš„ãªåˆ‡ã‚Šæ›¿ãˆ      â”‚
  â”‚ State            â”‚ çŠ¶æ…‹ã«å¿œã˜ãŸæŒ¯ã‚‹èˆã„ã®åˆ‡ã‚Šæ›¿ãˆ            â”‚
  â”‚ Visitor          â”‚ æ“ä½œã®è¿½åŠ ï¼ˆãƒ€ãƒ–ãƒ«ãƒ‡ã‚£ã‚¹ãƒ‘ãƒƒãƒï¼‰          â”‚
  â”‚ Chain of Resp.   â”‚ å‡¦ç†ã®é€£é–ã¨å§”è­²                        â”‚
  â”‚ Decorator        â”‚ æ©Ÿèƒ½ã®å‹•çš„ãªè¿½åŠ                         â”‚
  â”‚ Adapter          â”‚ äº’æ›æ€§ã®ãªã„IFã®å¤‰æ›                     â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

```typescript
// State ãƒ‘ã‚¿ãƒ¼ãƒ³: çŠ¶æ…‹ã«å¿œã˜ãŸæŒ¯ã‚‹èˆã„ã®åˆ‡ã‚Šæ›¿ãˆ
interface OrderState {
  readonly name: string;
  pay(order: Order): void;
  ship(order: Order): void;
  deliver(order: Order): void;
  cancel(order: Order): void;
}

class PendingState implements OrderState {
  readonly name = "ä¿ç•™ä¸­";

  pay(order: Order): void {
    console.log("æ”¯æ‰•ã„å‡¦ç†ã‚’é–‹å§‹ã—ã¾ã™");
    order.setState(new PaidState());
  }

  ship(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: æ”¯æ‰•ã„å‰ã«ç™ºé€ã§ãã¾ã›ã‚“");
  }

  deliver(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: æ”¯æ‰•ã„å‰ã«é…é”ã§ãã¾ã›ã‚“");
  }

  cancel(order: Order): void {
    console.log("æ³¨æ–‡ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ");
    order.setState(new CancelledState());
  }
}

class PaidState implements OrderState {
  readonly name = "æ”¯æ‰•ã„æ¸ˆã¿";

  pay(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: æ—¢ã«æ”¯æ‰•ã„æ¸ˆã¿ã§ã™");
  }

  ship(order: Order): void {
    console.log("å•†å“ã‚’ç™ºé€ã—ã¾ã—ãŸ");
    order.setState(new ShippedState());
  }

  deliver(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: ç™ºé€å‰ã«é…é”ã§ãã¾ã›ã‚“");
  }

  cancel(order: Order): void {
    console.log("è¿”é‡‘å‡¦ç†ã‚’é–‹å§‹ã—ã€æ³¨æ–‡ã‚’ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã—ã¾ã—ãŸ");
    order.setState(new CancelledState());
  }
}

class ShippedState implements OrderState {
  readonly name = "ç™ºé€æ¸ˆã¿";

  pay(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: æ—¢ã«æ”¯æ‰•ã„æ¸ˆã¿ã§ã™");
  }

  ship(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: æ—¢ã«ç™ºé€æ¸ˆã¿ã§ã™");
  }

  deliver(order: Order): void {
    console.log("å•†å“ãŒé…é”ã•ã‚Œã¾ã—ãŸ");
    order.setState(new DeliveredState());
  }

  cancel(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: ç™ºé€å¾Œã®ã‚­ãƒ£ãƒ³ã‚»ãƒ«ã¯å—ä»˜çª“å£ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„");
  }
}

class DeliveredState implements OrderState {
  readonly name = "é…é”æ¸ˆã¿";

  pay(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: æ—¢ã«é…é”æ¸ˆã¿ã§ã™");
  }

  ship(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: æ—¢ã«é…é”æ¸ˆã¿ã§ã™");
  }

  deliver(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: æ—¢ã«é…é”æ¸ˆã¿ã§ã™");
  }

  cancel(order: Order): void {
    console.log("è¿”å“å‡¦ç†ã‚’é–‹å§‹ã—ã¦ãã ã•ã„");
  }
}

class CancelledState implements OrderState {
  readonly name = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ¸ˆã¿";

  pay(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ¸ˆã¿ã®æ³¨æ–‡ã§ã™");
  }

  ship(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ¸ˆã¿ã®æ³¨æ–‡ã§ã™");
  }

  deliver(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ¸ˆã¿ã®æ³¨æ–‡ã§ã™");
  }

  cancel(order: Order): void {
    console.log("ã‚¨ãƒ©ãƒ¼: æ—¢ã«ã‚­ãƒ£ãƒ³ã‚»ãƒ«æ¸ˆã¿ã§ã™");
  }
}

class Order {
  private state: OrderState = new PendingState();

  constructor(public readonly id: string) {}

  setState(state: OrderState): void {
    console.log(`  çŠ¶æ…‹é·ç§»: ${this.state.name} â†’ ${state.name}`);
    this.state = state;
  }

  getStateName(): string {
    return this.state.name;
  }

  // ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ : ç¾åœ¨ã®çŠ¶æ…‹ã«å¿œã˜ãŸæŒ¯ã‚‹èˆã„ãŒå‘¼ã°ã‚Œã‚‹
  pay(): void { this.state.pay(this); }
  ship(): void { this.state.ship(this); }
  deliver(): void { this.state.deliver(this); }
  cancel(): void { this.state.cancel(this); }
}

// ä½¿ç”¨ä¾‹
const order = new Order("ORD-001");
order.pay();      // æ”¯æ‰•ã„å‡¦ç† â†’ PaidState
order.ship();     // ç™ºé€ â†’ ShippedState
order.deliver();  // é…é” â†’ DeliveredState
order.cancel();   // è¿”å“å‡¦ç†ã‚’é–‹å§‹ã—ã¦ãã ã•ã„
```

---

## 9. ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã®ã‚¢ãƒ³ãƒãƒ‘ã‚¿ãƒ¼ãƒ³

```
ã‚¢ãƒ³ãƒãƒ‘ã‚¿ãƒ¼ãƒ³1: å‹ãƒã‚§ãƒƒã‚¯ã®æ°¾æ¿«
  â†’ instanceof / typeof / type() ã‚’å¤šç”¨ã—ã¦åˆ†å²
  â†’ ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã§è§£æ±ºã™ã¹ã

ã‚¢ãƒ³ãƒãƒ‘ã‚¿ãƒ¼ãƒ³2: ãƒ€ã‚¦ãƒ³ã‚­ãƒ£ã‚¹ãƒˆ
  â†’ è¦ªå‹ã‚’å­å‹ã«ã‚­ãƒ£ã‚¹ãƒˆã—ã¦å­å›ºæœ‰ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’å‘¼ã¶
  â†’ ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹è¨­è¨ˆã®è¦‹ç›´ã—ãŒå¿…è¦

ã‚¢ãƒ³ãƒãƒ‘ã‚¿ãƒ¼ãƒ³3: ç©ºå®Ÿè£…
  â†’ ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ã®ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ç©ºå®Ÿè£…ã§æº€ãŸã™
  â†’ ISPï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹åˆ†é›¢ã®åŸå‰‡ï¼‰é•å

ã‚¢ãƒ³ãƒãƒ‘ã‚¿ãƒ¼ãƒ³4: éå‰°ãªãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ 
  â†’ å¤‰æ›´ã®è¦‹è¾¼ã¿ãŒãªã„éƒ¨åˆ†ã¾ã§æŠ½è±¡åŒ–
  â†’ YAGNI é•å
```

```typescript
// âŒ ã‚¢ãƒ³ãƒãƒ‘ã‚¿ãƒ¼ãƒ³: å‹ãƒã‚§ãƒƒã‚¯ã®æ°¾æ¿«
function calculateDiscount(customer: Customer): number {
  if (customer instanceof PremiumCustomer) {
    return 0.2; // 20%å‰²å¼•
  } else if (customer instanceof RegularCustomer) {
    return 0.05; // 5%å‰²å¼•
  } else if (customer instanceof NewCustomer) {
    return 0.1; // 10%å‰²å¼•ï¼ˆåˆå›ç‰¹å…¸ï¼‰
  }
  return 0;
}
// æ–°ã—ã„é¡§å®¢ã‚¿ã‚¤ãƒ—è¿½åŠ ã®ãŸã³ã«ã“ã“ã‚’ä¿®æ­£ â†’ OCPé•å

// âœ… ãƒãƒªãƒ¢ãƒ¼ãƒ•ã‚£ã‚ºãƒ ã§è§£æ±º
interface Customer {
  getDiscount(): number;
  getName(): string;
}

class PremiumCustomer implements Customer {
  getDiscount(): number { return 0.2; }
  getName(): string { return "ãƒ—ãƒ¬ãƒŸã‚¢ãƒ ä¼šå“¡"; }
}

class RegularCustomer implements Customer {
  getDiscount(): number { return 0.05; }
  getName(): string { return "ä¸€èˆ¬ä¼šå“¡"; }
}

class NewCustomer implements Customer {
  getDiscount(): number { return 0.1; }
  getName(): string { return "æ–°è¦ä¼šå“¡"; }
}

// åˆ©ç”¨å´: Customer.getDiscount() ã‚’å‘¼ã¶ã ã‘
function calculateTotal(customer: Customer, price: number): number {
  const discount = customer.getDiscount();
  return price * (1 - discount);
}
```

---

## ã¾ã¨ã‚

| ç¨®é¡ | æ±ºå®šæ™‚æœŸ | æ‰‹æ®µ | å…¸å‹ä¾‹ |
|------|---------|------|--------|
| ã‚µãƒ–ã‚¿ã‚¤ãƒ— | å®Ÿè¡Œæ™‚ | ç¶™æ‰¿/ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ | Strategy, Plugin, Observer |
| ãƒ‘ãƒ©ãƒ¡ãƒˆãƒªãƒƒã‚¯ | ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ | ã‚¸ã‚§ãƒãƒªã‚¯ã‚¹ | List<T>, Repository<T, ID> |
| ã‚¢ãƒ‰ãƒ›ãƒƒã‚¯ | ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ™‚ | ã‚ªãƒ¼ãƒãƒ¼ãƒ­ãƒ¼ãƒ‰ | add(int), add(double), æ¼”ç®—å­ |

| è¨­è¨ˆåŸå‰‡ | ãƒã‚¤ãƒ³ãƒˆ |
|----------|---------|
| OCP | æ–°æ©Ÿèƒ½ã¯ã‚¯ãƒ©ã‚¹è¿½åŠ ã§å¯¾å¿œï¼ˆæ—¢å­˜ã‚³ãƒ¼ãƒ‰å¤‰æ›´ãªã—ï¼‰ |
| LSP | ã‚µãƒ–ã‚¿ã‚¤ãƒ—ã¯è¦ªå‹ã®ä»£æ›¿ã¨ã—ã¦æ­£ã—ãå‹•ã |
| DIP | å…·è±¡ã§ã¯ãªãæŠ½è±¡ï¼ˆã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ï¼‰ã«ä¾å­˜ |
| ISP | ä¸è¦ãªãƒ¡ã‚½ãƒƒãƒ‰ã‚’å«ã¾ãªã„å°ã•ãªã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹ |

---

## æ¬¡ã«èª­ã‚€ã¹ãã‚¬ã‚¤ãƒ‰
â†’ [[03-abstraction.md]] -- æŠ½è±¡åŒ–

---

## å‚è€ƒæ–‡çŒ®
1. Cardelli, L. "On Understanding Types, Data Abstraction, and Polymorphism." 1985.
2. Gamma, E. et al. "Design Patterns." Addison-Wesley, 1994.
3. Bloch, J. "Effective Java." 3rd edition, 2018.
4. Martin, R. "Clean Architecture." Prentice Hall, 2017.
5. Wadler, P. "Theorems for free!" 1989.
6. Liskov, B. and Wing, J. "A Behavioral Notion of Subtyping." 1994.
